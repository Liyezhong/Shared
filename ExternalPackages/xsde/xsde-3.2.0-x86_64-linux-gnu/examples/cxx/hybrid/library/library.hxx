// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef LIBRARY_HXX
#define LIBRARY_HXX

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include <string>
#include <xsde/cxx/hybrid/xml-schema.hxx>
#include <xsde/cxx/hybrid/sequence.hxx>

namespace xml_schema
{
  using ::xsde::cxx::hybrid::any_type;
  typedef ::std::string any_simple_type;

  typedef signed char byte;
  using ::xsde::cxx::hybrid::byte_base;

  typedef unsigned char unsigned_byte;
  using ::xsde::cxx::hybrid::unsigned_byte_base;

  typedef short short_;
  using ::xsde::cxx::hybrid::short_base;

  typedef unsigned short unsigned_short;
  using ::xsde::cxx::hybrid::unsigned_short_base;

  typedef int int_;
  using ::xsde::cxx::hybrid::int_base;

  typedef unsigned int unsigned_int;
  using ::xsde::cxx::hybrid::unsigned_int_base;

  typedef long long long_;
  using ::xsde::cxx::hybrid::long_base;

  typedef unsigned long long unsigned_long;
  using ::xsde::cxx::hybrid::unsigned_long_base;

  typedef long integer;
  using ::xsde::cxx::hybrid::integer_base;

  typedef long non_positive_integer;
  using ::xsde::cxx::hybrid::non_positive_integer_base;

  typedef unsigned long non_negative_integer;
  using ::xsde::cxx::hybrid::non_negative_integer_base;

  typedef unsigned long positive_integer;
  using ::xsde::cxx::hybrid::positive_integer_base;

  typedef long negative_integer;
  using ::xsde::cxx::hybrid::negative_integer_base;

  typedef bool boolean;
  using ::xsde::cxx::hybrid::boolean_base;

  typedef float float_;
  using ::xsde::cxx::hybrid::float_base;

  typedef double double_;
  using ::xsde::cxx::hybrid::double_base;

  typedef double decimal;
  using ::xsde::cxx::hybrid::decimal_base;

  typedef ::std::string string;

  typedef ::std::string normalized_string;

  typedef ::std::string token;

  typedef ::std::string name;

  typedef ::std::string nmtoken;

  typedef ::xsde::cxx::string_sequence nmtokens;

  typedef ::std::string ncname;

  typedef ::std::string language;

  typedef ::std::string id;

  typedef ::std::string idref;

  typedef ::xsde::cxx::string_sequence idrefs;

  typedef ::std::string uri;

  using ::xsde::cxx::qname;

  using ::xsde::cxx::buffer;
  typedef ::xsde::cxx::buffer base64_binary;
  typedef ::xsde::cxx::buffer hex_binary;

  using ::xsde::cxx::time_zone;
  using ::xsde::cxx::date;
  using ::xsde::cxx::date_time;
  using ::xsde::cxx::duration;
  using ::xsde::cxx::gday;
  using ::xsde::cxx::gmonth;
  using ::xsde::cxx::gmonth_day;
  using ::xsde::cxx::gyear;
  using ::xsde::cxx::gyear_month;
  using ::xsde::cxx::time;

  using ::xsde::cxx::hybrid::pod_sequence;
  using ::xsde::cxx::hybrid::fix_sequence;
  using ::xsde::cxx::hybrid::var_sequence;
  using ::xsde::cxx::string_sequence;
  using ::xsde::cxx::hybrid::data_sequence;
}

namespace library
{
  class isbn;
  class title;
  class genre;
  class author;
  class book;
  class catalog;
}


#ifndef XSDE_DONT_INCLUDE_INLINE
#define XSDE_DONT_INCLUDE_INLINE

#undef XSDE_DONT_INCLUDE_INLINE
#else

#endif // XSDE_DONT_INCLUDE_INLINE

namespace library
{
  // isbn (fixed-length)
  //
  class isbn: public ::xml_schema::unsigned_int_base
  {
    public:
    isbn ();
  };

  // title (fixed-length)
  //
  class title: public ::std::string
  {
    public:
    title ();

    title (const title&);
    title& operator= (const title&);

    ~title ();

    // lang
    //
    bool
    lang_present () const;

    void
    lang_present (bool);

    const ::std::string&
    lang () const;

    ::std::string&
    lang ();

    void
    lang (const ::std::string&);

    private:
    ::std::string lang_;
    unsigned char lang_present_;
  };

  // genre (fixed-length)
  //
  class genre
  {
    public:
    enum value_type
    {
      romance,
      fiction,
      horror,
      history,
      philosophy
    };

    genre ();
    genre (value_type);

    void
    value (value_type);

    operator value_type () const
    {
      return value_;
    }

    const char*
    string () const;

    private:
    value_type value_;
  };

  // author (fixed-length)
  //
  class author
  {
    public:
    author ();

    author (const author&);
    author& operator= (const author&);

    ~author ();

    // name
    //
    const ::std::string&
    name () const;

    ::std::string&
    name ();

    void
    name (const ::std::string&);

    // born
    //
    const ::xml_schema::date&
    born () const;

    ::xml_schema::date&
    born ();

    void
    born (const ::xml_schema::date&);

    // died
    //
    bool
    died_present () const;

    void
    died_present (bool);

    const ::xml_schema::date&
    died () const;

    ::xml_schema::date&
    died ();

    void
    died (const ::xml_schema::date&);

    private:
    ::std::string name_;
    ::xml_schema::date born_;
    ::xml_schema::date died_;
    unsigned char died_present_;
  };

  // book (variable-length)
  //
  class book
  {
    private:
    book (const book&);
    book& operator= (const book&);

    public:
    book ();

    ~book ();

    // available
    //
    bool
    available_default () const;

    void
    available_default (bool);

    bool
    available () const;

    bool&
    available ();

    void
    available (bool);

    static bool
    available_default_value ();

    // isbn
    //
    const ::library::isbn&
    isbn () const;

    ::library::isbn&
    isbn ();

    void
    isbn (const ::library::isbn&);

    // title
    //
    const ::library::title&
    title () const;

    ::library::title&
    title ();

    void
    title (const ::library::title&);

    // genre
    //
    const ::library::genre&
    genre () const;

    ::library::genre&
    genre ();

    void
    genre (const ::library::genre&);

    // author
    //
    typedef ::xsde::cxx::hybrid::fix_sequence< ::library::author > author_sequence;
    typedef author_sequence::iterator author_iterator;
    typedef author_sequence::const_iterator author_const_iterator;

    const author_sequence&
    author () const;

    author_sequence&
    author ();

    private:
    bool available_;
    ::library::isbn isbn_;
    ::library::title title_;
    ::library::genre genre_;
    author_sequence author_;
  };

  // catalog (variable-length)
  //
  class catalog
  {
    private:
    catalog (const catalog&);
    catalog& operator= (const catalog&);

    public:
    catalog ();

    ~catalog ();

    // book
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::library::book > book_sequence;
    typedef book_sequence::iterator book_iterator;
    typedef book_sequence::const_iterator book_const_iterator;

    const book_sequence&
    book () const;

    book_sequence&
    book ();

    private:
    book_sequence book_;
  };
}

#ifndef XSDE_DONT_INCLUDE_INLINE

#endif // XSDE_DONT_INCLUDE_INLINE

#ifndef XSDE_DONT_INCLUDE_INLINE
#include "library.ixx"
#endif // XSDE_DONT_INCLUDE_INLINE

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // LIBRARY_HXX
