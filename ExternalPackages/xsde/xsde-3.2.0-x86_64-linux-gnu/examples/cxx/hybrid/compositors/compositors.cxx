// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "compositors.hxx"

#include <stdlib.h>
#include <new>

// simple_choice
//

simple_choice::
simple_choice ()
{
  this->choice_arm_ = choice_arm_tag (3);
}

simple_choice::
~simple_choice ()
{
  this->choice_arm (choice_arm_tag (3));
}

void simple_choice::
choice_arm (choice_arm_tag x)
{
  if (this->choice_arm_ == x)
    return;

  switch (this->choice_arm_)
  {
    case c_tag:
    {
      typedef c_sequence _dtor;
      reinterpret_cast< c_sequence& > (this->choice_.c_).~_dtor ();
      break;
    }
    default:
    break;
  }

  this->choice_arm_ = choice_arm_tag (3);

  switch (x)
  {
    case b_tag:
    {
      this->choice_.b_.data_[sizeof (int)] = false;
      break;
    }
    case c_tag:
    {
      new (&this->choice_.c_) c_sequence;
      break;
    }
    default:
    break;
  }

  this->choice_arm_ = x;
}

// nested_choice
//

nested_choice::
nested_choice ()
{
  this->choice_present_ = false;
}

nested_choice::
~nested_choice ()
{
}

nested_choice::
nested_choice (const nested_choice& x)
{
  XSDE_UNUSED (x);
  this->choice_present_ = x.choice_present_;
  if (this->choice_present_)
    this->choice_ = x.choice_;
  this->d_ = x.d_;
}

nested_choice& nested_choice::
operator= (const nested_choice& x)
{
  XSDE_UNUSED (x);
  this->choice_present_ = x.choice_present_;
  if (this->choice_present_)
    this->choice_ = x.choice_;
  this->d_ = x.d_;
  return *this;
}

nested_choice::choice_type::
choice_type ()
{
  this->choice_arm_ = choice_arm_tag (2);
}

nested_choice::choice_type::
~choice_type ()
{
  this->choice_arm (choice_arm_tag (2));
}

nested_choice::choice_type::
choice_type (const choice_type& x)
{
  this->choice_arm_ = x.choice_arm_;
  switch (this->choice_arm_)
  {
    case a_tag:
    {
      this->choice_.a_ = x.choice_.a_;
      break;
    }
    case sequence_tag:
    {
      new (&this->choice_.sequence_) sequence_type (reinterpret_cast< const sequence_type& > (x.choice_.sequence_));
      break;
    }
    default:
    break;
  }
}

nested_choice::choice_type& nested_choice::choice_type::
operator= (const choice_type& x)
{
  this->choice_arm (x.choice_arm_);
  switch (this->choice_arm_)
  {
    case a_tag:
    {
      this->choice_.a_ = x.choice_.a_;
      break;
    }
    case sequence_tag:
    {
      reinterpret_cast< sequence_type& > (this->choice_.sequence_) = reinterpret_cast< const sequence_type& > (x.choice_.sequence_);
      break;
    }
    default:
    break;
  }

  return *this;
}

void nested_choice::choice_type::
choice_arm (choice_arm_tag x)
{
  if (this->choice_arm_ == x)
    return;

  switch (this->choice_arm_)
  {
    case sequence_tag:
    {
      reinterpret_cast< sequence_type& > (this->choice_.sequence_).~sequence_type ();
      break;
    }
    default:
    break;
  }

  this->choice_arm_ = choice_arm_tag (2);

  switch (x)
  {
    case sequence_tag:
    {
      new (&this->choice_.sequence_) sequence_type;
      break;
    }
    default:
    break;
  }

  this->choice_arm_ = x;
}

nested_choice::choice_type::sequence_type::
sequence_type ()
{
}

nested_choice::choice_type::sequence_type::
~sequence_type ()
{
}

nested_choice::choice_type::sequence_type::
sequence_type (const sequence_type& x)
{
  XSDE_UNUSED (x);
  this->b_ = x.b_;
  this->c_ = x.c_;
}

nested_choice::choice_type::sequence_type& nested_choice::choice_type::sequence_type::
operator= (const sequence_type& x)
{
  XSDE_UNUSED (x);
  this->b_ = x.b_;
  this->c_ = x.c_;
  return *this;
}

// nested_sequence
//

nested_sequence::
nested_sequence ()
{
}

nested_sequence::
~nested_sequence ()
{
}

nested_sequence::sequence_type::
sequence_type ()
{
  this->sequence1_present_ = false;
}

nested_sequence::sequence_type::
~sequence_type ()
{
}

nested_sequence::sequence_type::
sequence_type (const sequence_type& x)
{
  XSDE_UNUSED (x);
  this->a_ = x.a_;
  this->sequence1_present_ = x.sequence1_present_;
  if (this->sequence1_present_)
    this->sequence1_ = x.sequence1_;
}

nested_sequence::sequence_type& nested_sequence::sequence_type::
operator= (const sequence_type& x)
{
  XSDE_UNUSED (x);
  this->a_ = x.a_;
  this->sequence1_present_ = x.sequence1_present_;
  if (this->sequence1_present_)
    this->sequence1_ = x.sequence1_;
  return *this;
}

nested_sequence::sequence_type::sequence1_type::
sequence1_type ()
{
}

nested_sequence::sequence_type::sequence1_type::
~sequence1_type ()
{
}

nested_sequence::sequence_type::sequence1_type::
sequence1_type (const sequence1_type& x)
{
  XSDE_UNUSED (x);
  this->b_ = x.b_;
  this->c_ = x.c_;
}

nested_sequence::sequence_type::sequence1_type& nested_sequence::sequence_type::sequence1_type::
operator= (const sequence1_type& x)
{
  XSDE_UNUSED (x);
  this->b_ = x.b_;
  this->c_ = x.c_;
  return *this;
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

