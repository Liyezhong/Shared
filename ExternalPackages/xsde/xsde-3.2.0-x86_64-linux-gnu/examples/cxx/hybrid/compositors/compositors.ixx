// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef COMPOSITORS_IXX
#define COMPOSITORS_IXX

// Begin prologue.
//
//
// End prologue.

// simple_choice
//

inline
simple_choice::choice_arm_tag simple_choice::
choice_arm () const
{
  return this->choice_arm_;
}

inline
int simple_choice::
a () const
{
  return reinterpret_cast< const int& > (this->choice_.a_);
}

inline
int& simple_choice::
a ()
{
  return reinterpret_cast< int& > (this->choice_.a_);
}

inline
void simple_choice::
a (int x)
{
  if (this->choice_arm_ != a_tag)
    this->choice_arm (a_tag);

  reinterpret_cast< int& > (this->choice_.a_) = x;
}

inline
bool simple_choice::
b_present () const
{
  return this->choice_.b_.data_[sizeof (int)];
}

inline
void simple_choice::
b_present (bool x)
{
  if (this->choice_arm_ != b_tag)
    this->choice_arm (b_tag);

  this->choice_.b_.data_[sizeof (int)] = x;
}

inline
int simple_choice::
b () const
{
  return reinterpret_cast< const int& > (this->choice_.b_);
}

inline
int& simple_choice::
b ()
{
  return reinterpret_cast< int& > (this->choice_.b_);
}

inline
void simple_choice::
b (int x)
{
  if (this->choice_arm_ != b_tag)
    this->choice_arm (b_tag);

  reinterpret_cast< int& > (this->choice_.b_) = x;
  this->choice_.b_.data_[sizeof (int)] = true;
}

inline
const simple_choice::c_sequence& simple_choice::
c () const
{
  return reinterpret_cast< const c_sequence& > (this->choice_.c_);
}

inline
simple_choice::c_sequence& simple_choice::
c ()
{
  return reinterpret_cast< c_sequence& > (this->choice_.c_);
}

// nested_choice
//

inline
bool nested_choice::
choice_present () const
{
  return this->choice_present_;
}

inline
void nested_choice::
choice_present (bool x)
{
  this->choice_present_ = x;
}

inline
const nested_choice::choice_type& nested_choice::
choice () const
{
  return this->choice_;
}

inline
nested_choice::choice_type& nested_choice::
choice ()
{
  return this->choice_;
}

inline
void nested_choice::
choice (const choice_type& x)
{
  this->choice_ = x;
  this->choice_present_ = true;
}

inline
int nested_choice::
d () const
{
  return this->d_;
}

inline
int& nested_choice::
d ()
{
  return this->d_;
}

inline
void nested_choice::
d (int x)
{
  this->d_ = x;
}

inline
nested_choice::choice_type::choice_arm_tag nested_choice::choice_type::
choice_arm () const
{
  return this->choice_arm_;
}

inline
int nested_choice::choice_type::
a () const
{
  return reinterpret_cast< const int& > (this->choice_.a_);
}

inline
int& nested_choice::choice_type::
a ()
{
  return reinterpret_cast< int& > (this->choice_.a_);
}

inline
void nested_choice::choice_type::
a (int x)
{
  if (this->choice_arm_ != a_tag)
    this->choice_arm (a_tag);

  reinterpret_cast< int& > (this->choice_.a_) = x;
}

inline
const nested_choice::choice_type::sequence_type& nested_choice::choice_type::
sequence () const
{
  return reinterpret_cast< const sequence_type& > (this->choice_.sequence_);
}

inline
nested_choice::choice_type::sequence_type& nested_choice::choice_type::
sequence ()
{
  return reinterpret_cast< sequence_type& > (this->choice_.sequence_);
}

inline
void nested_choice::choice_type::
sequence (const sequence_type& x)
{
  if (this->choice_arm_ != sequence_tag)
    this->choice_arm (sequence_tag);

  reinterpret_cast< sequence_type& > (this->choice_.sequence_) = x;
}

inline
int nested_choice::choice_type::sequence_type::
b () const
{
  return this->b_;
}

inline
int& nested_choice::choice_type::sequence_type::
b ()
{
  return this->b_;
}

inline
void nested_choice::choice_type::sequence_type::
b (int x)
{
  this->b_ = x;
}

inline
bool nested_choice::choice_type::sequence_type::
c () const
{
  return this->c_;
}

inline
bool& nested_choice::choice_type::sequence_type::
c ()
{
  return this->c_;
}

inline
void nested_choice::choice_type::sequence_type::
c (bool x)
{
  this->c_ = x;
}

// nested_sequence
//

inline
const nested_sequence::sequence_sequence& nested_sequence::
sequence () const
{
  return this->sequence_;
}

inline
nested_sequence::sequence_sequence& nested_sequence::
sequence ()
{
  return this->sequence_;
}

inline
int nested_sequence::sequence_type::
a () const
{
  return this->a_;
}

inline
int& nested_sequence::sequence_type::
a ()
{
  return this->a_;
}

inline
void nested_sequence::sequence_type::
a (int x)
{
  this->a_ = x;
}

inline
bool nested_sequence::sequence_type::
sequence1_present () const
{
  return this->sequence1_present_;
}

inline
void nested_sequence::sequence_type::
sequence1_present (bool x)
{
  this->sequence1_present_ = x;
}

inline
const nested_sequence::sequence_type::sequence1_type& nested_sequence::sequence_type::
sequence1 () const
{
  return this->sequence1_;
}

inline
nested_sequence::sequence_type::sequence1_type& nested_sequence::sequence_type::
sequence1 ()
{
  return this->sequence1_;
}

inline
void nested_sequence::sequence_type::
sequence1 (const sequence1_type& x)
{
  this->sequence1_ = x;
  this->sequence1_present_ = true;
}

inline
int nested_sequence::sequence_type::sequence1_type::
b () const
{
  return this->b_;
}

inline
int& nested_sequence::sequence_type::sequence1_type::
b ()
{
  return this->b_;
}

inline
void nested_sequence::sequence_type::sequence1_type::
b (int x)
{
  this->b_ = x;
}

inline
bool nested_sequence::sequence_type::sequence1_type::
c () const
{
  return this->c_;
}

inline
bool& nested_sequence::sequence_type::sequence1_type::
c ()
{
  return this->c_;
}

inline
void nested_sequence::sequence_type::sequence1_type::
c (bool x)
{
  this->c_ = x;
}

// Begin epilogue.
//
//
// End epilogue.

#endif // COMPOSITORS_IXX
