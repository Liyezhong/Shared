// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef COMPOSITORS_HXX
#define COMPOSITORS_HXX

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include <string>
#include <xsde/cxx/hybrid/xml-schema.hxx>
#include <xsde/cxx/hybrid/sequence.hxx>

namespace xml_schema
{
  using ::xsde::cxx::hybrid::any_type;
  typedef ::std::string any_simple_type;

  typedef signed char byte;
  using ::xsde::cxx::hybrid::byte_base;

  typedef unsigned char unsigned_byte;
  using ::xsde::cxx::hybrid::unsigned_byte_base;

  typedef short short_;
  using ::xsde::cxx::hybrid::short_base;

  typedef unsigned short unsigned_short;
  using ::xsde::cxx::hybrid::unsigned_short_base;

  typedef int int_;
  using ::xsde::cxx::hybrid::int_base;

  typedef unsigned int unsigned_int;
  using ::xsde::cxx::hybrid::unsigned_int_base;

  typedef long long long_;
  using ::xsde::cxx::hybrid::long_base;

  typedef unsigned long long unsigned_long;
  using ::xsde::cxx::hybrid::unsigned_long_base;

  typedef long integer;
  using ::xsde::cxx::hybrid::integer_base;

  typedef long non_positive_integer;
  using ::xsde::cxx::hybrid::non_positive_integer_base;

  typedef unsigned long non_negative_integer;
  using ::xsde::cxx::hybrid::non_negative_integer_base;

  typedef unsigned long positive_integer;
  using ::xsde::cxx::hybrid::positive_integer_base;

  typedef long negative_integer;
  using ::xsde::cxx::hybrid::negative_integer_base;

  typedef bool boolean;
  using ::xsde::cxx::hybrid::boolean_base;

  typedef float float_;
  using ::xsde::cxx::hybrid::float_base;

  typedef double double_;
  using ::xsde::cxx::hybrid::double_base;

  typedef double decimal;
  using ::xsde::cxx::hybrid::decimal_base;

  typedef ::std::string string;

  typedef ::std::string normalized_string;

  typedef ::std::string token;

  typedef ::std::string name;

  typedef ::std::string nmtoken;

  typedef ::xsde::cxx::string_sequence nmtokens;

  typedef ::std::string ncname;

  typedef ::std::string language;

  typedef ::std::string id;

  typedef ::std::string idref;

  typedef ::xsde::cxx::string_sequence idrefs;

  typedef ::std::string uri;

  using ::xsde::cxx::qname;

  using ::xsde::cxx::buffer;
  typedef ::xsde::cxx::buffer base64_binary;
  typedef ::xsde::cxx::buffer hex_binary;

  using ::xsde::cxx::time_zone;
  using ::xsde::cxx::date;
  using ::xsde::cxx::date_time;
  using ::xsde::cxx::duration;
  using ::xsde::cxx::gday;
  using ::xsde::cxx::gmonth;
  using ::xsde::cxx::gmonth_day;
  using ::xsde::cxx::gyear;
  using ::xsde::cxx::gyear_month;
  using ::xsde::cxx::time;

  using ::xsde::cxx::hybrid::pod_sequence;
  using ::xsde::cxx::hybrid::fix_sequence;
  using ::xsde::cxx::hybrid::var_sequence;
  using ::xsde::cxx::string_sequence;
  using ::xsde::cxx::hybrid::data_sequence;
}

class simple_choice;
class nested_choice;
class nested_sequence;

#ifndef XSDE_DONT_INCLUDE_INLINE
#define XSDE_DONT_INCLUDE_INLINE

#undef XSDE_DONT_INCLUDE_INLINE
#else

#endif // XSDE_DONT_INCLUDE_INLINE

// simple_choice (variable-length)
//
class simple_choice
{
  private:
  simple_choice (const simple_choice&);
  simple_choice& operator= (const simple_choice&);

  public:
  simple_choice ();

  ~simple_choice ();

  // choice
  //
  enum choice_arm_tag
  {
    a_tag,
    b_tag,
    c_tag
  };

  choice_arm_tag
  choice_arm () const;

  void
  choice_arm (choice_arm_tag);

  // a
  //
  int
  a () const;

  int&
  a ();

  void
  a (int);

  // b
  //
  bool
  b_present () const;

  void
  b_present (bool);

  int
  b () const;

  int&
  b ();

  void
  b (int);

  // c
  //
  typedef ::xsde::cxx::hybrid::pod_sequence< int > c_sequence;
  typedef c_sequence::iterator c_iterator;
  typedef c_sequence::const_iterator c_const_iterator;

  const c_sequence&
  c () const;

  c_sequence&
  c ();

  private:
  union
  {
    union
    {
      int align_;
      char data_[sizeof (int)];
    } a_;
    union
    {
      int align_;
      char data_[sizeof (int) + 1];
    } b_;
    union
    {
      size_t align_;
      char data_[sizeof (c_sequence)];
    } c_;
  } choice_;
  choice_arm_tag choice_arm_;
};

// nested_choice (fixed-length)
//
class nested_choice
{
  public:
  nested_choice ();

  nested_choice (const nested_choice&);
  nested_choice& operator= (const nested_choice&);

  ~nested_choice ();

  // choice (fixed-length)
  //
  class choice_type
  {
    public:
    choice_type ();

    ~choice_type ();

    choice_type (const choice_type&);
    choice_type& operator= (const choice_type&);

    enum choice_arm_tag
    {
      a_tag,
      sequence_tag
    };

    choice_arm_tag
    choice_arm () const;

    void
    choice_arm (choice_arm_tag);

    // a
    //
    int
    a () const;

    int&
    a ();

    void
    a (int);

    // sequence (fixed-length)
    //
    class sequence_type
    {
      public:
      sequence_type ();

      ~sequence_type ();

      sequence_type (const sequence_type&);
      sequence_type& operator= (const sequence_type&);

      // b
      //
      int
      b () const;

      int&
      b ();

      void
      b (int);

      // c
      //
      bool
      c () const;

      bool&
      c ();

      void
      c (bool);

      private:
      int b_;
      bool c_;
    };

    const sequence_type&
    sequence () const;

    sequence_type&
    sequence ();

    void
    sequence (const sequence_type&);

    private:
    union
    {
      union
      {
        int align_;
        char data_[sizeof (int)];
      } a_;
      union
      {
        int align_;
        char data_[sizeof (sequence_type)];
      } sequence_;
    } choice_;
    choice_arm_tag choice_arm_;
  };

  bool
  choice_present () const;

  void
  choice_present (bool);

  const choice_type&
  choice () const;

  choice_type&
  choice ();

  void
  choice (const choice_type&);

  // d
  //
  int
  d () const;

  int&
  d ();

  void
  d (int);

  private:
  choice_type choice_;
  unsigned char choice_present_;
  int d_;
};

// nested_sequence (variable-length)
//
class nested_sequence
{
  private:
  nested_sequence (const nested_sequence&);
  nested_sequence& operator= (const nested_sequence&);

  public:
  nested_sequence ();

  ~nested_sequence ();

  // sequence (fixed-length)
  //
  class sequence_type
  {
    public:
    sequence_type ();

    ~sequence_type ();

    sequence_type (const sequence_type&);
    sequence_type& operator= (const sequence_type&);

    // a
    //
    int
    a () const;

    int&
    a ();

    void
    a (int);

    // sequence1 (fixed-length)
    //
    class sequence1_type
    {
      public:
      sequence1_type ();

      ~sequence1_type ();

      sequence1_type (const sequence1_type&);
      sequence1_type& operator= (const sequence1_type&);

      // b
      //
      int
      b () const;

      int&
      b ();

      void
      b (int);

      // c
      //
      bool
      c () const;

      bool&
      c ();

      void
      c (bool);

      private:
      int b_;
      bool c_;
    };

    bool
    sequence1_present () const;

    void
    sequence1_present (bool);

    const sequence1_type&
    sequence1 () const;

    sequence1_type&
    sequence1 ();

    void
    sequence1 (const sequence1_type&);

    private:
    int a_;
    sequence1_type sequence1_;
    unsigned char sequence1_present_;
  };

  typedef ::xsde::cxx::hybrid::fix_sequence< sequence_type > sequence_sequence;
  typedef sequence_sequence::iterator sequence_iterator;
  typedef sequence_sequence::const_iterator sequence_const_iterator;

  const sequence_sequence&
  sequence () const;

  sequence_sequence&
  sequence ();

  private:
  sequence_sequence sequence_;
};

#ifndef XSDE_DONT_INCLUDE_INLINE

#endif // XSDE_DONT_INCLUDE_INLINE

#ifndef XSDE_DONT_INCLUDE_INLINE
#include "compositors.ixx"
#endif // XSDE_DONT_INCLUDE_INLINE

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // COMPOSITORS_HXX
