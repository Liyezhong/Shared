/****************************************************************************/
/*! \file fmTemperatureFan.c
 * 
 *  \brief Functions determining the speed of a ventilation fan.
 *
 *   $Version: $ 0.1
 *   $Date:    $ 02.07.2010
 *   $Author:  $ Martin Scherer
 *
 *  \b Description:
 *
 *  This file's only task the determination of speed of a ventilation fan.
 *  The unit is rotations per minute.
 *
 *  \b Company:
 *
 *       Leica Biosystems Nussloch GmbH.
 * 
 *  (C) Copyright 2010 by Leica Biosystems Nussloch GmbH. All rights reserved.
 *  This is unpublished proprietary source code of Leica. The copyright notice 
 *  does not evidence any actual or intended publication.
 */
/****************************************************************************/

#include <stdlib.h>
#include "Global.h"
#include "bmError.h"
#include "fmTemperatureFan.h"
#include "halLayer.h"

//****************************************************************************/
// Private Constants and Macros 
//****************************************************************************/

static const Device_t TEMP_FAN_HAL_TIMER = HAL_TEMP_FANSPEED; //!< The timer unit for the first instance

//****************************************************************************/
// Private Type Definitions 
//****************************************************************************/

/*! Contains all variables needed for fan speed measurments */
typedef struct {
    Handle_t Handle;            //!< Handle to access a hardware timer (HAL)
    Handle_t *HandleControl;    //!< Handle to access digital output ports (HAL)
    UInt8 CaptureNumber;        //!< Number of active capture channels
    UInt32 *CountOld;           //!< Last counter value from the capture register
    UInt32 *CountDiff;          //!< The difference between two capture events
    Bool *TopSpeed;             //!< Indicates if the fan is at top speed or not
    UInt32 TimeMask;            //!< The size of the timer register
} TemperatureFan_t;

//****************************************************************************/
// Private Variables 
//****************************************************************************/

static TemperatureFan_t *TempFanTable = NULL; //!< data table for all instances
static UInt16 TempFanInstances = 0; //!< number of module instances

//****************************************************************************/
// Private Function Prototypes 
//****************************************************************************/

static void tempFanInterrupt (UInt32 Channel, UInt32 IntrFlags);


/*****************************************************************************/
/*! 
 *  \brief   Initializes the data structures for all instances 
 *
 *      This method allocates the data table that holds all information
 *      required for the computation of the speed of the ventilation fans. It
 *      initializes the table for all instances. It must not be called more
 *      than once. 
 * 
 *  \iparam  Instances = Number of instances 
 *
 *  \return  NO_ERROR or (negative) error code
 *
 ****************************************************************************/
 
Error_t tempFanInit (UInt16 Instances)
{
    if (NULL == TempFanTable) {
        TempFanTable = calloc (Instances, sizeof(TemperatureFan_t));
        if (NULL == TempFanTable) {
            return (E_MEMORY_FULL);
        }
        TempFanInstances = Instances;
        return (NO_ERROR);
    }
    return (E_PARAMETER_OUT_OF_RANGE);
}


/*****************************************************************************/
/*! 
 *  \brief   Opens the timer capture channels
 *
 *      The function initializes a capture unit that is part of the hardware
 *      abstraction layer. The capture unit measures the time between two
 *      strobes generated by the sensor of the ventilation fans.
 * 
 *  \iparam  Instance = Instance number 
 *  \oparam  Fans = Total number of fans for this instance
 *
 *  \return  NO_ERROR or (negative) error code
 *
 ****************************************************************************/

Error_t tempFanOpen (UInt16 Instance, UInt8 Fans)
{
    UInt8 i;
    Error_t Error;
    TimerMode_t TimerMode;
    TemperatureFan_t *TempFan = &TempFanTable[Instance];
    
    TimerMode.Direction = TIM_MODE_COUNT_UP;
    TimerMode.OneShot = TIM_MODE_INTERVAL;
    TimerMode.ClkSource = TIM_MODE_INTERNAL;
    TimerMode.ClkMode = 0;

    if (Fans == 0) {
        return (NO_ERROR);
    }

    if (Instance >= TempFanInstances) {
        return E_PARAMETER_OUT_OF_RANGE;
    }
    
    // Allocate fan control handles
    TempFan->HandleControl = calloc (Fans, sizeof(Handle_t));
    if (NULL == TempFanTable) {
        return (E_MEMORY_FULL);
    }
    // Open fan control switches
    for (i = 0; i < Fans; i++) {
        TempFan->HandleControl[i] = halPortOpen (HAL_TEMP_FANCONTROL + i, HAL_OPEN_WRITE);
        if (TempFan->HandleControl[i] < 0) {
            return (TempFan->HandleControl[i]);
        }
    }

    // Open fan speed capture units
    TempFan->Handle = halTimerOpen (TEMP_FAN_HAL_TIMER + Instance, Instance, tempFanInterrupt);
    if (TempFan->Handle < 0) {
        return (TempFan->Handle);
    }
    Error = halTimerStatus (TempFan->Handle, TIM_STAT_CLOCKRATE);
    if (Error < NO_ERROR) {
        return (Error);
    }
    Error = halTimerSetup (TempFan->Handle, &TimerMode, Error / 100000);
    if (Error < NO_ERROR) {
        return (Error);
    }
    // Request the size of the capture registers
    Error = halTimerStatus (TempFan->Handle, TIM_STAT_MAXCOUNT);
    if (Error < NO_ERROR) {
        return (Error);
    }
    TempFan->TimeMask = Error;

    Error = halTimerStatus (TempFan->Handle, TIM_STAT_UNITS);
    if (Error < 0) {
        return (Error);
    }
    else if (Error < Fans) {
        return (E_PARAMETER_OUT_OF_RANGE);
    }
    
    Error = halTimerControl (TempFan->Handle, TIM_CTRL_START);
    if (Error < 0) {
        return (Error);
    }
    
    // Allocation of measurement variables
    TempFan->CaptureNumber = Fans;
    TempFanTable->CountOld = calloc (TempFan->CaptureNumber, sizeof(UInt32));
    if (NULL == TempFanTable->CountOld) {
        return (E_MEMORY_FULL);
    }
    TempFanTable->CountDiff = calloc (TempFan->CaptureNumber, sizeof(UInt32));
    if (NULL == TempFanTable->CountDiff) {
        return (E_MEMORY_FULL);
    }
    TempFanTable->TopSpeed = calloc (TempFan->CaptureNumber, sizeof(Bool));
    if (NULL == TempFanTable->TopSpeed) {
        return (E_MEMORY_FULL);
    }
    
    return (NO_ERROR);
}


/*****************************************************************************/
/*! 
 *  \brief   Activates or deactivates the fans
 *
 *      This method starts and stopps all ventialtion fans assigned to an
 *      instance of this function module.
 * 
 *  \iparam  Instance = Instance number 
 *  \iparam  Activate = Switch on (true) or off (false)
 *
 *  \return  NO_ERROR or (negative) error code
 *
 ****************************************************************************/
 
Error_t tempFanControl (UInt16 Instance, Bool Activate)
{
    UInt8 i;
    Error_t Status;

    if (Instance >= TempFanInstances) {
        return E_PARAMETER_OUT_OF_RANGE;
    }

    for (i = 0; i < TempFanTable[Instance].CaptureNumber; i++) {
        TempFanTable[Instance].CountOld[i] = 0;
        TempFanTable[Instance].CountDiff[i] = 0;
        TempFanTable[Instance].TopSpeed[i] = FALSE;
        
        Status = halPortWrite (TempFanTable[Instance].HandleControl[i], Activate);
        if (Status < NO_ERROR) {
            return (Status);
        }
        
        if (Activate == TRUE) {
            Status = halCapComControl (TempFanTable[Instance].Handle, i, TIM_INTR_ENABLE);
        }
        else {
            Status = halCapComControl (TempFanTable[Instance].Handle, i, TIM_INTR_DISABLE);
        }
        if (Status < NO_ERROR) {
            return (Status);
        }
    }
    
    return (Status);
}


/*****************************************************************************/
/*! 
 *  \brief   Measures the speed of a ventilation fan
 *
 *      This function converts the information fetched from a single capture
 *      channel into rotations per minute and returns the value.
 * 
 *  \iparam  Instance = Instance number 
 *  \iparam  Fan = Number of the ventilation fan
 *  \oparam  Speed = Fan speed in rotations per minute
 *
 *  \return  NO_ERROR or (negative) error code
 *
 ****************************************************************************/

Error_t tempFanSpeed (UInt16 Instance, UInt8 Fan, UInt16 *Speed)
{
    UInt32 Count;
    Error_t Status = TempFanTable[Instance].TopSpeed[Fan];

    if (Instance >= TempFanInstances) {
        return E_PARAMETER_OUT_OF_RANGE;
    }
    if (Fan >= TempFanTable[Instance].CaptureNumber) {
        return E_PARAMETER_OUT_OF_RANGE;
    }

    Count = TempFanTable[Instance].CountDiff[Fan];
    
    if (Count != 0) {
        *Speed = 3000000 / Count;
    }
    else {
        *Speed = 0;
    }
    
    TempFanTable[Instance].TopSpeed[Fan] = TRUE;
    return (Status);
}


/*****************************************************************************/
/*! 
 *  \brief   Interrupt handler reading capture channels
 *
 *      This interrupt handler reads all capture registers of the timer unit
 *      and computes the counter difference since the last event. These values
 *      are stored in the corresponding data struture of the function module
 *      instance.
 * 
 *  \iparam  Channel = user infomation
 *  \iparam  IntrFlags = interrupt flags
 *
 ****************************************************************************/

static void tempFanInterrupt (UInt32 Channel, UInt32 IntrFlags)
{
    UInt8 i;
    UInt32 CountNew;
    Error_t Error;
    TemperatureFan_t *TempFan = &TempFanTable[Channel];
    
    // Looking for capture events
    for (i = 0; i < TempFan->CaptureNumber; i++) {
        // Get the captured counter value
        Error = halCapComRead (TempFan->Handle, i, &CountNew);
        if (Error < 0) {
            return;
        }
        else if (Error == 1) {
            TempFan->CountDiff[i] = TempFan->TimeMask & (CountNew - TempFan->CountOld[i]);
            TempFan->CountOld[i] = CountNew;
        }
    }
    
    return;
}

//****************************************************************************/
