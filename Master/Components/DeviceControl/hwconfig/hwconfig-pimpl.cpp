// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include "hwconfig-pimpl.hpp"

#include <xsde/cxx/parser/validating/string-common.hxx>

// can_interfaceType_pimpl
//

can_interfaceType_pimpl::
can_interfaceType_pimpl ()
: can_interfaceType_pskel (&base_impl_)
{
}

void can_interfaceType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->can_interfaceType_pimpl_state_.can_interfaceType_ = ::can_interfaceType ();
}

void can_interfaceType_pimpl::
interface (const ::std::string& x)
{
  this->can_interfaceType_pimpl_state_.can_interfaceType_.interface (x);
}

::can_interfaceType can_interfaceType_pimpl::
post_can_interfaceType ()
{
  static_cast< ::std::string& > (this->can_interfaceType_pimpl_state_.can_interfaceType_) =
  this->base_impl_.post_string ();
  return this->can_interfaceType_pimpl_state_.can_interfaceType_;
}

// tcp_interfaceType_pimpl
//

tcp_interfaceType_pimpl::
tcp_interfaceType_pimpl ()
: tcp_interfaceType_pskel (&base_impl_)
{
}

void tcp_interfaceType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->tcp_interfaceType_pimpl_state_.tcp_interfaceType_ = ::tcp_interfaceType ();
}

void tcp_interfaceType_pimpl::
usage (signed char x)
{
  this->tcp_interfaceType_pimpl_state_.tcp_interfaceType_.usage (x);
}

::tcp_interfaceType tcp_interfaceType_pimpl::
post_tcp_interfaceType ()
{
  static_cast< ::std::string& > (this->tcp_interfaceType_pimpl_state_.tcp_interfaceType_) =
  this->base_impl_.post_string ();
  return this->tcp_interfaceType_pimpl_state_.tcp_interfaceType_;
}

// serial_numberType_pimpl
//

serial_numberType_pimpl::
serial_numberType_pimpl ()
: serial_numberType_pskel (&base_impl_)
{
}

void serial_numberType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->serial_numberType_pimpl_state_.serial_numberType_ = ::serial_numberType ();
}

void serial_numberType_pimpl::
serialno (const ::std::string& x)
{
  this->serial_numberType_pimpl_state_.serial_numberType_.serialno (x);
}

::serial_numberType serial_numberType_pimpl::
post_serial_numberType ()
{
  static_cast< ::std::string& > (this->serial_numberType_pimpl_state_.serial_numberType_) =
  this->base_impl_.post_string ();
  return this->serial_numberType_pimpl_state_.serial_numberType_;
}

// deviceType_pimpl
//

deviceType_pimpl::
deviceType_pimpl (bool b)
{
  this->deviceType_pimpl_base_ = b;
  this->deviceType_pimpl_state_.deviceType_ = 0;
}

deviceType_pimpl::
~deviceType_pimpl ()
{
  if (!this->deviceType_pimpl_base_ && this->deviceType_pimpl_state_.deviceType_)
    delete this->deviceType_pimpl_state_.deviceType_;
}

void deviceType_pimpl::
_reset ()
{
  deviceType_pskel::_reset ();

  if (!this->deviceType_pimpl_base_ && this->deviceType_pimpl_state_.deviceType_)
  {
    delete this->deviceType_pimpl_state_.deviceType_;
    this->deviceType_pimpl_state_.deviceType_ = 0;
  }
}

void deviceType_pimpl::
pre_impl (::deviceType* x)
{
  this->deviceType_pimpl_state_.deviceType_ = x;
}

void deviceType_pimpl::
pre ()
{
  ::deviceType* x = new ::deviceType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void deviceType_pimpl::
name (const ::std::string& x)
{
  this->deviceType_pimpl_state_.deviceType_->name (x);
}

void deviceType_pimpl::
id (const ::std::string& x)
{
  this->deviceType_pimpl_state_.deviceType_->id (x);
}

void deviceType_pimpl::
type (const ::std::string& x)
{
  this->deviceType_pimpl_state_.deviceType_->type (x);
}

void deviceType_pimpl::
dev_instanceID (const ::std::string& x)
{
  this->deviceType_pimpl_state_.deviceType_->dev_instanceID (x);
}

void deviceType_pimpl::
optional (signed char x)
{
  this->deviceType_pimpl_state_.deviceType_->optional (x);
}

void deviceType_pimpl::
functionmodules (::functionmodulesType* x)
{
  this->deviceType_pimpl_state_.deviceType_->functionmodules (x);
}

::deviceType* deviceType_pimpl::
post_deviceType ()
{
  ::deviceType* r = this->deviceType_pimpl_state_.deviceType_;
  this->deviceType_pimpl_state_.deviceType_ = 0;
  return r;
}

// devicesType_pimpl
//

devicesType_pimpl::
devicesType_pimpl (bool b)
{
  this->devicesType_pimpl_base_ = b;
  this->devicesType_pimpl_state_.devicesType_ = 0;
}

devicesType_pimpl::
~devicesType_pimpl ()
{
  if (!this->devicesType_pimpl_base_ && this->devicesType_pimpl_state_.devicesType_)
    delete this->devicesType_pimpl_state_.devicesType_;
}

void devicesType_pimpl::
_reset ()
{
  devicesType_pskel::_reset ();

  if (!this->devicesType_pimpl_base_ && this->devicesType_pimpl_state_.devicesType_)
  {
    delete this->devicesType_pimpl_state_.devicesType_;
    this->devicesType_pimpl_state_.devicesType_ = 0;
  }
}

void devicesType_pimpl::
pre_impl (::devicesType* x)
{
  this->devicesType_pimpl_state_.devicesType_ = x;
}

void devicesType_pimpl::
pre ()
{
  ::devicesType* x = new ::devicesType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void devicesType_pimpl::
device (::deviceType* x)
{
  if (this->devicesType_pimpl_state_.devicesType_->device ().push_back (x))
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

::devicesType* devicesType_pimpl::
post_devicesType ()
{
  ::devicesType* r = this->devicesType_pimpl_state_.devicesType_;
  this->devicesType_pimpl_state_.devicesType_ = 0;
  return r;
}

// retortType_pimpl
//

retortType_pimpl::
retortType_pimpl (bool b)
{
  this->retortType_pimpl_base_ = b;
  this->retortType_pimpl_state_.retortType_ = 0;
}

retortType_pimpl::
~retortType_pimpl ()
{
  if (!this->retortType_pimpl_base_ && this->retortType_pimpl_state_.retortType_)
    delete this->retortType_pimpl_state_.retortType_;
}

void retortType_pimpl::
_reset ()
{
  retortType_pskel::_reset ();

  if (!this->retortType_pimpl_base_ && this->retortType_pimpl_state_.retortType_)
  {
    delete this->retortType_pimpl_state_.retortType_;
    this->retortType_pimpl_state_.retortType_ = 0;
  }
}

void retortType_pimpl::
pre_impl (::retortType* x)
{
  this->retortType_pimpl_state_.retortType_ = x;
}

void retortType_pimpl::
pre ()
{
  ::retortType* x = new ::retortType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void retortType_pimpl::
name (const ::std::string& x)
{
  this->retortType_pimpl_state_.retortType_->name (x);
}

void retortType_pimpl::
index (signed char x)
{
  this->retortType_pimpl_state_.retortType_->index (x);
}

void retortType_pimpl::
devices (::devicesType* x)
{
  this->retortType_pimpl_state_.retortType_->devices (x);
}

::retortType* retortType_pimpl::
post_retortType ()
{
  ::retortType* r = this->retortType_pimpl_state_.retortType_;
  this->retortType_pimpl_state_.retortType_ = 0;
  return r;
}

// retortsType_pimpl
//

retortsType_pimpl::
retortsType_pimpl (bool b)
{
  this->retortsType_pimpl_base_ = b;
  this->retortsType_pimpl_state_.retortsType_ = 0;
}

retortsType_pimpl::
~retortsType_pimpl ()
{
  if (!this->retortsType_pimpl_base_ && this->retortsType_pimpl_state_.retortsType_)
    delete this->retortsType_pimpl_state_.retortsType_;
}

void retortsType_pimpl::
_reset ()
{
  retortsType_pskel::_reset ();

  if (!this->retortsType_pimpl_base_ && this->retortsType_pimpl_state_.retortsType_)
  {
    delete this->retortsType_pimpl_state_.retortsType_;
    this->retortsType_pimpl_state_.retortsType_ = 0;
  }
}

void retortsType_pimpl::
pre_impl (::retortsType* x)
{
  this->retortsType_pimpl_state_.retortsType_ = x;
}

void retortsType_pimpl::
pre ()
{
  ::retortsType* x = new ::retortsType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void retortsType_pimpl::
retort (::retortType* x)
{
  if (this->retortsType_pimpl_state_.retortsType_->retort ().push_back (x))
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

::retortsType* retortsType_pimpl::
post_retortsType ()
{
  ::retortsType* r = this->retortsType_pimpl_state_.retortsType_;
  this->retortsType_pimpl_state_.retortsType_ = 0;
  return r;
}

// parameter_masterType_pimpl
//

parameter_masterType_pimpl::
parameter_masterType_pimpl (bool b)
{
  this->parameter_masterType_pimpl_base_ = b;
  this->parameter_masterType_pimpl_state_.parameter_masterType_ = 0;
}

parameter_masterType_pimpl::
~parameter_masterType_pimpl ()
{
  if (!this->parameter_masterType_pimpl_base_ && this->parameter_masterType_pimpl_state_.parameter_masterType_)
    delete this->parameter_masterType_pimpl_state_.parameter_masterType_;
}

void parameter_masterType_pimpl::
_reset ()
{
  parameter_masterType_pskel::_reset ();

  if (!this->parameter_masterType_pimpl_base_ && this->parameter_masterType_pimpl_state_.parameter_masterType_)
  {
    delete this->parameter_masterType_pimpl_state_.parameter_masterType_;
    this->parameter_masterType_pimpl_state_.parameter_masterType_ = 0;
  }
}

void parameter_masterType_pimpl::
pre_impl (::parameter_masterType* x)
{
  this->parameter_masterType_pimpl_state_.parameter_masterType_ = x;
}

void parameter_masterType_pimpl::
pre ()
{
  ::parameter_masterType* x = new ::parameter_masterType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void parameter_masterType_pimpl::
folded (const ::std::string& x)
{
  this->parameter_masterType_pimpl_state_.parameter_masterType_->folded (x);
}

void parameter_masterType_pimpl::
can_interface (const ::can_interfaceType& x)
{
  this->parameter_masterType_pimpl_state_.parameter_masterType_->can_interface (x);
}

void parameter_masterType_pimpl::
tcp_interface (const ::tcp_interfaceType& x)
{
  this->parameter_masterType_pimpl_state_.parameter_masterType_->tcp_interface (x);
}

void parameter_masterType_pimpl::
nodetype (signed char x)
{
  this->parameter_masterType_pimpl_state_.parameter_masterType_->nodetype (x);
}

void parameter_masterType_pimpl::
nodeindex (signed char x)
{
  this->parameter_masterType_pimpl_state_.parameter_masterType_->nodeindex (x);
}

void parameter_masterType_pimpl::
serial_number (const ::serial_numberType& x)
{
  this->parameter_masterType_pimpl_state_.parameter_masterType_->serial_number (x);
}

void parameter_masterType_pimpl::
retorts (::retortsType* x)
{
  this->parameter_masterType_pimpl_state_.parameter_masterType_->retorts (x);
}

::parameter_masterType* parameter_masterType_pimpl::
post_parameter_masterType ()
{
  ::parameter_masterType* r = this->parameter_masterType_pimpl_state_.parameter_masterType_;
  this->parameter_masterType_pimpl_state_.parameter_masterType_ = 0;
  return r;
}

// rotationType_pimpl
//

rotationType_pimpl::
rotationType_pimpl ()
: rotationType_pskel (&base_impl_)
{
}

void rotationType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->rotationType_pimpl_state_.rotationType_ = ::rotationType ();
}

void rotationType_pimpl::
type (const ::std::string& x)
{
  this->rotationType_pimpl_state_.rotationType_.type (x);
}

void rotationType_pimpl::
direction (const ::std::string& x)
{
  this->rotationType_pimpl_state_.rotationType_.direction (x);
}

void rotationType_pimpl::
steps_revolution (short x)
{
  this->rotationType_pimpl_state_.rotationType_.steps_revolution (x);
}

void rotationType_pimpl::
position_min (short x)
{
  this->rotationType_pimpl_state_.rotationType_.position_min (x);
}

void rotationType_pimpl::
position_max (short x)
{
  this->rotationType_pimpl_state_.rotationType_.position_max (x);
}

void rotationType_pimpl::
speed_min (signed char x)
{
  this->rotationType_pimpl_state_.rotationType_.speed_min (x);
}

void rotationType_pimpl::
speed_max (short x)
{
  this->rotationType_pimpl_state_.rotationType_.speed_max (x);
}

void rotationType_pimpl::
run_cs (signed char x)
{
  this->rotationType_pimpl_state_.rotationType_.run_cs (x);
}

void rotationType_pimpl::
stop_cs (signed char x)
{
  this->rotationType_pimpl_state_.rotationType_.stop_cs (x);
}

void rotationType_pimpl::
stop_cs_delay (short x)
{
  this->rotationType_pimpl_state_.rotationType_.stop_cs_delay (x);
}

::rotationType rotationType_pimpl::
post_rotationType ()
{
  static_cast< ::std::string& > (this->rotationType_pimpl_state_.rotationType_) =
  this->base_impl_.post_string ();
  return this->rotationType_pimpl_state_.rotationType_;
}

// reference_runType_pimpl
//

reference_runType_pimpl::
reference_runType_pimpl ()
: reference_runType_pskel (&base_impl_)
{
}

void reference_runType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->reference_runType_pimpl_state_.reference_runType_ = ::reference_runType ();
}

void reference_runType_pimpl::
ref_position (signed char x)
{
  this->reference_runType_pimpl_state_.reference_runType_.ref_position (x);
}

void reference_runType_pimpl::
max_distance (short x)
{
  this->reference_runType_pimpl_state_.reference_runType_.max_distance (x);
}

void reference_runType_pimpl::
timeout (int x)
{
  this->reference_runType_pimpl_state_.reference_runType_.timeout (x);
}

void reference_runType_pimpl::
reverse_distance (signed char x)
{
  this->reference_runType_pimpl_state_.reference_runType_.reverse_distance (x);
}

void reference_runType_pimpl::
slow_speed (signed char x)
{
  this->reference_runType_pimpl_state_.reference_runType_.slow_speed (x);
}

void reference_runType_pimpl::
high_speed (short x)
{
  this->reference_runType_pimpl_state_.reference_runType_.high_speed (x);
}

void reference_runType_pimpl::
refpos_offset (signed char x)
{
  this->reference_runType_pimpl_state_.reference_runType_.refpos_offset (x);
}

::reference_runType reference_runType_pimpl::
post_reference_runType ()
{
  static_cast< ::std::string& > (this->reference_runType_pimpl_state_.reference_runType_) =
  this->base_impl_.post_string ();
  return this->reference_runType_pimpl_state_.reference_runType_;
}

// encoderType_pimpl
//

encoderType_pimpl::
encoderType_pimpl ()
: encoderType_pskel (&base_impl_)
{
}

void encoderType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->encoderType_pimpl_state_.encoderType_ = ::encoderType ();
}

void encoderType_pimpl::
type (signed char x)
{
  this->encoderType_pimpl_state_.encoderType_.type (x);
}

void encoderType_pimpl::
resolution (short x)
{
  this->encoderType_pimpl_state_.encoderType_.resolution (x);
}

void encoderType_pimpl::
rotation (const ::std::string& x)
{
  this->encoderType_pimpl_state_.encoderType_.rotation (x);
}

::encoderType encoderType_pimpl::
post_encoderType ()
{
  static_cast< ::std::string& > (this->encoderType_pimpl_state_.encoderType_) =
  this->base_impl_.post_string ();
  return this->encoderType_pimpl_state_.encoderType_;
}

// configurationType_pimpl
//

configurationType_pimpl::
configurationType_pimpl ()
: configurationType_pskel (&base_impl_)
{
}

void configurationType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->configurationType_pimpl_state_.configurationType_ = ::configurationType ();
}

void configurationType_pimpl::
polarity (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.polarity (x);
}

void configurationType_pimpl::
sample_rate (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.sample_rate (x);
}

void configurationType_pimpl::
debounce (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.debounce (x);
}

void configurationType_pimpl::
temp_tolerance (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.temp_tolerance (x);
}

void configurationType_pimpl::
sampling_period (short x)
{
  this->configurationType_pimpl_state_.configurationType_.sampling_period (x);
}

void configurationType_pimpl::
fan_speed (short x)
{
  this->configurationType_pimpl_state_.configurationType_.fan_speed (x);
}

void configurationType_pimpl::
fan_threshold (short x)
{
  this->configurationType_pimpl_state_.configurationType_.fan_threshold (x);
}

void configurationType_pimpl::
current_gain (short x)
{
  this->configurationType_pimpl_state_.configurationType_.current_gain (x);
}

void configurationType_pimpl::
heater_current (short x)
{
  this->configurationType_pimpl_state_.configurationType_.heater_current (x);
}

void configurationType_pimpl::
heater_threshold (short x)
{
  this->configurationType_pimpl_state_.configurationType_.heater_threshold (x);
}

void configurationType_pimpl::
current_deviation (short x)
{
  this->configurationType_pimpl_state_.configurationType_.current_deviation (x);
}

void configurationType_pimpl::
current_min_230_serial (short x)
{
  this->configurationType_pimpl_state_.configurationType_.current_min_230_serial (x);
}

void configurationType_pimpl::
current_max_230_serial (short x)
{
  this->configurationType_pimpl_state_.configurationType_.current_max_230_serial (x);
}

void configurationType_pimpl::
current_min_100_serial (short x)
{
  this->configurationType_pimpl_state_.configurationType_.current_min_100_serial (x);
}

void configurationType_pimpl::
current_max_100_serial (short x)
{
  this->configurationType_pimpl_state_.configurationType_.current_max_100_serial (x);
}

void configurationType_pimpl::
current_min_100_parallel (short x)
{
  this->configurationType_pimpl_state_.configurationType_.current_min_100_parallel (x);
}

void configurationType_pimpl::
current_max_100_parallel (short x)
{
  this->configurationType_pimpl_state_.configurationType_.current_max_100_parallel (x);
}

void configurationType_pimpl::
pressure_tolerance (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.pressure_tolerance (x);
}

void configurationType_pimpl::
fan_current_gain (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.fan_current_gain (x);
}

void configurationType_pimpl::
fan_current (short x)
{
  this->configurationType_pimpl_state_.configurationType_.fan_current (x);
}

void configurationType_pimpl::
pump_current (short x)
{
  this->configurationType_pimpl_state_.configurationType_.pump_current (x);
}

void configurationType_pimpl::
pump_threshold (short x)
{
  this->configurationType_pimpl_state_.configurationType_.pump_threshold (x);
}

void configurationType_pimpl::
enabled (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.enabled (x);
}

void configurationType_pimpl::
inactiv_shutdown (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.inactiv_shutdown (x);
}

void configurationType_pimpl::
inactiv_emcy (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.inactiv_emcy (x);
}

void configurationType_pimpl::
outval_inactiv (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.outval_inactiv (x);
}

void configurationType_pimpl::
livetime_limit (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.livetime_limit (x);
}

void configurationType_pimpl::
timestamp (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.timestamp (x);
}

void configurationType_pimpl::
threshold (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.threshold (x);
}

void configurationType_pimpl::
interval (signed char x)
{
  this->configurationType_pimpl_state_.configurationType_.interval (x);
}

::configurationType configurationType_pimpl::
post_configurationType ()
{
  static_cast< ::std::string& > (this->configurationType_pimpl_state_.configurationType_) =
  this->base_impl_.post_string ();
  return this->configurationType_pimpl_state_.configurationType_;
}

// limitswitchType_pimpl
//

void limitswitchType_pimpl::
pre ()
{
  this->limitswitchType_pimpl_state_.limitswitchType_ = ::limitswitchType ();
}

void limitswitchType_pimpl::
index (signed char x)
{
  this->limitswitchType_pimpl_state_.limitswitchType_.index (x);
}

void limitswitchType_pimpl::
configuration (const ::configurationType& x)
{
  this->limitswitchType_pimpl_state_.limitswitchType_.configuration (x);
}

::limitswitchType limitswitchType_pimpl::
post_limitswitchType ()
{
  return this->limitswitchType_pimpl_state_.limitswitchType_;
}

// position_codeType_pimpl
//

position_codeType_pimpl::
position_codeType_pimpl ()
: position_codeType_pskel (&base_impl_)
{
}

void position_codeType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->position_codeType_pimpl_state_.position_codeType_ = ::position_codeType ();
}

void position_codeType_pimpl::
value (signed char x)
{
  this->position_codeType_pimpl_state_.position_codeType_.value (x);
}

void position_codeType_pimpl::
stop (signed char x)
{
  this->position_codeType_pimpl_state_.position_codeType_.stop (x);
}

void position_codeType_pimpl::
stop_dir (const ::std::string& x)
{
  this->position_codeType_pimpl_state_.position_codeType_.stop_dir (x);
}

void position_codeType_pimpl::
position (signed char x)
{
  this->position_codeType_pimpl_state_.position_codeType_.position (x);
}

void position_codeType_pimpl::
width (signed char x)
{
  this->position_codeType_pimpl_state_.position_codeType_.width (x);
}

void position_codeType_pimpl::
deviation (signed char x)
{
  this->position_codeType_pimpl_state_.position_codeType_.deviation (x);
}

void position_codeType_pimpl::
dir_check (signed char x)
{
  this->position_codeType_pimpl_state_.position_codeType_.dir_check (x);
}

void position_codeType_pimpl::
hit_skip (signed char x)
{
  this->position_codeType_pimpl_state_.position_codeType_.hit_skip (x);
}

::position_codeType position_codeType_pimpl::
post_position_codeType ()
{
  static_cast< ::std::string& > (this->position_codeType_pimpl_state_.position_codeType_) =
  this->base_impl_.post_string ();
  return this->position_codeType_pimpl_state_.position_codeType_;
}

// limitswitchesType_pimpl
//

limitswitchesType_pimpl::
limitswitchesType_pimpl (bool b)
{
  this->limitswitchesType_pimpl_base_ = b;
  this->limitswitchesType_pimpl_state_.limitswitchesType_ = 0;
}

limitswitchesType_pimpl::
~limitswitchesType_pimpl ()
{
  if (!this->limitswitchesType_pimpl_base_ && this->limitswitchesType_pimpl_state_.limitswitchesType_)
    delete this->limitswitchesType_pimpl_state_.limitswitchesType_;
}

void limitswitchesType_pimpl::
_reset ()
{
  limitswitchesType_pskel::_reset ();

  if (!this->limitswitchesType_pimpl_base_ && this->limitswitchesType_pimpl_state_.limitswitchesType_)
  {
    delete this->limitswitchesType_pimpl_state_.limitswitchesType_;
    this->limitswitchesType_pimpl_state_.limitswitchesType_ = 0;
  }
}

void limitswitchesType_pimpl::
pre_impl (::limitswitchesType* x)
{
  this->limitswitchesType_pimpl_state_.limitswitchesType_ = x;
}

void limitswitchesType_pimpl::
pre ()
{
  ::limitswitchesType* x = new ::limitswitchesType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void limitswitchesType_pimpl::
limitswitch (const ::limitswitchType& x)
{
  if (this->limitswitchesType_pimpl_state_.limitswitchesType_->limitswitch ().push_back (x))
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void limitswitchesType_pimpl::
position_code (const ::position_codeType& x)
{
  if (this->limitswitchesType_pimpl_state_.limitswitchesType_->position_code ().push_back (x))
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

::limitswitchesType* limitswitchesType_pimpl::
post_limitswitchesType ()
{
  ::limitswitchesType* r = this->limitswitchesType_pimpl_state_.limitswitchesType_;
  this->limitswitchesType_pimpl_state_.limitswitchesType_ = 0;
  return r;
}

// position_coverageType_pimpl
//

position_coverageType_pimpl::
position_coverageType_pimpl (bool b)
{
  this->position_coverageType_pimpl_base_ = b;
  this->position_coverageType_pimpl_state_.position_coverageType_ = 0;
}

position_coverageType_pimpl::
~position_coverageType_pimpl ()
{
  if (!this->position_coverageType_pimpl_base_ && this->position_coverageType_pimpl_state_.position_coverageType_)
    delete this->position_coverageType_pimpl_state_.position_coverageType_;
}

void position_coverageType_pimpl::
_reset ()
{
  position_coverageType_pskel::_reset ();

  if (!this->position_coverageType_pimpl_base_ && this->position_coverageType_pimpl_state_.position_coverageType_)
  {
    delete this->position_coverageType_pimpl_state_.position_coverageType_;
    this->position_coverageType_pimpl_state_.position_coverageType_ = 0;
  }
}

void position_coverageType_pimpl::
pre_impl (::position_coverageType* x)
{
  this->position_coverageType_pimpl_state_.position_coverageType_ = x;
}

void position_coverageType_pimpl::
pre ()
{
  ::position_coverageType* x = new ::position_coverageType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void position_coverageType_pimpl::
encoder (const ::encoderType& x)
{
  this->position_coverageType_pimpl_state_.position_coverageType_->encoder (x);
}

void position_coverageType_pimpl::
limitswitches (::limitswitchesType* x)
{
  this->position_coverageType_pimpl_state_.position_coverageType_->limitswitches (x);
}

::position_coverageType* position_coverageType_pimpl::
post_position_coverageType ()
{
  ::position_coverageType* r = this->position_coverageType_pimpl_state_.position_coverageType_;
  this->position_coverageType_pimpl_state_.position_coverageType_ = 0;
  return r;
}

// supervisionType_pimpl
//

supervisionType_pimpl::
supervisionType_pimpl ()
: supervisionType_pskel (&base_impl_)
{
}

void supervisionType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->supervisionType_pimpl_state_.supervisionType_ = ::supervisionType ();
}

void supervisionType_pimpl::
steploss_warn_limit (signed char x)
{
  this->supervisionType_pimpl_state_.supervisionType_.steploss_warn_limit (x);
}

void supervisionType_pimpl::
steploss_error_limit (signed char x)
{
  this->supervisionType_pimpl_state_.supervisionType_.steploss_error_limit (x);
}

void supervisionType_pimpl::
current_limit (short x)
{
  this->supervisionType_pimpl_state_.supervisionType_.current_limit (x);
}

::supervisionType supervisionType_pimpl::
post_supervisionType ()
{
  static_cast< ::std::string& > (this->supervisionType_pimpl_state_.supervisionType_) =
  this->base_impl_.post_string ();
  return this->supervisionType_pimpl_state_.supervisionType_;
}

// driverType_pimpl
//

driverType_pimpl::
driverType_pimpl ()
: driverType_pskel (&base_impl_)
{
}

void driverType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->driverType_pimpl_state_.driverType_ = ::driverType ();
}

void driverType_pimpl::
type (const ::std::string& x)
{
  this->driverType_pimpl_state_.driverType_.type (x);
}

void driverType_pimpl::
reg_chopConf (const ::std::string& x)
{
  this->driverType_pimpl_state_.driverType_.reg_chopConf (x);
}

void driverType_pimpl::
reg_smartEn (const ::std::string& x)
{
  this->driverType_pimpl_state_.driverType_.reg_smartEn (x);
}

void driverType_pimpl::
reg_sgcsConf (const ::std::string& x)
{
  this->driverType_pimpl_state_.driverType_.reg_sgcsConf (x);
}

void driverType_pimpl::
reg_drvConf (const ::std::string& x)
{
  this->driverType_pimpl_state_.driverType_.reg_drvConf (x);
}

::driverType driverType_pimpl::
post_driverType ()
{
  static_cast< ::std::string& > (this->driverType_pimpl_state_.driverType_) =
  this->base_impl_.post_string ();
  return this->driverType_pimpl_state_.driverType_;
}

// motion_profileType_pimpl
//

motion_profileType_pimpl::
motion_profileType_pimpl ()
: motion_profileType_pskel (&base_impl_)
{
}

void motion_profileType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->motion_profileType_pimpl_state_.motion_profileType_ = ::motion_profileType ();
}

void motion_profileType_pimpl::
speed_min (signed char x)
{
  this->motion_profileType_pimpl_state_.motion_profileType_.speed_min (x);
}

void motion_profileType_pimpl::
speed_max (short x)
{
  this->motion_profileType_pimpl_state_.motion_profileType_.speed_max (x);
}

void motion_profileType_pimpl::
acc (short x)
{
  this->motion_profileType_pimpl_state_.motion_profileType_.acc (x);
}

void motion_profileType_pimpl::
dec (short x)
{
  this->motion_profileType_pimpl_state_.motion_profileType_.dec (x);
}

void motion_profileType_pimpl::
acc_time (signed char x)
{
  this->motion_profileType_pimpl_state_.motion_profileType_.acc_time (x);
}

void motion_profileType_pimpl::
dec_time (signed char x)
{
  this->motion_profileType_pimpl_state_.motion_profileType_.dec_time (x);
}

void motion_profileType_pimpl::
micro_steps (signed char x)
{
  this->motion_profileType_pimpl_state_.motion_profileType_.micro_steps (x);
}

void motion_profileType_pimpl::
ramp_type (signed char x)
{
  this->motion_profileType_pimpl_state_.motion_profileType_.ramp_type (x);
}

::motion_profileType motion_profileType_pimpl::
post_motion_profileType ()
{
  static_cast< ::std::string& > (this->motion_profileType_pimpl_state_.motion_profileType_) =
  this->base_impl_.post_string ();
  return this->motion_profileType_pimpl_state_.motion_profileType_;
}

// motion_profilesType_pimpl
//

motion_profilesType_pimpl::
motion_profilesType_pimpl (bool b)
{
  this->motion_profilesType_pimpl_base_ = b;
  this->motion_profilesType_pimpl_state_.motion_profilesType_ = 0;
}

motion_profilesType_pimpl::
~motion_profilesType_pimpl ()
{
  if (!this->motion_profilesType_pimpl_base_ && this->motion_profilesType_pimpl_state_.motion_profilesType_)
    delete this->motion_profilesType_pimpl_state_.motion_profilesType_;
}

void motion_profilesType_pimpl::
_reset ()
{
  motion_profilesType_pskel::_reset ();

  if (!this->motion_profilesType_pimpl_base_ && this->motion_profilesType_pimpl_state_.motion_profilesType_)
  {
    delete this->motion_profilesType_pimpl_state_.motion_profilesType_;
    this->motion_profilesType_pimpl_state_.motion_profilesType_ = 0;
  }
}

void motion_profilesType_pimpl::
pre_impl (::motion_profilesType* x)
{
  this->motion_profilesType_pimpl_state_.motion_profilesType_ = x;
}

void motion_profilesType_pimpl::
pre ()
{
  ::motion_profilesType* x = new ::motion_profilesType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void motion_profilesType_pimpl::
motion_profile (const ::motion_profileType& x)
{
  if (this->motion_profilesType_pimpl_state_.motion_profilesType_->motion_profile ().push_back (x))
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

::motion_profilesType* motion_profilesType_pimpl::
post_motion_profilesType ()
{
  ::motion_profilesType* r = this->motion_profilesType_pimpl_state_.motion_profilesType_;
  this->motion_profilesType_pimpl_state_.motion_profilesType_ = 0;
  return r;
}

// pid_controllerType_pimpl
//

pid_controllerType_pimpl::
pid_controllerType_pimpl ()
: pid_controllerType_pskel (&base_impl_)
{
}

void pid_controllerType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->pid_controllerType_pimpl_state_.pid_controllerType_ = ::pid_controllerType ();
}

void pid_controllerType_pimpl::
max_temperature (short x)
{
  this->pid_controllerType_pimpl_state_.pid_controllerType_.max_temperature (x);
}

void pid_controllerType_pimpl::
controller_gain (short x)
{
  this->pid_controllerType_pimpl_state_.pid_controllerType_.controller_gain (x);
}

void pid_controllerType_pimpl::
reset_time (short x)
{
  this->pid_controllerType_pimpl_state_.pid_controllerType_.reset_time (x);
}

void pid_controllerType_pimpl::
derivative_time (signed char x)
{
  this->pid_controllerType_pimpl_state_.pid_controllerType_.derivative_time (x);
}

void pid_controllerType_pimpl::
max_pressure (signed char x)
{
  this->pid_controllerType_pimpl_state_.pid_controllerType_.max_pressure (x);
}

void pid_controllerType_pimpl::
min_pressure (signed char x)
{
  this->pid_controllerType_pimpl_state_.pid_controllerType_.min_pressure (x);
}

::pid_controllerType pid_controllerType_pimpl::
post_pid_controllerType ()
{
  static_cast< ::std::string& > (this->pid_controllerType_pimpl_state_.pid_controllerType_) =
  this->base_impl_.post_string ();
  return this->pid_controllerType_pimpl_state_.pid_controllerType_;
}

// pid_controllersType_pimpl
//

void pid_controllersType_pimpl::
pre ()
{
  this->pid_controllersType_pimpl_state_.pid_controllersType_ = ::pid_controllersType ();
}

void pid_controllersType_pimpl::
pid_controller (const ::pid_controllerType& x)
{
  this->pid_controllersType_pimpl_state_.pid_controllersType_.pid_controller (x);
}

::pid_controllersType pid_controllersType_pimpl::
post_pid_controllersType ()
{
  return this->pid_controllersType_pimpl_state_.pid_controllersType_;
}

// pwm_controllerType_pimpl
//

pwm_controllerType_pimpl::
pwm_controllerType_pimpl ()
: pwm_controllerType_pskel (&base_impl_)
{
}

void pwm_controllerType_pimpl::
pre ()
{
  this->base_impl_.pre ();
  this->pwm_controllerType_pimpl_state_.pwm_controllerType_ = ::pwm_controllerType ();
}

void pwm_controllerType_pimpl::
max_actuating_value (short x)
{
  this->pwm_controllerType_pimpl_state_.pwm_controllerType_.max_actuating_value (x);
}

void pwm_controllerType_pimpl::
min_actuating_value (short x)
{
  this->pwm_controllerType_pimpl_state_.pwm_controllerType_.min_actuating_value (x);
}

void pwm_controllerType_pimpl::
max_pwm_duty (signed char x)
{
  this->pwm_controllerType_pimpl_state_.pwm_controllerType_.max_pwm_duty (x);
}

void pwm_controllerType_pimpl::
min_pwm_duty (signed char x)
{
  this->pwm_controllerType_pimpl_state_.pwm_controllerType_.min_pwm_duty (x);
}

::pwm_controllerType pwm_controllerType_pimpl::
post_pwm_controllerType ()
{
  static_cast< ::std::string& > (this->pwm_controllerType_pimpl_state_.pwm_controllerType_) =
  this->base_impl_.post_string ();
  return this->pwm_controllerType_pimpl_state_.pwm_controllerType_;
}

// functionmoduleType_pimpl
//

functionmoduleType_pimpl::
functionmoduleType_pimpl (bool b)
{
  this->functionmoduleType_pimpl_base_ = b;
  this->functionmoduleType_pimpl_state_.functionmoduleType_ = 0;
}

functionmoduleType_pimpl::
~functionmoduleType_pimpl ()
{
  if (!this->functionmoduleType_pimpl_base_ && this->functionmoduleType_pimpl_state_.functionmoduleType_)
    delete this->functionmoduleType_pimpl_state_.functionmoduleType_;
}

void functionmoduleType_pimpl::
_reset ()
{
  functionmoduleType_pskel::_reset ();

  if (!this->functionmoduleType_pimpl_base_ && this->functionmoduleType_pimpl_state_.functionmoduleType_)
  {
    delete this->functionmoduleType_pimpl_state_.functionmoduleType_;
    this->functionmoduleType_pimpl_state_.functionmoduleType_ = 0;
  }
}

void functionmoduleType_pimpl::
pre_impl (::functionmoduleType* x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_ = x;
}

void functionmoduleType_pimpl::
pre ()
{
  ::functionmoduleType* x = new ::functionmoduleType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void functionmoduleType_pimpl::
type (const ::std::string& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->type (x);
}

void functionmoduleType_pimpl::
key (const ::std::string& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->key (x);
}

void functionmoduleType_pimpl::
name (const ::std::string& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->name (x);
}

void functionmoduleType_pimpl::
interface (signed char x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->interface (x);
}

void functionmoduleType_pimpl::
fct_instanceID (const ::std::string& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->fct_instanceID (x);
}

void functionmoduleType_pimpl::
rotation (const ::rotationType& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->rotation (x);
}

void functionmoduleType_pimpl::
reference_run (const ::reference_runType& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->reference_run (x);
}

void functionmoduleType_pimpl::
position_coverage (::position_coverageType* x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->position_coverage (x);
}

void functionmoduleType_pimpl::
supervision (const ::supervisionType& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->supervision (x);
}

void functionmoduleType_pimpl::
driver (const ::driverType& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->driver (x);
}

void functionmoduleType_pimpl::
motion_profiles (::motion_profilesType* x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->motion_profiles (x);
}

void functionmoduleType_pimpl::
configuration (const ::configurationType& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->configuration (x);
}

void functionmoduleType_pimpl::
pid_controllers (const ::pid_controllersType& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->pid_controllers (x);
}

void functionmoduleType_pimpl::
pwm_controller (const ::pwm_controllerType& x)
{
  this->functionmoduleType_pimpl_state_.functionmoduleType_->pwm_controller (x);
}

::functionmoduleType* functionmoduleType_pimpl::
post_functionmoduleType ()
{
  ::functionmoduleType* r = this->functionmoduleType_pimpl_state_.functionmoduleType_;
  this->functionmoduleType_pimpl_state_.functionmoduleType_ = 0;
  return r;
}

// functionmodulesType_pimpl
//

functionmodulesType_pimpl::
functionmodulesType_pimpl (bool b)
{
  this->functionmodulesType_pimpl_base_ = b;
  this->functionmodulesType_pimpl_state_.functionmodulesType_ = 0;
}

functionmodulesType_pimpl::
~functionmodulesType_pimpl ()
{
  if (!this->functionmodulesType_pimpl_base_ && this->functionmodulesType_pimpl_state_.functionmodulesType_)
    delete this->functionmodulesType_pimpl_state_.functionmodulesType_;
}

void functionmodulesType_pimpl::
_reset ()
{
  functionmodulesType_pskel::_reset ();

  if (!this->functionmodulesType_pimpl_base_ && this->functionmodulesType_pimpl_state_.functionmodulesType_)
  {
    delete this->functionmodulesType_pimpl_state_.functionmodulesType_;
    this->functionmodulesType_pimpl_state_.functionmodulesType_ = 0;
  }
}

void functionmodulesType_pimpl::
pre_impl (::functionmodulesType* x)
{
  this->functionmodulesType_pimpl_state_.functionmodulesType_ = x;
}

void functionmodulesType_pimpl::
pre ()
{
  ::functionmodulesType* x = new ::functionmodulesType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void functionmodulesType_pimpl::
functionmodule (::functionmoduleType* x)
{
  if (this->functionmodulesType_pimpl_state_.functionmodulesType_->functionmodule ().push_back (x))
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

::functionmodulesType* functionmodulesType_pimpl::
post_functionmodulesType ()
{
  ::functionmodulesType* r = this->functionmodulesType_pimpl_state_.functionmodulesType_;
  this->functionmodulesType_pimpl_state_.functionmodulesType_ = 0;
  return r;
}

// slaveType_pimpl
//

slaveType_pimpl::
slaveType_pimpl (bool b)
{
  this->slaveType_pimpl_base_ = b;
  this->slaveType_pimpl_state_.slaveType_ = 0;
}

slaveType_pimpl::
~slaveType_pimpl ()
{
  if (!this->slaveType_pimpl_base_ && this->slaveType_pimpl_state_.slaveType_)
    delete this->slaveType_pimpl_state_.slaveType_;
}

void slaveType_pimpl::
_reset ()
{
  slaveType_pskel::_reset ();

  if (!this->slaveType_pimpl_base_ && this->slaveType_pimpl_state_.slaveType_)
  {
    delete this->slaveType_pimpl_state_.slaveType_;
    this->slaveType_pimpl_state_.slaveType_ = 0;
  }
}

void slaveType_pimpl::
pre_impl (::slaveType* x)
{
  this->slaveType_pimpl_state_.slaveType_ = x;
}

void slaveType_pimpl::
pre ()
{
  ::slaveType* x = new ::slaveType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void slaveType_pimpl::
type (const ::std::string& x)
{
  this->slaveType_pimpl_state_.slaveType_->type (x);
}

void slaveType_pimpl::
key (const ::std::string& x)
{
  this->slaveType_pimpl_state_.slaveType_->key (x);
}

void slaveType_pimpl::
name (const ::std::string& x)
{
  this->slaveType_pimpl_state_.slaveType_->name (x);
}

void slaveType_pimpl::
virtual_ (signed char x)
{
  this->slaveType_pimpl_state_.slaveType_->virtual_ (x);
}

void slaveType_pimpl::
nodetype (signed char x)
{
  this->slaveType_pimpl_state_.slaveType_->nodetype (x);
}

void slaveType_pimpl::
nodeindex (signed char x)
{
  this->slaveType_pimpl_state_.slaveType_->nodeindex (x);
}

void slaveType_pimpl::
functionmodules (::functionmodulesType* x)
{
  this->slaveType_pimpl_state_.slaveType_->functionmodules (x);
}

::slaveType* slaveType_pimpl::
post_slaveType ()
{
  ::slaveType* r = this->slaveType_pimpl_state_.slaveType_;
  this->slaveType_pimpl_state_.slaveType_ = 0;
  return r;
}

// parameter_slavesType_pimpl
//

parameter_slavesType_pimpl::
parameter_slavesType_pimpl (bool b)
{
  this->parameter_slavesType_pimpl_base_ = b;
  this->parameter_slavesType_pimpl_state_.parameter_slavesType_ = 0;
}

parameter_slavesType_pimpl::
~parameter_slavesType_pimpl ()
{
  if (!this->parameter_slavesType_pimpl_base_ && this->parameter_slavesType_pimpl_state_.parameter_slavesType_)
    delete this->parameter_slavesType_pimpl_state_.parameter_slavesType_;
}

void parameter_slavesType_pimpl::
_reset ()
{
  parameter_slavesType_pskel::_reset ();

  if (!this->parameter_slavesType_pimpl_base_ && this->parameter_slavesType_pimpl_state_.parameter_slavesType_)
  {
    delete this->parameter_slavesType_pimpl_state_.parameter_slavesType_;
    this->parameter_slavesType_pimpl_state_.parameter_slavesType_ = 0;
  }
}

void parameter_slavesType_pimpl::
pre_impl (::parameter_slavesType* x)
{
  this->parameter_slavesType_pimpl_state_.parameter_slavesType_ = x;
}

void parameter_slavesType_pimpl::
pre ()
{
  ::parameter_slavesType* x = new ::parameter_slavesType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void parameter_slavesType_pimpl::
slave (::slaveType* x)
{
  if (this->parameter_slavesType_pimpl_state_.parameter_slavesType_->slave ().push_back (x))
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

::parameter_slavesType* parameter_slavesType_pimpl::
post_parameter_slavesType ()
{
  ::parameter_slavesType* r = this->parameter_slavesType_pimpl_state_.parameter_slavesType_;
  this->parameter_slavesType_pimpl_state_.parameter_slavesType_ = 0;
  return r;
}

// hwconfigType_pimpl
//

hwconfigType_pimpl::
hwconfigType_pimpl (bool b)
{
  this->hwconfigType_pimpl_base_ = b;
  this->hwconfigType_pimpl_state_.hwconfigType_ = 0;
}

hwconfigType_pimpl::
~hwconfigType_pimpl ()
{
  if (!this->hwconfigType_pimpl_base_ && this->hwconfigType_pimpl_state_.hwconfigType_)
    delete this->hwconfigType_pimpl_state_.hwconfigType_;
}

void hwconfigType_pimpl::
_reset ()
{
  hwconfigType_pskel::_reset ();

  if (!this->hwconfigType_pimpl_base_ && this->hwconfigType_pimpl_state_.hwconfigType_)
  {
    delete this->hwconfigType_pimpl_state_.hwconfigType_;
    this->hwconfigType_pimpl_state_.hwconfigType_ = 0;
  }
}

void hwconfigType_pimpl::
pre_impl (::hwconfigType* x)
{
  this->hwconfigType_pimpl_state_.hwconfigType_ = x;
}

void hwconfigType_pimpl::
pre ()
{
  ::hwconfigType* x = new ::hwconfigType;

  if (x)
  {
    this->pre_impl (x);
  }
  else
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
}

void hwconfigType_pimpl::
version (float x)
{
  this->hwconfigType_pimpl_state_.hwconfigType_->version (x);
}

void hwconfigType_pimpl::
parameter_master (::parameter_masterType* x)
{
  this->hwconfigType_pimpl_state_.hwconfigType_->parameter_master (x);
}

void hwconfigType_pimpl::
parameter_slaves (::parameter_slavesType* x)
{
  this->hwconfigType_pimpl_state_.hwconfigType_->parameter_slaves (x);
}

void hwconfigType_pimpl::
devices (::devicesType* x)
{
  this->hwconfigType_pimpl_state_.hwconfigType_->devices (x);
}

::hwconfigType* hwconfigType_pimpl::
post_hwconfigType ()
{
  ::hwconfigType* r = this->hwconfigType_pimpl_state_.hwconfigType_;
  this->hwconfigType_pimpl_state_.hwconfigType_ = 0;
  return r;
}

// hwconfig_paggr
//

hwconfig_paggr::
hwconfig_paggr ()
{
  this->can_interfaceType_p_.parsers (this->string_p_);

  this->tcp_interfaceType_p_.parsers (this->byte_p_);

  this->serial_numberType_p_.parsers (this->string_p_);

  this->deviceType_p_.parsers (this->string_p_,
                               this->string_p_,
                               this->string_p_,
                               this->string_p_,
                               this->byte_p_,
                               this->functionmodulesType_p_);

  this->devicesType_p_.parsers (this->deviceType_p_);

  this->retortType_p_.parsers (this->string_p_,
                               this->byte_p_,
                               this->devicesType_p_);

  this->retortsType_p_.parsers (this->retortType_p_);

  this->parameter_masterType_p_.parsers (this->string_p_,
                                         this->can_interfaceType_p_,
                                         this->tcp_interfaceType_p_,
                                         this->byte_p_,
                                         this->byte_p_,
                                         this->serial_numberType_p_,
                                         this->retortsType_p_);

  this->rotationType_p_.parsers (this->string_p_,
                                 this->string_p_,
                                 this->short_p_,
                                 this->short_p_,
                                 this->short_p_,
                                 this->byte_p_,
                                 this->short_p_,
                                 this->byte_p_,
                                 this->byte_p_,
                                 this->short_p_);

  this->reference_runType_p_.parsers (this->byte_p_,
                                      this->short_p_,
                                      this->int_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->short_p_,
                                      this->byte_p_);

  this->encoderType_p_.parsers (this->byte_p_,
                                this->short_p_,
                                this->string_p_);

  this->configurationType_p_.parsers (this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->short_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_);

  this->limitswitchType_p_.parsers (this->byte_p_,
                                    this->configurationType_p_);

  this->position_codeType_p_.parsers (this->byte_p_,
                                      this->byte_p_,
                                      this->string_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_,
                                      this->byte_p_);

  this->limitswitchesType_p_.parsers (this->limitswitchType_p_,
                                      this->position_codeType_p_);

  this->position_coverageType_p_.parsers (this->encoderType_p_,
                                          this->limitswitchesType_p_);

  this->supervisionType_p_.parsers (this->byte_p_,
                                    this->byte_p_,
                                    this->short_p_);

  this->driverType_p_.parsers (this->string_p_,
                               this->string_p_,
                               this->string_p_,
                               this->string_p_,
                               this->string_p_);

  this->motion_profileType_p_.parsers (this->byte_p_,
                                       this->short_p_,
                                       this->short_p_,
                                       this->short_p_,
                                       this->byte_p_,
                                       this->byte_p_,
                                       this->byte_p_,
                                       this->byte_p_);

  this->motion_profilesType_p_.parsers (this->motion_profileType_p_);

  this->functionmoduleType_p_.parsers (this->string_p_,
                                       this->string_p_,
                                       this->string_p_,
                                       this->byte_p_,
                                       this->string_p_,
                                       this->rotationType_p_,
                                       this->reference_runType_p_,
                                       this->position_coverageType_p_,
                                       this->supervisionType_p_,
                                       this->driverType_p_,
                                       this->motion_profilesType_p_,
                                       this->configurationType_p_,
                                       this->pid_controllersType_p_,
                                       this->pwm_controllerType_p_);

  this->pid_controllerType_p_.parsers (this->short_p_,
                                       this->short_p_,
                                       this->short_p_,
                                       this->byte_p_,
                                       this->byte_p_,
                                       this->byte_p_);

  this->pid_controllersType_p_.parsers (this->pid_controllerType_p_);

  this->functionmodulesType_p_.parsers (this->functionmoduleType_p_);

  this->slaveType_p_.parsers (this->string_p_,
                              this->string_p_,
                              this->string_p_,
                              this->byte_p_,
                              this->byte_p_,
                              this->byte_p_,
                              this->functionmodulesType_p_);

  this->pwm_controllerType_p_.parsers (this->short_p_,
                                       this->short_p_,
                                       this->byte_p_,
                                       this->byte_p_);

  this->parameter_slavesType_p_.parsers (this->slaveType_p_);

  this->hwconfigType_p_.parsers (this->float_p_,
                                 this->parameter_masterType_p_,
                                 this->parameter_slavesType_p_,
                                 this->devicesType_p_);
}

const char* hwconfig_paggr::
root_name ()
{
  return "hwconfig";
}

const char* hwconfig_paggr::
root_namespace ()
{
  return "";
}

// Begin epilogue.
//
//
// End epilogue.

