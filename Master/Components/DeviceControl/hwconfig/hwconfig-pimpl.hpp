// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef HWCONFIG_PIMPL_HPP
#define HWCONFIG_PIMPL_HPP

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#ifndef XSDE_OMIT_PAGGR
#  define XSDE_OMIT_PAGGR
#  define HWCONFIG_PIMPL_HPP_CLEAR_OMIT_PAGGR
#endif

#include "hwconfig-pskel.hpp"

#include <xsde/cxx/stack.hxx>

class can_interfaceType_pimpl: public can_interfaceType_pskel
{
  public:
  can_interfaceType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  interface (const ::std::string&);

  virtual ::can_interfaceType
  post_can_interfaceType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct can_interfaceType_pimpl_state
  {
    ::can_interfaceType can_interfaceType_;
  };

  can_interfaceType_pimpl_state can_interfaceType_pimpl_state_;
};

class tcp_interfaceType_pimpl: public tcp_interfaceType_pskel
{
  public:
  tcp_interfaceType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  usage (signed char);

  virtual ::tcp_interfaceType
  post_tcp_interfaceType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct tcp_interfaceType_pimpl_state
  {
    ::tcp_interfaceType tcp_interfaceType_;
  };

  tcp_interfaceType_pimpl_state tcp_interfaceType_pimpl_state_;
};

class serial_numberType_pimpl: public serial_numberType_pskel
{
  public:
  serial_numberType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  serialno (const ::std::string&);

  virtual ::serial_numberType
  post_serial_numberType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct serial_numberType_pimpl_state
  {
    ::serial_numberType serial_numberType_;
  };

  serial_numberType_pimpl_state serial_numberType_pimpl_state_;
};

class deviceType_pimpl: public deviceType_pskel
{
  public:
  deviceType_pimpl (bool = false);

  ~deviceType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  name (const ::std::string&);

  virtual void
  id (const ::std::string&);

  virtual void
  type (const ::std::string&);

  virtual void
  dev_instanceID (const ::std::string&);

  virtual void
  optional (signed char);

  // Elements.
  //
  virtual void
  functionmodules (::functionmodulesType*);

  virtual ::deviceType*
  post_deviceType ();

  public:
  void
  pre_impl (::deviceType*);

  public:
  struct deviceType_pimpl_state
  {
    ::deviceType* deviceType_;
  };

  deviceType_pimpl_state deviceType_pimpl_state_;
  bool deviceType_pimpl_base_;
};

class devicesType_pimpl: public devicesType_pskel
{
  public:
  devicesType_pimpl (bool = false);

  ~devicesType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Elements.
  //
  virtual void
  device (::deviceType*);

  virtual ::devicesType*
  post_devicesType ();

  public:
  void
  pre_impl (::devicesType*);

  public:
  struct devicesType_pimpl_state
  {
    ::devicesType* devicesType_;
  };

  devicesType_pimpl_state devicesType_pimpl_state_;
  bool devicesType_pimpl_base_;
};

class retortType_pimpl: public retortType_pskel
{
  public:
  retortType_pimpl (bool = false);

  ~retortType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  name (const ::std::string&);

  virtual void
  index (signed char);

  // Elements.
  //
  virtual void
  devices (::devicesType*);

  virtual ::retortType*
  post_retortType ();

  public:
  void
  pre_impl (::retortType*);

  public:
  struct retortType_pimpl_state
  {
    ::retortType* retortType_;
  };

  retortType_pimpl_state retortType_pimpl_state_;
  bool retortType_pimpl_base_;
};

class retortsType_pimpl: public retortsType_pskel
{
  public:
  retortsType_pimpl (bool = false);

  ~retortsType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Elements.
  //
  virtual void
  retort (::retortType*);

  virtual ::retortsType*
  post_retortsType ();

  public:
  void
  pre_impl (::retortsType*);

  public:
  struct retortsType_pimpl_state
  {
    ::retortsType* retortsType_;
  };

  retortsType_pimpl_state retortsType_pimpl_state_;
  bool retortsType_pimpl_base_;
};

class parameter_masterType_pimpl: public parameter_masterType_pskel
{
  public:
  parameter_masterType_pimpl (bool = false);

  ~parameter_masterType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  folded (const ::std::string&);

  // Elements.
  //
  virtual void
  can_interface (const ::can_interfaceType&);

  virtual void
  tcp_interface (const ::tcp_interfaceType&);

  virtual void
  nodetype (signed char);

  virtual void
  nodeindex (signed char);

  virtual void
  serial_number (const ::serial_numberType&);

  virtual void
  retorts (::retortsType*);

  virtual ::parameter_masterType*
  post_parameter_masterType ();

  public:
  void
  pre_impl (::parameter_masterType*);

  public:
  struct parameter_masterType_pimpl_state
  {
    ::parameter_masterType* parameter_masterType_;
  };

  parameter_masterType_pimpl_state parameter_masterType_pimpl_state_;
  bool parameter_masterType_pimpl_base_;
};

class rotationType_pimpl: public rotationType_pskel
{
  public:
  rotationType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  type (const ::std::string&);

  virtual void
  direction (const ::std::string&);

  virtual void
  steps_revolution (short);

  virtual void
  position_min (short);

  virtual void
  position_max (short);

  virtual void
  speed_min (signed char);

  virtual void
  speed_max (short);

  virtual void
  run_cs (signed char);

  virtual void
  stop_cs (signed char);

  virtual void
  stop_cs_delay (short);

  virtual ::rotationType
  post_rotationType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct rotationType_pimpl_state
  {
    ::rotationType rotationType_;
  };

  rotationType_pimpl_state rotationType_pimpl_state_;
};

class reference_runType_pimpl: public reference_runType_pskel
{
  public:
  reference_runType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  ref_position (signed char);

  virtual void
  max_distance (short);

  virtual void
  timeout (int);

  virtual void
  reverse_distance (signed char);

  virtual void
  slow_speed (signed char);

  virtual void
  high_speed (short);

  virtual void
  refpos_offset (signed char);

  virtual ::reference_runType
  post_reference_runType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct reference_runType_pimpl_state
  {
    ::reference_runType reference_runType_;
  };

  reference_runType_pimpl_state reference_runType_pimpl_state_;
};

class encoderType_pimpl: public encoderType_pskel
{
  public:
  encoderType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  type (signed char);

  virtual void
  resolution (short);

  virtual void
  rotation (const ::std::string&);

  virtual ::encoderType
  post_encoderType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct encoderType_pimpl_state
  {
    ::encoderType encoderType_;
  };

  encoderType_pimpl_state encoderType_pimpl_state_;
};

class configurationType_pimpl: public configurationType_pskel
{
  public:
  configurationType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  polarity (signed char);

  virtual void
  sample_rate (signed char);

  virtual void
  debounce (signed char);

  virtual void
  temp_tolerance (signed char);

  virtual void
  sampling_period (short);

  virtual void
  fan_speed (short);

  virtual void
  fan_threshold (short);

  virtual void
  current_gain (short);

  virtual void
  heater_current (short);

  virtual void
  heater_threshold (short);

  virtual void
  current_deviation (short);

  virtual void
  current_min_230_serial (short);

  virtual void
  current_max_230_serial (short);

  virtual void
  current_min_100_serial (short);

  virtual void
  current_max_100_serial (short);

  virtual void
  current_min_100_parallel (short);

  virtual void
  current_max_100_parallel (short);

  virtual void
  pressure_tolerance (signed char);

  virtual void
  fan_current_gain (signed char);

  virtual void
  fan_current (short);

  virtual void
  pump_current (short);

  virtual void
  pump_threshold (short);

  virtual void
  enabled (signed char);

  virtual void
  inactiv_shutdown (signed char);

  virtual void
  inactiv_emcy (signed char);

  virtual void
  outval_inactiv (signed char);

  virtual void
  livetime_limit (signed char);

  virtual void
  timestamp (signed char);

  virtual void
  threshold (signed char);

  virtual void
  interval (signed char);

  virtual ::configurationType
  post_configurationType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct configurationType_pimpl_state
  {
    ::configurationType configurationType_;
  };

  configurationType_pimpl_state configurationType_pimpl_state_;
};

class limitswitchType_pimpl: public limitswitchType_pskel
{
  public:
  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  index (signed char);

  // Elements.
  //
  virtual void
  configuration (const ::configurationType&);

  virtual ::limitswitchType
  post_limitswitchType ();

  public:
  struct limitswitchType_pimpl_state
  {
    ::limitswitchType limitswitchType_;
  };

  limitswitchType_pimpl_state limitswitchType_pimpl_state_;
};

class position_codeType_pimpl: public position_codeType_pskel
{
  public:
  position_codeType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  value (signed char);

  virtual void
  stop (signed char);

  virtual void
  stop_dir (const ::std::string&);

  virtual void
  position (signed char);

  virtual void
  width (signed char);

  virtual void
  deviation (signed char);

  virtual void
  dir_check (signed char);

  virtual void
  hit_skip (signed char);

  virtual ::position_codeType
  post_position_codeType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct position_codeType_pimpl_state
  {
    ::position_codeType position_codeType_;
  };

  position_codeType_pimpl_state position_codeType_pimpl_state_;
};

class limitswitchesType_pimpl: public limitswitchesType_pskel
{
  public:
  limitswitchesType_pimpl (bool = false);

  ~limitswitchesType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Elements.
  //
  virtual void
  limitswitch (const ::limitswitchType&);

  virtual void
  position_code (const ::position_codeType&);

  virtual ::limitswitchesType*
  post_limitswitchesType ();

  public:
  void
  pre_impl (::limitswitchesType*);

  public:
  struct limitswitchesType_pimpl_state
  {
    ::limitswitchesType* limitswitchesType_;
  };

  limitswitchesType_pimpl_state limitswitchesType_pimpl_state_;
  bool limitswitchesType_pimpl_base_;
};

class position_coverageType_pimpl: public position_coverageType_pskel
{
  public:
  position_coverageType_pimpl (bool = false);

  ~position_coverageType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Elements.
  //
  virtual void
  encoder (const ::encoderType&);

  virtual void
  limitswitches (::limitswitchesType*);

  virtual ::position_coverageType*
  post_position_coverageType ();

  public:
  void
  pre_impl (::position_coverageType*);

  public:
  struct position_coverageType_pimpl_state
  {
    ::position_coverageType* position_coverageType_;
  };

  position_coverageType_pimpl_state position_coverageType_pimpl_state_;
  bool position_coverageType_pimpl_base_;
};

class supervisionType_pimpl: public supervisionType_pskel
{
  public:
  supervisionType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  steploss_warn_limit (signed char);

  virtual void
  steploss_error_limit (signed char);

  virtual void
  current_limit (short);

  virtual ::supervisionType
  post_supervisionType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct supervisionType_pimpl_state
  {
    ::supervisionType supervisionType_;
  };

  supervisionType_pimpl_state supervisionType_pimpl_state_;
};

class driverType_pimpl: public driverType_pskel
{
  public:
  driverType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  type (const ::std::string&);

  virtual void
  reg_chopConf (const ::std::string&);

  virtual void
  reg_smartEn (const ::std::string&);

  virtual void
  reg_sgcsConf (const ::std::string&);

  virtual void
  reg_drvConf (const ::std::string&);

  virtual ::driverType
  post_driverType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct driverType_pimpl_state
  {
    ::driverType driverType_;
  };

  driverType_pimpl_state driverType_pimpl_state_;
};

class motion_profileType_pimpl: public motion_profileType_pskel
{
  public:
  motion_profileType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  speed_min (signed char);

  virtual void
  speed_max (short);

  virtual void
  acc (short);

  virtual void
  dec (short);

  virtual void
  acc_time (signed char);

  virtual void
  dec_time (signed char);

  virtual void
  micro_steps (signed char);

  virtual void
  ramp_type (signed char);

  virtual ::motion_profileType
  post_motion_profileType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct motion_profileType_pimpl_state
  {
    ::motion_profileType motion_profileType_;
  };

  motion_profileType_pimpl_state motion_profileType_pimpl_state_;
};

class motion_profilesType_pimpl: public motion_profilesType_pskel
{
  public:
  motion_profilesType_pimpl (bool = false);

  ~motion_profilesType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Elements.
  //
  virtual void
  motion_profile (const ::motion_profileType&);

  virtual ::motion_profilesType*
  post_motion_profilesType ();

  public:
  void
  pre_impl (::motion_profilesType*);

  public:
  struct motion_profilesType_pimpl_state
  {
    ::motion_profilesType* motion_profilesType_;
  };

  motion_profilesType_pimpl_state motion_profilesType_pimpl_state_;
  bool motion_profilesType_pimpl_base_;
};

class pid_controllerType_pimpl: public pid_controllerType_pskel
{
  public:
  pid_controllerType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  max_temperature (short);

  virtual void
  controller_gain (short);

  virtual void
  reset_time (short);

  virtual void
  derivative_time (signed char);

  virtual void
  max_pressure (signed char);

  virtual void
  min_pressure (signed char);

  virtual ::pid_controllerType
  post_pid_controllerType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct pid_controllerType_pimpl_state
  {
    ::pid_controllerType pid_controllerType_;
  };

  pid_controllerType_pimpl_state pid_controllerType_pimpl_state_;
};

class pid_controllersType_pimpl: public pid_controllersType_pskel
{
  public:
  virtual void
  pre ();

  // Elements.
  //
  virtual void
  pid_controller (const ::pid_controllerType&);

  virtual ::pid_controllersType
  post_pid_controllersType ();

  public:
  struct pid_controllersType_pimpl_state
  {
    ::pid_controllersType pid_controllersType_;
  };

  pid_controllersType_pimpl_state pid_controllersType_pimpl_state_;
};

class pwm_controllerType_pimpl: public pwm_controllerType_pskel
{
  public:
  pwm_controllerType_pimpl ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  max_actuating_value (short);

  virtual void
  min_actuating_value (short);

  virtual void
  max_pwm_duty (signed char);

  virtual void
  min_pwm_duty (signed char);

  virtual ::pwm_controllerType
  post_pwm_controllerType ();

  public:
  ::xml_schema::string_pimpl base_impl_;

  public:
  struct pwm_controllerType_pimpl_state
  {
    ::pwm_controllerType pwm_controllerType_;
  };

  pwm_controllerType_pimpl_state pwm_controllerType_pimpl_state_;
};

class functionmoduleType_pimpl: public functionmoduleType_pskel
{
  public:
  functionmoduleType_pimpl (bool = false);

  ~functionmoduleType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  type (const ::std::string&);

  virtual void
  key (const ::std::string&);

  virtual void
  name (const ::std::string&);

  virtual void
  interface (signed char);

  virtual void
  fct_instanceID (const ::std::string&);

  // Elements.
  //
  virtual void
  rotation (const ::rotationType&);

  virtual void
  reference_run (const ::reference_runType&);

  virtual void
  position_coverage (::position_coverageType*);

  virtual void
  supervision (const ::supervisionType&);

  virtual void
  driver (const ::driverType&);

  virtual void
  motion_profiles (::motion_profilesType*);

  virtual void
  configuration (const ::configurationType&);

  virtual void
  pid_controllers (const ::pid_controllersType&);

  virtual void
  pwm_controller (const ::pwm_controllerType&);

  virtual ::functionmoduleType*
  post_functionmoduleType ();

  public:
  void
  pre_impl (::functionmoduleType*);

  public:
  struct functionmoduleType_pimpl_state
  {
    ::functionmoduleType* functionmoduleType_;
  };

  functionmoduleType_pimpl_state functionmoduleType_pimpl_state_;
  bool functionmoduleType_pimpl_base_;
};

class functionmodulesType_pimpl: public functionmodulesType_pskel
{
  public:
  functionmodulesType_pimpl (bool = false);

  ~functionmodulesType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Elements.
  //
  virtual void
  functionmodule (::functionmoduleType*);

  virtual ::functionmodulesType*
  post_functionmodulesType ();

  public:
  void
  pre_impl (::functionmodulesType*);

  public:
  struct functionmodulesType_pimpl_state
  {
    ::functionmodulesType* functionmodulesType_;
  };

  functionmodulesType_pimpl_state functionmodulesType_pimpl_state_;
  bool functionmodulesType_pimpl_base_;
};

class slaveType_pimpl: public slaveType_pskel
{
  public:
  slaveType_pimpl (bool = false);

  ~slaveType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  type (const ::std::string&);

  virtual void
  key (const ::std::string&);

  virtual void
  name (const ::std::string&);

  virtual void
  virtual_ (signed char);

  // Elements.
  //
  virtual void
  nodetype (signed char);

  virtual void
  nodeindex (signed char);

  virtual void
  functionmodules (::functionmodulesType*);

  virtual ::slaveType*
  post_slaveType ();

  public:
  void
  pre_impl (::slaveType*);

  public:
  struct slaveType_pimpl_state
  {
    ::slaveType* slaveType_;
  };

  slaveType_pimpl_state slaveType_pimpl_state_;
  bool slaveType_pimpl_base_;
};

class parameter_slavesType_pimpl: public parameter_slavesType_pskel
{
  public:
  parameter_slavesType_pimpl (bool = false);

  ~parameter_slavesType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Elements.
  //
  virtual void
  slave (::slaveType*);

  virtual ::parameter_slavesType*
  post_parameter_slavesType ();

  public:
  void
  pre_impl (::parameter_slavesType*);

  public:
  struct parameter_slavesType_pimpl_state
  {
    ::parameter_slavesType* parameter_slavesType_;
  };

  parameter_slavesType_pimpl_state parameter_slavesType_pimpl_state_;
  bool parameter_slavesType_pimpl_base_;
};

class hwconfigType_pimpl: public hwconfigType_pskel
{
  public:
  hwconfigType_pimpl (bool = false);

  ~hwconfigType_pimpl ();

  virtual void
  _reset ();

  virtual void
  pre ();

  // Attributes.
  //
  virtual void
  version (float);

  // Elements.
  //
  virtual void
  parameter_master (::parameter_masterType*);

  virtual void
  parameter_slaves (::parameter_slavesType*);

  virtual void
  devices (::devicesType*);

  virtual ::hwconfigType*
  post_hwconfigType ();

  public:
  void
  pre_impl (::hwconfigType*);

  public:
  struct hwconfigType_pimpl_state
  {
    ::hwconfigType* hwconfigType_;
  };

  hwconfigType_pimpl_state hwconfigType_pimpl_state_;
  bool hwconfigType_pimpl_base_;
};

#ifdef HWCONFIG_PIMPL_HPP_CLEAR_OMIT_PAGGR
#  undef XSDE_OMIT_PAGGR
#endif

#ifndef XSDE_OMIT_PAGGR

// Parser aggregate for the hwconfig element.
//
class hwconfig_paggr
{
  public:
  hwconfig_paggr ();

  void
  pre ()
  {
    this->hwconfigType_p_.pre ();
  }

  ::hwconfigType*
  post ()
  {
    return this->hwconfigType_p_.post_hwconfigType ();
  }

  ::hwconfigType_pimpl&
  root_parser ()
  {
    return this->hwconfigType_p_;
  }

  static const char*
  root_name ();

  static const char*
  root_namespace ();

  ::xml_schema::parser_error
  _error ()
  {
    return this->hwconfigType_p_._error ();
  }

  void
  reset ()
  {
    this->hwconfigType_p_._reset ();
  }

  public:
  ::xml_schema::byte_pimpl byte_p_;
  ::xml_schema::float_pimpl float_p_;
  ::can_interfaceType_pimpl can_interfaceType_p_;
  ::tcp_interfaceType_pimpl tcp_interfaceType_p_;
  ::serial_numberType_pimpl serial_numberType_p_;
  ::deviceType_pimpl deviceType_p_;
  ::xml_schema::int_pimpl int_p_;
  ::devicesType_pimpl devicesType_p_;
  ::retortType_pimpl retortType_p_;
  ::retortsType_pimpl retortsType_p_;
  ::parameter_masterType_pimpl parameter_masterType_p_;
  ::rotationType_pimpl rotationType_p_;
  ::reference_runType_pimpl reference_runType_p_;
  ::encoderType_pimpl encoderType_p_;
  ::configurationType_pimpl configurationType_p_;
  ::limitswitchType_pimpl limitswitchType_p_;
  ::position_codeType_pimpl position_codeType_p_;
  ::limitswitchesType_pimpl limitswitchesType_p_;
  ::position_coverageType_pimpl position_coverageType_p_;
  ::supervisionType_pimpl supervisionType_p_;
  ::driverType_pimpl driverType_p_;
  ::xml_schema::string_pimpl string_p_;
  ::xml_schema::short_pimpl short_p_;
  ::motion_profileType_pimpl motion_profileType_p_;
  ::motion_profilesType_pimpl motion_profilesType_p_;
  ::functionmoduleType_pimpl functionmoduleType_p_;
  ::pid_controllerType_pimpl pid_controllerType_p_;
  ::pid_controllersType_pimpl pid_controllersType_p_;
  ::functionmodulesType_pimpl functionmodulesType_p_;
  ::slaveType_pimpl slaveType_p_;
  ::pwm_controllerType_pimpl pwm_controllerType_p_;
  ::parameter_slavesType_pimpl parameter_slavesType_p_;
  ::hwconfigType_pimpl hwconfigType_p_;
};

#endif // XSDE_OMIT_PAGGR

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // HWCONFIG_PIMPL_HPP
