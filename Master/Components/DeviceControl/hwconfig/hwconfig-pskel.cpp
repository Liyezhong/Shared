// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include "hwconfig-pskel.hpp"

// can_interfaceType_pskel
//

void can_interfaceType_pskel::
interface_parser (::xml_schema::string_pskel& p)
{
  this->interface_parser_ = &p;
}

void can_interfaceType_pskel::
parsers (::xml_schema::string_pskel& interface)
{
  this->interface_parser_ = &interface;
}

can_interfaceType_pskel::
can_interfaceType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  can_interfaceType_impl_ (0),
  interface_parser_ (0)
{
}

can_interfaceType_pskel::
can_interfaceType_pskel (can_interfaceType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  can_interfaceType_impl_ (impl),
  interface_parser_ (0)
{
}

// tcp_interfaceType_pskel
//

void tcp_interfaceType_pskel::
usage_parser (::xml_schema::byte_pskel& p)
{
  this->usage_parser_ = &p;
}

void tcp_interfaceType_pskel::
parsers (::xml_schema::byte_pskel& usage)
{
  this->usage_parser_ = &usage;
}

tcp_interfaceType_pskel::
tcp_interfaceType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  tcp_interfaceType_impl_ (0),
  usage_parser_ (0)
{
}

tcp_interfaceType_pskel::
tcp_interfaceType_pskel (tcp_interfaceType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  tcp_interfaceType_impl_ (impl),
  usage_parser_ (0)
{
}

// serial_numberType_pskel
//

void serial_numberType_pskel::
serialno_parser (::xml_schema::string_pskel& p)
{
  this->serialno_parser_ = &p;
}

void serial_numberType_pskel::
parsers (::xml_schema::string_pskel& serialno)
{
  this->serialno_parser_ = &serialno;
}

serial_numberType_pskel::
serial_numberType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  serial_numberType_impl_ (0),
  serialno_parser_ (0)
{
}

serial_numberType_pskel::
serial_numberType_pskel (serial_numberType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  serial_numberType_impl_ (impl),
  serialno_parser_ (0)
{
}

// deviceType_pskel
//

void deviceType_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void deviceType_pskel::
id_parser (::xml_schema::string_pskel& p)
{
  this->id_parser_ = &p;
}

void deviceType_pskel::
type_parser (::xml_schema::string_pskel& p)
{
  this->type_parser_ = &p;
}

void deviceType_pskel::
dev_instanceID_parser (::xml_schema::string_pskel& p)
{
  this->dev_instanceID_parser_ = &p;
}

void deviceType_pskel::
optional_parser (::xml_schema::byte_pskel& p)
{
  this->optional_parser_ = &p;
}

void deviceType_pskel::
functionmodules_parser (::functionmodulesType_pskel& p)
{
  this->functionmodules_parser_ = &p;
}

void deviceType_pskel::
parsers (::xml_schema::string_pskel& name,
         ::xml_schema::string_pskel& id,
         ::xml_schema::string_pskel& type,
         ::xml_schema::string_pskel& dev_instanceID,
         ::xml_schema::byte_pskel& optional,
         ::functionmodulesType_pskel& functionmodules)
{
  this->name_parser_ = &name;
  this->id_parser_ = &id;
  this->type_parser_ = &type;
  this->dev_instanceID_parser_ = &dev_instanceID;
  this->optional_parser_ = &optional;
  this->functionmodules_parser_ = &functionmodules;
}

deviceType_pskel::
deviceType_pskel ()
: deviceType_impl_ (0),
  name_parser_ (0),
  id_parser_ (0),
  type_parser_ (0),
  dev_instanceID_parser_ (0),
  optional_parser_ (0),
  functionmodules_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

deviceType_pskel::
deviceType_pskel (deviceType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  deviceType_impl_ (impl),
  name_parser_ (0),
  id_parser_ (0),
  type_parser_ (0),
  dev_instanceID_parser_ (0),
  optional_parser_ (0),
  functionmodules_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// devicesType_pskel
//

void devicesType_pskel::
device_parser (::deviceType_pskel& p)
{
  this->device_parser_ = &p;
}

void devicesType_pskel::
parsers (::deviceType_pskel& device)
{
  this->device_parser_ = &device;
}

devicesType_pskel::
devicesType_pskel ()
: devicesType_impl_ (0),
  device_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

devicesType_pskel::
devicesType_pskel (devicesType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  devicesType_impl_ (impl),
  device_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// retortType_pskel
//

void retortType_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void retortType_pskel::
index_parser (::xml_schema::byte_pskel& p)
{
  this->index_parser_ = &p;
}

void retortType_pskel::
devices_parser (::devicesType_pskel& p)
{
  this->devices_parser_ = &p;
}

void retortType_pskel::
parsers (::xml_schema::string_pskel& name,
         ::xml_schema::byte_pskel& index,
         ::devicesType_pskel& devices)
{
  this->name_parser_ = &name;
  this->index_parser_ = &index;
  this->devices_parser_ = &devices;
}

retortType_pskel::
retortType_pskel ()
: retortType_impl_ (0),
  name_parser_ (0),
  index_parser_ (0),
  devices_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

retortType_pskel::
retortType_pskel (retortType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  retortType_impl_ (impl),
  name_parser_ (0),
  index_parser_ (0),
  devices_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// retortsType_pskel
//

void retortsType_pskel::
retort_parser (::retortType_pskel& p)
{
  this->retort_parser_ = &p;
}

void retortsType_pskel::
parsers (::retortType_pskel& retort)
{
  this->retort_parser_ = &retort;
}

retortsType_pskel::
retortsType_pskel ()
: retortsType_impl_ (0),
  retort_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

retortsType_pskel::
retortsType_pskel (retortsType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  retortsType_impl_ (impl),
  retort_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// parameter_masterType_pskel
//

void parameter_masterType_pskel::
folded_parser (::xml_schema::string_pskel& p)
{
  this->folded_parser_ = &p;
}

void parameter_masterType_pskel::
can_interface_parser (::can_interfaceType_pskel& p)
{
  this->can_interface_parser_ = &p;
}

void parameter_masterType_pskel::
tcp_interface_parser (::tcp_interfaceType_pskel& p)
{
  this->tcp_interface_parser_ = &p;
}

void parameter_masterType_pskel::
nodetype_parser (::xml_schema::byte_pskel& p)
{
  this->nodetype_parser_ = &p;
}

void parameter_masterType_pskel::
nodeindex_parser (::xml_schema::byte_pskel& p)
{
  this->nodeindex_parser_ = &p;
}

void parameter_masterType_pskel::
serial_number_parser (::serial_numberType_pskel& p)
{
  this->serial_number_parser_ = &p;
}

void parameter_masterType_pskel::
retorts_parser (::retortsType_pskel& p)
{
  this->retorts_parser_ = &p;
}

void parameter_masterType_pskel::
parsers (::xml_schema::string_pskel& folded,
         ::can_interfaceType_pskel& can_interface,
         ::tcp_interfaceType_pskel& tcp_interface,
         ::xml_schema::byte_pskel& nodetype,
         ::xml_schema::byte_pskel& nodeindex,
         ::serial_numberType_pskel& serial_number,
         ::retortsType_pskel& retorts)
{
  this->folded_parser_ = &folded;
  this->can_interface_parser_ = &can_interface;
  this->tcp_interface_parser_ = &tcp_interface;
  this->nodetype_parser_ = &nodetype;
  this->nodeindex_parser_ = &nodeindex;
  this->serial_number_parser_ = &serial_number;
  this->retorts_parser_ = &retorts;
}

parameter_masterType_pskel::
parameter_masterType_pskel ()
: parameter_masterType_impl_ (0),
  folded_parser_ (0),
  can_interface_parser_ (0),
  tcp_interface_parser_ (0),
  nodetype_parser_ (0),
  nodeindex_parser_ (0),
  serial_number_parser_ (0),
  retorts_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

parameter_masterType_pskel::
parameter_masterType_pskel (parameter_masterType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  parameter_masterType_impl_ (impl),
  folded_parser_ (0),
  can_interface_parser_ (0),
  tcp_interface_parser_ (0),
  nodetype_parser_ (0),
  nodeindex_parser_ (0),
  serial_number_parser_ (0),
  retorts_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// rotationType_pskel
//

void rotationType_pskel::
type_parser (::xml_schema::string_pskel& p)
{
  this->type_parser_ = &p;
}

void rotationType_pskel::
direction_parser (::xml_schema::string_pskel& p)
{
  this->direction_parser_ = &p;
}

void rotationType_pskel::
steps_revolution_parser (::xml_schema::short_pskel& p)
{
  this->steps_revolution_parser_ = &p;
}

void rotationType_pskel::
position_min_parser (::xml_schema::short_pskel& p)
{
  this->position_min_parser_ = &p;
}

void rotationType_pskel::
position_max_parser (::xml_schema::short_pskel& p)
{
  this->position_max_parser_ = &p;
}

void rotationType_pskel::
speed_min_parser (::xml_schema::byte_pskel& p)
{
  this->speed_min_parser_ = &p;
}

void rotationType_pskel::
speed_max_parser (::xml_schema::short_pskel& p)
{
  this->speed_max_parser_ = &p;
}

void rotationType_pskel::
run_cs_parser (::xml_schema::byte_pskel& p)
{
  this->run_cs_parser_ = &p;
}

void rotationType_pskel::
stop_cs_parser (::xml_schema::byte_pskel& p)
{
  this->stop_cs_parser_ = &p;
}

void rotationType_pskel::
stop_cs_delay_parser (::xml_schema::short_pskel& p)
{
  this->stop_cs_delay_parser_ = &p;
}

void rotationType_pskel::
parsers (::xml_schema::string_pskel& type,
         ::xml_schema::string_pskel& direction,
         ::xml_schema::short_pskel& steps_revolution,
         ::xml_schema::short_pskel& position_min,
         ::xml_schema::short_pskel& position_max,
         ::xml_schema::byte_pskel& speed_min,
         ::xml_schema::short_pskel& speed_max,
         ::xml_schema::byte_pskel& run_cs,
         ::xml_schema::byte_pskel& stop_cs,
         ::xml_schema::short_pskel& stop_cs_delay)
{
  this->type_parser_ = &type;
  this->direction_parser_ = &direction;
  this->steps_revolution_parser_ = &steps_revolution;
  this->position_min_parser_ = &position_min;
  this->position_max_parser_ = &position_max;
  this->speed_min_parser_ = &speed_min;
  this->speed_max_parser_ = &speed_max;
  this->run_cs_parser_ = &run_cs;
  this->stop_cs_parser_ = &stop_cs;
  this->stop_cs_delay_parser_ = &stop_cs_delay;
}

rotationType_pskel::
rotationType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  rotationType_impl_ (0),
  type_parser_ (0),
  direction_parser_ (0),
  steps_revolution_parser_ (0),
  position_min_parser_ (0),
  position_max_parser_ (0),
  speed_min_parser_ (0),
  speed_max_parser_ (0),
  run_cs_parser_ (0),
  stop_cs_parser_ (0),
  stop_cs_delay_parser_ (0)
{
}

rotationType_pskel::
rotationType_pskel (rotationType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  rotationType_impl_ (impl),
  type_parser_ (0),
  direction_parser_ (0),
  steps_revolution_parser_ (0),
  position_min_parser_ (0),
  position_max_parser_ (0),
  speed_min_parser_ (0),
  speed_max_parser_ (0),
  run_cs_parser_ (0),
  stop_cs_parser_ (0),
  stop_cs_delay_parser_ (0)
{
}

// reference_runType_pskel
//

void reference_runType_pskel::
ref_position_parser (::xml_schema::byte_pskel& p)
{
  this->ref_position_parser_ = &p;
}

void reference_runType_pskel::
max_distance_parser (::xml_schema::short_pskel& p)
{
  this->max_distance_parser_ = &p;
}

void reference_runType_pskel::
timeout_parser (::xml_schema::int_pskel& p)
{
  this->timeout_parser_ = &p;
}

void reference_runType_pskel::
reverse_distance_parser (::xml_schema::byte_pskel& p)
{
  this->reverse_distance_parser_ = &p;
}

void reference_runType_pskel::
slow_speed_parser (::xml_schema::byte_pskel& p)
{
  this->slow_speed_parser_ = &p;
}

void reference_runType_pskel::
high_speed_parser (::xml_schema::short_pskel& p)
{
  this->high_speed_parser_ = &p;
}

void reference_runType_pskel::
refpos_offset_parser (::xml_schema::byte_pskel& p)
{
  this->refpos_offset_parser_ = &p;
}

void reference_runType_pskel::
parsers (::xml_schema::byte_pskel& ref_position,
         ::xml_schema::short_pskel& max_distance,
         ::xml_schema::int_pskel& timeout,
         ::xml_schema::byte_pskel& reverse_distance,
         ::xml_schema::byte_pskel& slow_speed,
         ::xml_schema::short_pskel& high_speed,
         ::xml_schema::byte_pskel& refpos_offset)
{
  this->ref_position_parser_ = &ref_position;
  this->max_distance_parser_ = &max_distance;
  this->timeout_parser_ = &timeout;
  this->reverse_distance_parser_ = &reverse_distance;
  this->slow_speed_parser_ = &slow_speed;
  this->high_speed_parser_ = &high_speed;
  this->refpos_offset_parser_ = &refpos_offset;
}

reference_runType_pskel::
reference_runType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  reference_runType_impl_ (0),
  ref_position_parser_ (0),
  max_distance_parser_ (0),
  timeout_parser_ (0),
  reverse_distance_parser_ (0),
  slow_speed_parser_ (0),
  high_speed_parser_ (0),
  refpos_offset_parser_ (0)
{
}

reference_runType_pskel::
reference_runType_pskel (reference_runType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  reference_runType_impl_ (impl),
  ref_position_parser_ (0),
  max_distance_parser_ (0),
  timeout_parser_ (0),
  reverse_distance_parser_ (0),
  slow_speed_parser_ (0),
  high_speed_parser_ (0),
  refpos_offset_parser_ (0)
{
}

// encoderType_pskel
//

void encoderType_pskel::
type_parser (::xml_schema::byte_pskel& p)
{
  this->type_parser_ = &p;
}

void encoderType_pskel::
resolution_parser (::xml_schema::short_pskel& p)
{
  this->resolution_parser_ = &p;
}

void encoderType_pskel::
rotation_parser (::xml_schema::string_pskel& p)
{
  this->rotation_parser_ = &p;
}

void encoderType_pskel::
parsers (::xml_schema::byte_pskel& type,
         ::xml_schema::short_pskel& resolution,
         ::xml_schema::string_pskel& rotation)
{
  this->type_parser_ = &type;
  this->resolution_parser_ = &resolution;
  this->rotation_parser_ = &rotation;
}

encoderType_pskel::
encoderType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  encoderType_impl_ (0),
  type_parser_ (0),
  resolution_parser_ (0),
  rotation_parser_ (0)
{
}

encoderType_pskel::
encoderType_pskel (encoderType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  encoderType_impl_ (impl),
  type_parser_ (0),
  resolution_parser_ (0),
  rotation_parser_ (0)
{
}

// configurationType_pskel
//

void configurationType_pskel::
polarity_parser (::xml_schema::byte_pskel& p)
{
  this->polarity_parser_ = &p;
}

void configurationType_pskel::
sample_rate_parser (::xml_schema::byte_pskel& p)
{
  this->sample_rate_parser_ = &p;
}

void configurationType_pskel::
debounce_parser (::xml_schema::byte_pskel& p)
{
  this->debounce_parser_ = &p;
}

void configurationType_pskel::
temp_tolerance_parser (::xml_schema::byte_pskel& p)
{
  this->temp_tolerance_parser_ = &p;
}

void configurationType_pskel::
sampling_period_parser (::xml_schema::short_pskel& p)
{
  this->sampling_period_parser_ = &p;
}

void configurationType_pskel::
fan_speed_parser (::xml_schema::short_pskel& p)
{
  this->fan_speed_parser_ = &p;
}

void configurationType_pskel::
fan_threshold_parser (::xml_schema::short_pskel& p)
{
  this->fan_threshold_parser_ = &p;
}

void configurationType_pskel::
current_gain_parser (::xml_schema::short_pskel& p)
{
  this->current_gain_parser_ = &p;
}

void configurationType_pskel::
heater_current_parser (::xml_schema::short_pskel& p)
{
  this->heater_current_parser_ = &p;
}

void configurationType_pskel::
heater_threshold_parser (::xml_schema::short_pskel& p)
{
  this->heater_threshold_parser_ = &p;
}

void configurationType_pskel::
current_deviation_parser (::xml_schema::short_pskel& p)
{
  this->current_deviation_parser_ = &p;
}

void configurationType_pskel::
current_min_230_serial_parser (::xml_schema::short_pskel& p)
{
  this->current_min_230_serial_parser_ = &p;
}

void configurationType_pskel::
current_max_230_serial_parser (::xml_schema::short_pskel& p)
{
  this->current_max_230_serial_parser_ = &p;
}

void configurationType_pskel::
current_min_100_serial_parser (::xml_schema::short_pskel& p)
{
  this->current_min_100_serial_parser_ = &p;
}

void configurationType_pskel::
current_max_100_serial_parser (::xml_schema::short_pskel& p)
{
  this->current_max_100_serial_parser_ = &p;
}

void configurationType_pskel::
current_min_100_parallel_parser (::xml_schema::short_pskel& p)
{
  this->current_min_100_parallel_parser_ = &p;
}

void configurationType_pskel::
current_max_100_parallel_parser (::xml_schema::short_pskel& p)
{
  this->current_max_100_parallel_parser_ = &p;
}

void configurationType_pskel::
pressure_tolerance_parser (::xml_schema::byte_pskel& p)
{
  this->pressure_tolerance_parser_ = &p;
}

void configurationType_pskel::
fan_current_gain_parser (::xml_schema::byte_pskel& p)
{
  this->fan_current_gain_parser_ = &p;
}

void configurationType_pskel::
fan_current_parser (::xml_schema::short_pskel& p)
{
  this->fan_current_parser_ = &p;
}

void configurationType_pskel::
pump_current_parser (::xml_schema::short_pskel& p)
{
  this->pump_current_parser_ = &p;
}

void configurationType_pskel::
pump_threshold_parser (::xml_schema::short_pskel& p)
{
  this->pump_threshold_parser_ = &p;
}

void configurationType_pskel::
enabled_parser (::xml_schema::byte_pskel& p)
{
  this->enabled_parser_ = &p;
}

void configurationType_pskel::
inactiv_shutdown_parser (::xml_schema::byte_pskel& p)
{
  this->inactiv_shutdown_parser_ = &p;
}

void configurationType_pskel::
inactiv_emcy_parser (::xml_schema::byte_pskel& p)
{
  this->inactiv_emcy_parser_ = &p;
}

void configurationType_pskel::
outval_inactiv_parser (::xml_schema::byte_pskel& p)
{
  this->outval_inactiv_parser_ = &p;
}

void configurationType_pskel::
livetime_limit_parser (::xml_schema::byte_pskel& p)
{
  this->livetime_limit_parser_ = &p;
}

void configurationType_pskel::
timestamp_parser (::xml_schema::byte_pskel& p)
{
  this->timestamp_parser_ = &p;
}

void configurationType_pskel::
threshold_parser (::xml_schema::byte_pskel& p)
{
  this->threshold_parser_ = &p;
}

void configurationType_pskel::
interval_parser (::xml_schema::byte_pskel& p)
{
  this->interval_parser_ = &p;
}

void configurationType_pskel::
parsers (::xml_schema::byte_pskel& polarity,
         ::xml_schema::byte_pskel& sample_rate,
         ::xml_schema::byte_pskel& debounce,
         ::xml_schema::byte_pskel& temp_tolerance,
         ::xml_schema::short_pskel& sampling_period,
         ::xml_schema::short_pskel& fan_speed,
         ::xml_schema::short_pskel& fan_threshold,
         ::xml_schema::short_pskel& current_gain,
         ::xml_schema::short_pskel& heater_current,
         ::xml_schema::short_pskel& heater_threshold,
         ::xml_schema::short_pskel& current_deviation,
         ::xml_schema::short_pskel& current_min_230_serial,
         ::xml_schema::short_pskel& current_max_230_serial,
         ::xml_schema::short_pskel& current_min_100_serial,
         ::xml_schema::short_pskel& current_max_100_serial,
         ::xml_schema::short_pskel& current_min_100_parallel,
         ::xml_schema::short_pskel& current_max_100_parallel,
         ::xml_schema::byte_pskel& pressure_tolerance,
         ::xml_schema::byte_pskel& fan_current_gain,
         ::xml_schema::short_pskel& fan_current,
         ::xml_schema::short_pskel& pump_current,
         ::xml_schema::short_pskel& pump_threshold,
         ::xml_schema::byte_pskel& enabled,
         ::xml_schema::byte_pskel& inactiv_shutdown,
         ::xml_schema::byte_pskel& inactiv_emcy,
         ::xml_schema::byte_pskel& outval_inactiv,
         ::xml_schema::byte_pskel& livetime_limit,
         ::xml_schema::byte_pskel& timestamp,
         ::xml_schema::byte_pskel& threshold,
         ::xml_schema::byte_pskel& interval)
{
  this->polarity_parser_ = &polarity;
  this->sample_rate_parser_ = &sample_rate;
  this->debounce_parser_ = &debounce;
  this->temp_tolerance_parser_ = &temp_tolerance;
  this->sampling_period_parser_ = &sampling_period;
  this->fan_speed_parser_ = &fan_speed;
  this->fan_threshold_parser_ = &fan_threshold;
  this->current_gain_parser_ = &current_gain;
  this->heater_current_parser_ = &heater_current;
  this->heater_threshold_parser_ = &heater_threshold;
  this->current_deviation_parser_ = &current_deviation;
  this->current_min_230_serial_parser_ = &current_min_230_serial;
  this->current_max_230_serial_parser_ = &current_max_230_serial;
  this->current_min_100_serial_parser_ = &current_min_100_serial;
  this->current_max_100_serial_parser_ = &current_max_100_serial;
  this->current_min_100_parallel_parser_ = &current_min_100_parallel;
  this->current_max_100_parallel_parser_ = &current_max_100_parallel;
  this->pressure_tolerance_parser_ = &pressure_tolerance;
  this->fan_current_gain_parser_ = &fan_current_gain;
  this->fan_current_parser_ = &fan_current;
  this->pump_current_parser_ = &pump_current;
  this->pump_threshold_parser_ = &pump_threshold;
  this->enabled_parser_ = &enabled;
  this->inactiv_shutdown_parser_ = &inactiv_shutdown;
  this->inactiv_emcy_parser_ = &inactiv_emcy;
  this->outval_inactiv_parser_ = &outval_inactiv;
  this->livetime_limit_parser_ = &livetime_limit;
  this->timestamp_parser_ = &timestamp;
  this->threshold_parser_ = &threshold;
  this->interval_parser_ = &interval;
}

configurationType_pskel::
configurationType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  configurationType_impl_ (0),
  polarity_parser_ (0),
  sample_rate_parser_ (0),
  debounce_parser_ (0),
  temp_tolerance_parser_ (0),
  sampling_period_parser_ (0),
  fan_speed_parser_ (0),
  fan_threshold_parser_ (0),
  current_gain_parser_ (0),
  heater_current_parser_ (0),
  heater_threshold_parser_ (0),
  current_deviation_parser_ (0),
  current_min_230_serial_parser_ (0),
  current_max_230_serial_parser_ (0),
  current_min_100_serial_parser_ (0),
  current_max_100_serial_parser_ (0),
  current_min_100_parallel_parser_ (0),
  current_max_100_parallel_parser_ (0),
  pressure_tolerance_parser_ (0),
  fan_current_gain_parser_ (0),
  fan_current_parser_ (0),
  pump_current_parser_ (0),
  pump_threshold_parser_ (0),
  enabled_parser_ (0),
  inactiv_shutdown_parser_ (0),
  inactiv_emcy_parser_ (0),
  outval_inactiv_parser_ (0),
  livetime_limit_parser_ (0),
  timestamp_parser_ (0),
  threshold_parser_ (0),
  interval_parser_ (0)
{
}

configurationType_pskel::
configurationType_pskel (configurationType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  configurationType_impl_ (impl),
  polarity_parser_ (0),
  sample_rate_parser_ (0),
  debounce_parser_ (0),
  temp_tolerance_parser_ (0),
  sampling_period_parser_ (0),
  fan_speed_parser_ (0),
  fan_threshold_parser_ (0),
  current_gain_parser_ (0),
  heater_current_parser_ (0),
  heater_threshold_parser_ (0),
  current_deviation_parser_ (0),
  current_min_230_serial_parser_ (0),
  current_max_230_serial_parser_ (0),
  current_min_100_serial_parser_ (0),
  current_max_100_serial_parser_ (0),
  current_min_100_parallel_parser_ (0),
  current_max_100_parallel_parser_ (0),
  pressure_tolerance_parser_ (0),
  fan_current_gain_parser_ (0),
  fan_current_parser_ (0),
  pump_current_parser_ (0),
  pump_threshold_parser_ (0),
  enabled_parser_ (0),
  inactiv_shutdown_parser_ (0),
  inactiv_emcy_parser_ (0),
  outval_inactiv_parser_ (0),
  livetime_limit_parser_ (0),
  timestamp_parser_ (0),
  threshold_parser_ (0),
  interval_parser_ (0)
{
}

// limitswitchType_pskel
//

void limitswitchType_pskel::
index_parser (::xml_schema::byte_pskel& p)
{
  this->index_parser_ = &p;
}

void limitswitchType_pskel::
configuration_parser (::configurationType_pskel& p)
{
  this->configuration_parser_ = &p;
}

void limitswitchType_pskel::
parsers (::xml_schema::byte_pskel& index,
         ::configurationType_pskel& configuration)
{
  this->index_parser_ = &index;
  this->configuration_parser_ = &configuration;
}

limitswitchType_pskel::
limitswitchType_pskel ()
: limitswitchType_impl_ (0),
  index_parser_ (0),
  configuration_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

limitswitchType_pskel::
limitswitchType_pskel (limitswitchType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  limitswitchType_impl_ (impl),
  index_parser_ (0),
  configuration_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// position_codeType_pskel
//

void position_codeType_pskel::
value_parser (::xml_schema::byte_pskel& p)
{
  this->value_parser_ = &p;
}

void position_codeType_pskel::
stop_parser (::xml_schema::byte_pskel& p)
{
  this->stop_parser_ = &p;
}

void position_codeType_pskel::
stop_dir_parser (::xml_schema::string_pskel& p)
{
  this->stop_dir_parser_ = &p;
}

void position_codeType_pskel::
position_parser (::xml_schema::byte_pskel& p)
{
  this->position_parser_ = &p;
}

void position_codeType_pskel::
width_parser (::xml_schema::byte_pskel& p)
{
  this->width_parser_ = &p;
}

void position_codeType_pskel::
deviation_parser (::xml_schema::byte_pskel& p)
{
  this->deviation_parser_ = &p;
}

void position_codeType_pskel::
dir_check_parser (::xml_schema::byte_pskel& p)
{
  this->dir_check_parser_ = &p;
}

void position_codeType_pskel::
hit_skip_parser (::xml_schema::byte_pskel& p)
{
  this->hit_skip_parser_ = &p;
}

void position_codeType_pskel::
parsers (::xml_schema::byte_pskel& value,
         ::xml_schema::byte_pskel& stop,
         ::xml_schema::string_pskel& stop_dir,
         ::xml_schema::byte_pskel& position,
         ::xml_schema::byte_pskel& width,
         ::xml_schema::byte_pskel& deviation,
         ::xml_schema::byte_pskel& dir_check,
         ::xml_schema::byte_pskel& hit_skip)
{
  this->value_parser_ = &value;
  this->stop_parser_ = &stop;
  this->stop_dir_parser_ = &stop_dir;
  this->position_parser_ = &position;
  this->width_parser_ = &width;
  this->deviation_parser_ = &deviation;
  this->dir_check_parser_ = &dir_check;
  this->hit_skip_parser_ = &hit_skip;
}

position_codeType_pskel::
position_codeType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  position_codeType_impl_ (0),
  value_parser_ (0),
  stop_parser_ (0),
  stop_dir_parser_ (0),
  position_parser_ (0),
  width_parser_ (0),
  deviation_parser_ (0),
  dir_check_parser_ (0),
  hit_skip_parser_ (0)
{
}

position_codeType_pskel::
position_codeType_pskel (position_codeType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  position_codeType_impl_ (impl),
  value_parser_ (0),
  stop_parser_ (0),
  stop_dir_parser_ (0),
  position_parser_ (0),
  width_parser_ (0),
  deviation_parser_ (0),
  dir_check_parser_ (0),
  hit_skip_parser_ (0)
{
}

// limitswitchesType_pskel
//

void limitswitchesType_pskel::
limitswitch_parser (::limitswitchType_pskel& p)
{
  this->limitswitch_parser_ = &p;
}

void limitswitchesType_pskel::
position_code_parser (::position_codeType_pskel& p)
{
  this->position_code_parser_ = &p;
}

void limitswitchesType_pskel::
parsers (::limitswitchType_pskel& limitswitch,
         ::position_codeType_pskel& position_code)
{
  this->limitswitch_parser_ = &limitswitch;
  this->position_code_parser_ = &position_code;
}

limitswitchesType_pskel::
limitswitchesType_pskel ()
: limitswitchesType_impl_ (0),
  limitswitch_parser_ (0),
  position_code_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

limitswitchesType_pskel::
limitswitchesType_pskel (limitswitchesType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  limitswitchesType_impl_ (impl),
  limitswitch_parser_ (0),
  position_code_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// position_coverageType_pskel
//

void position_coverageType_pskel::
encoder_parser (::encoderType_pskel& p)
{
  this->encoder_parser_ = &p;
}

void position_coverageType_pskel::
limitswitches_parser (::limitswitchesType_pskel& p)
{
  this->limitswitches_parser_ = &p;
}

void position_coverageType_pskel::
parsers (::encoderType_pskel& encoder,
         ::limitswitchesType_pskel& limitswitches)
{
  this->encoder_parser_ = &encoder;
  this->limitswitches_parser_ = &limitswitches;
}

position_coverageType_pskel::
position_coverageType_pskel ()
: position_coverageType_impl_ (0),
  encoder_parser_ (0),
  limitswitches_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

position_coverageType_pskel::
position_coverageType_pskel (position_coverageType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  position_coverageType_impl_ (impl),
  encoder_parser_ (0),
  limitswitches_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// supervisionType_pskel
//

void supervisionType_pskel::
steploss_warn_limit_parser (::xml_schema::byte_pskel& p)
{
  this->steploss_warn_limit_parser_ = &p;
}

void supervisionType_pskel::
steploss_error_limit_parser (::xml_schema::byte_pskel& p)
{
  this->steploss_error_limit_parser_ = &p;
}

void supervisionType_pskel::
current_limit_parser (::xml_schema::short_pskel& p)
{
  this->current_limit_parser_ = &p;
}

void supervisionType_pskel::
parsers (::xml_schema::byte_pskel& steploss_warn_limit,
         ::xml_schema::byte_pskel& steploss_error_limit,
         ::xml_schema::short_pskel& current_limit)
{
  this->steploss_warn_limit_parser_ = &steploss_warn_limit;
  this->steploss_error_limit_parser_ = &steploss_error_limit;
  this->current_limit_parser_ = &current_limit;
}

supervisionType_pskel::
supervisionType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  supervisionType_impl_ (0),
  steploss_warn_limit_parser_ (0),
  steploss_error_limit_parser_ (0),
  current_limit_parser_ (0)
{
}

supervisionType_pskel::
supervisionType_pskel (supervisionType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  supervisionType_impl_ (impl),
  steploss_warn_limit_parser_ (0),
  steploss_error_limit_parser_ (0),
  current_limit_parser_ (0)
{
}

// driverType_pskel
//

void driverType_pskel::
type_parser (::xml_schema::string_pskel& p)
{
  this->type_parser_ = &p;
}

void driverType_pskel::
reg_chopConf_parser (::xml_schema::string_pskel& p)
{
  this->reg_chopConf_parser_ = &p;
}

void driverType_pskel::
reg_smartEn_parser (::xml_schema::string_pskel& p)
{
  this->reg_smartEn_parser_ = &p;
}

void driverType_pskel::
reg_sgcsConf_parser (::xml_schema::string_pskel& p)
{
  this->reg_sgcsConf_parser_ = &p;
}

void driverType_pskel::
reg_drvConf_parser (::xml_schema::string_pskel& p)
{
  this->reg_drvConf_parser_ = &p;
}

void driverType_pskel::
parsers (::xml_schema::string_pskel& type,
         ::xml_schema::string_pskel& reg_chopConf,
         ::xml_schema::string_pskel& reg_smartEn,
         ::xml_schema::string_pskel& reg_sgcsConf,
         ::xml_schema::string_pskel& reg_drvConf)
{
  this->type_parser_ = &type;
  this->reg_chopConf_parser_ = &reg_chopConf;
  this->reg_smartEn_parser_ = &reg_smartEn;
  this->reg_sgcsConf_parser_ = &reg_sgcsConf;
  this->reg_drvConf_parser_ = &reg_drvConf;
}

driverType_pskel::
driverType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  driverType_impl_ (0),
  type_parser_ (0),
  reg_chopConf_parser_ (0),
  reg_smartEn_parser_ (0),
  reg_sgcsConf_parser_ (0),
  reg_drvConf_parser_ (0)
{
}

driverType_pskel::
driverType_pskel (driverType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  driverType_impl_ (impl),
  type_parser_ (0),
  reg_chopConf_parser_ (0),
  reg_smartEn_parser_ (0),
  reg_sgcsConf_parser_ (0),
  reg_drvConf_parser_ (0)
{
}

// motion_profileType_pskel
//

void motion_profileType_pskel::
speed_min_parser (::xml_schema::byte_pskel& p)
{
  this->speed_min_parser_ = &p;
}

void motion_profileType_pskel::
speed_max_parser (::xml_schema::short_pskel& p)
{
  this->speed_max_parser_ = &p;
}

void motion_profileType_pskel::
acc_parser (::xml_schema::short_pskel& p)
{
  this->acc_parser_ = &p;
}

void motion_profileType_pskel::
dec_parser (::xml_schema::short_pskel& p)
{
  this->dec_parser_ = &p;
}

void motion_profileType_pskel::
acc_time_parser (::xml_schema::byte_pskel& p)
{
  this->acc_time_parser_ = &p;
}

void motion_profileType_pskel::
dec_time_parser (::xml_schema::byte_pskel& p)
{
  this->dec_time_parser_ = &p;
}

void motion_profileType_pskel::
micro_steps_parser (::xml_schema::byte_pskel& p)
{
  this->micro_steps_parser_ = &p;
}

void motion_profileType_pskel::
ramp_type_parser (::xml_schema::byte_pskel& p)
{
  this->ramp_type_parser_ = &p;
}

void motion_profileType_pskel::
parsers (::xml_schema::byte_pskel& speed_min,
         ::xml_schema::short_pskel& speed_max,
         ::xml_schema::short_pskel& acc,
         ::xml_schema::short_pskel& dec,
         ::xml_schema::byte_pskel& acc_time,
         ::xml_schema::byte_pskel& dec_time,
         ::xml_schema::byte_pskel& micro_steps,
         ::xml_schema::byte_pskel& ramp_type)
{
  this->speed_min_parser_ = &speed_min;
  this->speed_max_parser_ = &speed_max;
  this->acc_parser_ = &acc;
  this->dec_parser_ = &dec;
  this->acc_time_parser_ = &acc_time;
  this->dec_time_parser_ = &dec_time;
  this->micro_steps_parser_ = &micro_steps;
  this->ramp_type_parser_ = &ramp_type;
}

motion_profileType_pskel::
motion_profileType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  motion_profileType_impl_ (0),
  speed_min_parser_ (0),
  speed_max_parser_ (0),
  acc_parser_ (0),
  dec_parser_ (0),
  acc_time_parser_ (0),
  dec_time_parser_ (0),
  micro_steps_parser_ (0),
  ramp_type_parser_ (0)
{
}

motion_profileType_pskel::
motion_profileType_pskel (motion_profileType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  motion_profileType_impl_ (impl),
  speed_min_parser_ (0),
  speed_max_parser_ (0),
  acc_parser_ (0),
  dec_parser_ (0),
  acc_time_parser_ (0),
  dec_time_parser_ (0),
  micro_steps_parser_ (0),
  ramp_type_parser_ (0)
{
}

// motion_profilesType_pskel
//

void motion_profilesType_pskel::
motion_profile_parser (::motion_profileType_pskel& p)
{
  this->motion_profile_parser_ = &p;
}

void motion_profilesType_pskel::
parsers (::motion_profileType_pskel& motion_profile)
{
  this->motion_profile_parser_ = &motion_profile;
}

motion_profilesType_pskel::
motion_profilesType_pskel ()
: motion_profilesType_impl_ (0),
  motion_profile_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

motion_profilesType_pskel::
motion_profilesType_pskel (motion_profilesType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  motion_profilesType_impl_ (impl),
  motion_profile_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// pid_controllerType_pskel
//

void pid_controllerType_pskel::
max_temperature_parser (::xml_schema::short_pskel& p)
{
  this->max_temperature_parser_ = &p;
}

void pid_controllerType_pskel::
controller_gain_parser (::xml_schema::short_pskel& p)
{
  this->controller_gain_parser_ = &p;
}

void pid_controllerType_pskel::
reset_time_parser (::xml_schema::short_pskel& p)
{
  this->reset_time_parser_ = &p;
}

void pid_controllerType_pskel::
derivative_time_parser (::xml_schema::byte_pskel& p)
{
  this->derivative_time_parser_ = &p;
}

void pid_controllerType_pskel::
max_pressure_parser (::xml_schema::byte_pskel& p)
{
  this->max_pressure_parser_ = &p;
}

void pid_controllerType_pskel::
min_pressure_parser (::xml_schema::byte_pskel& p)
{
  this->min_pressure_parser_ = &p;
}

void pid_controllerType_pskel::
parsers (::xml_schema::short_pskel& max_temperature,
         ::xml_schema::short_pskel& controller_gain,
         ::xml_schema::short_pskel& reset_time,
         ::xml_schema::byte_pskel& derivative_time,
         ::xml_schema::byte_pskel& max_pressure,
         ::xml_schema::byte_pskel& min_pressure)
{
  this->max_temperature_parser_ = &max_temperature;
  this->controller_gain_parser_ = &controller_gain;
  this->reset_time_parser_ = &reset_time;
  this->derivative_time_parser_ = &derivative_time;
  this->max_pressure_parser_ = &max_pressure;
  this->min_pressure_parser_ = &min_pressure;
}

pid_controllerType_pskel::
pid_controllerType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  pid_controllerType_impl_ (0),
  max_temperature_parser_ (0),
  controller_gain_parser_ (0),
  reset_time_parser_ (0),
  derivative_time_parser_ (0),
  max_pressure_parser_ (0),
  min_pressure_parser_ (0)
{
}

pid_controllerType_pskel::
pid_controllerType_pskel (pid_controllerType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  pid_controllerType_impl_ (impl),
  max_temperature_parser_ (0),
  controller_gain_parser_ (0),
  reset_time_parser_ (0),
  derivative_time_parser_ (0),
  max_pressure_parser_ (0),
  min_pressure_parser_ (0)
{
}

// pid_controllersType_pskel
//

void pid_controllersType_pskel::
pid_controller_parser (::pid_controllerType_pskel& p)
{
  this->pid_controller_parser_ = &p;
}

void pid_controllersType_pskel::
parsers (::pid_controllerType_pskel& pid_controller)
{
  this->pid_controller_parser_ = &pid_controller;
}

pid_controllersType_pskel::
pid_controllersType_pskel ()
: pid_controllersType_impl_ (0),
  pid_controller_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

pid_controllersType_pskel::
pid_controllersType_pskel (pid_controllersType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  pid_controllersType_impl_ (impl),
  pid_controller_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// pwm_controllerType_pskel
//

void pwm_controllerType_pskel::
max_actuating_value_parser (::xml_schema::short_pskel& p)
{
  this->max_actuating_value_parser_ = &p;
}

void pwm_controllerType_pskel::
min_actuating_value_parser (::xml_schema::short_pskel& p)
{
  this->min_actuating_value_parser_ = &p;
}

void pwm_controllerType_pskel::
max_pwm_duty_parser (::xml_schema::byte_pskel& p)
{
  this->max_pwm_duty_parser_ = &p;
}

void pwm_controllerType_pskel::
min_pwm_duty_parser (::xml_schema::byte_pskel& p)
{
  this->min_pwm_duty_parser_ = &p;
}

void pwm_controllerType_pskel::
parsers (::xml_schema::short_pskel& max_actuating_value,
         ::xml_schema::short_pskel& min_actuating_value,
         ::xml_schema::byte_pskel& max_pwm_duty,
         ::xml_schema::byte_pskel& min_pwm_duty)
{
  this->max_actuating_value_parser_ = &max_actuating_value;
  this->min_actuating_value_parser_ = &min_actuating_value;
  this->max_pwm_duty_parser_ = &max_pwm_duty;
  this->min_pwm_duty_parser_ = &min_pwm_duty;
}

pwm_controllerType_pskel::
pwm_controllerType_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  pwm_controllerType_impl_ (0),
  max_actuating_value_parser_ (0),
  min_actuating_value_parser_ (0),
  max_pwm_duty_parser_ (0),
  min_pwm_duty_parser_ (0)
{
}

pwm_controllerType_pskel::
pwm_controllerType_pskel (pwm_controllerType_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  pwm_controllerType_impl_ (impl),
  max_actuating_value_parser_ (0),
  min_actuating_value_parser_ (0),
  max_pwm_duty_parser_ (0),
  min_pwm_duty_parser_ (0)
{
}

// functionmoduleType_pskel
//

void functionmoduleType_pskel::
type_parser (::xml_schema::string_pskel& p)
{
  this->type_parser_ = &p;
}

void functionmoduleType_pskel::
key_parser (::xml_schema::string_pskel& p)
{
  this->key_parser_ = &p;
}

void functionmoduleType_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void functionmoduleType_pskel::
interface_parser (::xml_schema::byte_pskel& p)
{
  this->interface_parser_ = &p;
}

void functionmoduleType_pskel::
fct_instanceID_parser (::xml_schema::string_pskel& p)
{
  this->fct_instanceID_parser_ = &p;
}

void functionmoduleType_pskel::
rotation_parser (::rotationType_pskel& p)
{
  this->rotation_parser_ = &p;
}

void functionmoduleType_pskel::
reference_run_parser (::reference_runType_pskel& p)
{
  this->reference_run_parser_ = &p;
}

void functionmoduleType_pskel::
position_coverage_parser (::position_coverageType_pskel& p)
{
  this->position_coverage_parser_ = &p;
}

void functionmoduleType_pskel::
supervision_parser (::supervisionType_pskel& p)
{
  this->supervision_parser_ = &p;
}

void functionmoduleType_pskel::
driver_parser (::driverType_pskel& p)
{
  this->driver_parser_ = &p;
}

void functionmoduleType_pskel::
motion_profiles_parser (::motion_profilesType_pskel& p)
{
  this->motion_profiles_parser_ = &p;
}

void functionmoduleType_pskel::
configuration_parser (::configurationType_pskel& p)
{
  this->configuration_parser_ = &p;
}

void functionmoduleType_pskel::
pid_controllers_parser (::pid_controllersType_pskel& p)
{
  this->pid_controllers_parser_ = &p;
}

void functionmoduleType_pskel::
pwm_controller_parser (::pwm_controllerType_pskel& p)
{
  this->pwm_controller_parser_ = &p;
}

void functionmoduleType_pskel::
parsers (::xml_schema::string_pskel& type,
         ::xml_schema::string_pskel& key,
         ::xml_schema::string_pskel& name,
         ::xml_schema::byte_pskel& interface,
         ::xml_schema::string_pskel& fct_instanceID,
         ::rotationType_pskel& rotation,
         ::reference_runType_pskel& reference_run,
         ::position_coverageType_pskel& position_coverage,
         ::supervisionType_pskel& supervision,
         ::driverType_pskel& driver,
         ::motion_profilesType_pskel& motion_profiles,
         ::configurationType_pskel& configuration,
         ::pid_controllersType_pskel& pid_controllers,
         ::pwm_controllerType_pskel& pwm_controller)
{
  this->type_parser_ = &type;
  this->key_parser_ = &key;
  this->name_parser_ = &name;
  this->interface_parser_ = &interface;
  this->fct_instanceID_parser_ = &fct_instanceID;
  this->rotation_parser_ = &rotation;
  this->reference_run_parser_ = &reference_run;
  this->position_coverage_parser_ = &position_coverage;
  this->supervision_parser_ = &supervision;
  this->driver_parser_ = &driver;
  this->motion_profiles_parser_ = &motion_profiles;
  this->configuration_parser_ = &configuration;
  this->pid_controllers_parser_ = &pid_controllers;
  this->pwm_controller_parser_ = &pwm_controller;
}

functionmoduleType_pskel::
functionmoduleType_pskel ()
: functionmoduleType_impl_ (0),
  type_parser_ (0),
  key_parser_ (0),
  name_parser_ (0),
  interface_parser_ (0),
  fct_instanceID_parser_ (0),
  rotation_parser_ (0),
  reference_run_parser_ (0),
  position_coverage_parser_ (0),
  supervision_parser_ (0),
  driver_parser_ (0),
  motion_profiles_parser_ (0),
  configuration_parser_ (0),
  pid_controllers_parser_ (0),
  pwm_controller_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

functionmoduleType_pskel::
functionmoduleType_pskel (functionmoduleType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  functionmoduleType_impl_ (impl),
  type_parser_ (0),
  key_parser_ (0),
  name_parser_ (0),
  interface_parser_ (0),
  fct_instanceID_parser_ (0),
  rotation_parser_ (0),
  reference_run_parser_ (0),
  position_coverage_parser_ (0),
  supervision_parser_ (0),
  driver_parser_ (0),
  motion_profiles_parser_ (0),
  configuration_parser_ (0),
  pid_controllers_parser_ (0),
  pwm_controller_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// functionmodulesType_pskel
//

void functionmodulesType_pskel::
functionmodule_parser (::functionmoduleType_pskel& p)
{
  this->functionmodule_parser_ = &p;
}

void functionmodulesType_pskel::
parsers (::functionmoduleType_pskel& functionmodule)
{
  this->functionmodule_parser_ = &functionmodule;
}

functionmodulesType_pskel::
functionmodulesType_pskel ()
: functionmodulesType_impl_ (0),
  functionmodule_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

functionmodulesType_pskel::
functionmodulesType_pskel (functionmodulesType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  functionmodulesType_impl_ (impl),
  functionmodule_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// slaveType_pskel
//

void slaveType_pskel::
type_parser (::xml_schema::string_pskel& p)
{
  this->type_parser_ = &p;
}

void slaveType_pskel::
key_parser (::xml_schema::string_pskel& p)
{
  this->key_parser_ = &p;
}

void slaveType_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void slaveType_pskel::
virtual__parser (::xml_schema::byte_pskel& p)
{
  this->virtual__parser_ = &p;
}

void slaveType_pskel::
nodetype_parser (::xml_schema::byte_pskel& p)
{
  this->nodetype_parser_ = &p;
}

void slaveType_pskel::
nodeindex_parser (::xml_schema::byte_pskel& p)
{
  this->nodeindex_parser_ = &p;
}

void slaveType_pskel::
functionmodules_parser (::functionmodulesType_pskel& p)
{
  this->functionmodules_parser_ = &p;
}

void slaveType_pskel::
parsers (::xml_schema::string_pskel& type,
         ::xml_schema::string_pskel& key,
         ::xml_schema::string_pskel& name,
         ::xml_schema::byte_pskel& virtual_,
         ::xml_schema::byte_pskel& nodetype,
         ::xml_schema::byte_pskel& nodeindex,
         ::functionmodulesType_pskel& functionmodules)
{
  this->type_parser_ = &type;
  this->key_parser_ = &key;
  this->name_parser_ = &name;
  this->virtual__parser_ = &virtual_;
  this->nodetype_parser_ = &nodetype;
  this->nodeindex_parser_ = &nodeindex;
  this->functionmodules_parser_ = &functionmodules;
}

slaveType_pskel::
slaveType_pskel ()
: slaveType_impl_ (0),
  type_parser_ (0),
  key_parser_ (0),
  name_parser_ (0),
  virtual__parser_ (0),
  nodetype_parser_ (0),
  nodeindex_parser_ (0),
  functionmodules_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

slaveType_pskel::
slaveType_pskel (slaveType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  slaveType_impl_ (impl),
  type_parser_ (0),
  key_parser_ (0),
  name_parser_ (0),
  virtual__parser_ (0),
  nodetype_parser_ (0),
  nodeindex_parser_ (0),
  functionmodules_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// parameter_slavesType_pskel
//

void parameter_slavesType_pskel::
slave_parser (::slaveType_pskel& p)
{
  this->slave_parser_ = &p;
}

void parameter_slavesType_pskel::
parsers (::slaveType_pskel& slave)
{
  this->slave_parser_ = &slave;
}

parameter_slavesType_pskel::
parameter_slavesType_pskel ()
: parameter_slavesType_impl_ (0),
  slave_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

parameter_slavesType_pskel::
parameter_slavesType_pskel (parameter_slavesType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  parameter_slavesType_impl_ (impl),
  slave_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// hwconfigType_pskel
//

void hwconfigType_pskel::
version_parser (::xml_schema::float_pskel& p)
{
  this->version_parser_ = &p;
}

void hwconfigType_pskel::
parameter_master_parser (::parameter_masterType_pskel& p)
{
  this->parameter_master_parser_ = &p;
}

void hwconfigType_pskel::
parameter_slaves_parser (::parameter_slavesType_pskel& p)
{
  this->parameter_slaves_parser_ = &p;
}

void hwconfigType_pskel::
devices_parser (::devicesType_pskel& p)
{
  this->devices_parser_ = &p;
}

void hwconfigType_pskel::
parsers (::xml_schema::float_pskel& version,
         ::parameter_masterType_pskel& parameter_master,
         ::parameter_slavesType_pskel& parameter_slaves,
         ::devicesType_pskel& devices)
{
  this->version_parser_ = &version;
  this->parameter_master_parser_ = &parameter_master;
  this->parameter_slaves_parser_ = &parameter_slaves;
  this->devices_parser_ = &devices;
}

hwconfigType_pskel::
hwconfigType_pskel ()
: hwconfigType_impl_ (0),
  version_parser_ (0),
  parameter_master_parser_ (0),
  parameter_slaves_parser_ (0),
  devices_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

hwconfigType_pskel::
hwconfigType_pskel (hwconfigType_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  hwconfigType_impl_ (impl),
  version_parser_ (0),
  parameter_master_parser_ (0),
  parameter_slaves_parser_ (0),
  devices_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

#include <assert.h>

// can_interfaceType_pskel
//

void can_interfaceType_pskel::
interface (const ::std::string& x)
{
  if (this->can_interfaceType_impl_)
    this->can_interfaceType_impl_->interface (x);
}

void can_interfaceType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->interface_parser_)
    this->interface_parser_->_reset ();
}

::std::string can_interfaceType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// tcp_interfaceType_pskel
//

void tcp_interfaceType_pskel::
usage (signed char x)
{
  if (this->tcp_interfaceType_impl_)
    this->tcp_interfaceType_impl_->usage (x);
}

void tcp_interfaceType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->usage_parser_)
    this->usage_parser_->_reset ();
}

::std::string tcp_interfaceType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// serial_numberType_pskel
//

void serial_numberType_pskel::
serialno (const ::std::string& x)
{
  if (this->serial_numberType_impl_)
    this->serial_numberType_impl_->serialno (x);
}

void serial_numberType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->serialno_parser_)
    this->serialno_parser_->_reset ();
}

::std::string serial_numberType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// deviceType_pskel
//

void deviceType_pskel::
name (const ::std::string& x)
{
  if (this->deviceType_impl_)
    this->deviceType_impl_->name (x);
}

void deviceType_pskel::
id (const ::std::string& x)
{
  if (this->deviceType_impl_)
    this->deviceType_impl_->id (x);
}

void deviceType_pskel::
type (const ::std::string& x)
{
  if (this->deviceType_impl_)
    this->deviceType_impl_->type (x);
}

void deviceType_pskel::
dev_instanceID (const ::std::string& x)
{
  if (this->deviceType_impl_)
    this->deviceType_impl_->dev_instanceID (x);
}

void deviceType_pskel::
optional (signed char x)
{
  if (this->deviceType_impl_)
    this->deviceType_impl_->optional (x);
}

void deviceType_pskel::
functionmodules (::functionmodulesType* x)
{
  if (this->deviceType_impl_)
    this->deviceType_impl_->functionmodules (x);
}

void deviceType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->type_parser_)
    this->type_parser_->_reset ();

  if (this->dev_instanceID_parser_)
    this->dev_instanceID_parser_->_reset ();

  if (this->optional_parser_)
    this->optional_parser_->_reset ();

  this->resetting_ = true;

  if (this->functionmodules_parser_)
    this->functionmodules_parser_->_reset ();

  this->resetting_ = false;
}

// devicesType_pskel
//

void devicesType_pskel::
device (::deviceType* x)
{
  if (this->devicesType_impl_)
    this->devicesType_impl_->device (x);
}

void devicesType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->device_parser_)
    this->device_parser_->_reset ();

  this->resetting_ = false;
}

// retortType_pskel
//

void retortType_pskel::
name (const ::std::string& x)
{
  if (this->retortType_impl_)
    this->retortType_impl_->name (x);
}

void retortType_pskel::
index (signed char x)
{
  if (this->retortType_impl_)
    this->retortType_impl_->index (x);
}

void retortType_pskel::
devices (::devicesType* x)
{
  if (this->retortType_impl_)
    this->retortType_impl_->devices (x);
}

void retortType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->index_parser_)
    this->index_parser_->_reset ();

  this->resetting_ = true;

  if (this->devices_parser_)
    this->devices_parser_->_reset ();

  this->resetting_ = false;
}

// retortsType_pskel
//

void retortsType_pskel::
retort (::retortType* x)
{
  if (this->retortsType_impl_)
    this->retortsType_impl_->retort (x);
}

void retortsType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->retort_parser_)
    this->retort_parser_->_reset ();

  this->resetting_ = false;
}

// parameter_masterType_pskel
//

void parameter_masterType_pskel::
folded (const ::std::string& x)
{
  if (this->parameter_masterType_impl_)
    this->parameter_masterType_impl_->folded (x);
}

void parameter_masterType_pskel::
can_interface (const ::can_interfaceType& x)
{
  if (this->parameter_masterType_impl_)
    this->parameter_masterType_impl_->can_interface (x);
}

void parameter_masterType_pskel::
tcp_interface (const ::tcp_interfaceType& x)
{
  if (this->parameter_masterType_impl_)
    this->parameter_masterType_impl_->tcp_interface (x);
}

void parameter_masterType_pskel::
nodetype (signed char x)
{
  if (this->parameter_masterType_impl_)
    this->parameter_masterType_impl_->nodetype (x);
}

void parameter_masterType_pskel::
nodeindex (signed char x)
{
  if (this->parameter_masterType_impl_)
    this->parameter_masterType_impl_->nodeindex (x);
}

void parameter_masterType_pskel::
serial_number (const ::serial_numberType& x)
{
  if (this->parameter_masterType_impl_)
    this->parameter_masterType_impl_->serial_number (x);
}

void parameter_masterType_pskel::
retorts (::retortsType* x)
{
  if (this->parameter_masterType_impl_)
    this->parameter_masterType_impl_->retorts (x);
}

void parameter_masterType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->folded_parser_)
    this->folded_parser_->_reset ();

  this->resetting_ = true;

  if (this->can_interface_parser_)
    this->can_interface_parser_->_reset ();

  if (this->tcp_interface_parser_)
    this->tcp_interface_parser_->_reset ();

  if (this->nodetype_parser_)
    this->nodetype_parser_->_reset ();

  if (this->nodeindex_parser_)
    this->nodeindex_parser_->_reset ();

  if (this->serial_number_parser_)
    this->serial_number_parser_->_reset ();

  if (this->retorts_parser_)
    this->retorts_parser_->_reset ();

  this->resetting_ = false;
}

// rotationType_pskel
//

void rotationType_pskel::
type (const ::std::string& x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->type (x);
}

void rotationType_pskel::
direction (const ::std::string& x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->direction (x);
}

void rotationType_pskel::
steps_revolution (short x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->steps_revolution (x);
}

void rotationType_pskel::
position_min (short x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->position_min (x);
}

void rotationType_pskel::
position_max (short x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->position_max (x);
}

void rotationType_pskel::
speed_min (signed char x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->speed_min (x);
}

void rotationType_pskel::
speed_max (short x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->speed_max (x);
}

void rotationType_pskel::
run_cs (signed char x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->run_cs (x);
}

void rotationType_pskel::
stop_cs (signed char x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->stop_cs (x);
}

void rotationType_pskel::
stop_cs_delay (short x)
{
  if (this->rotationType_impl_)
    this->rotationType_impl_->stop_cs_delay (x);
}

void rotationType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->type_parser_)
    this->type_parser_->_reset ();

  if (this->direction_parser_)
    this->direction_parser_->_reset ();

  if (this->steps_revolution_parser_)
    this->steps_revolution_parser_->_reset ();

  if (this->position_min_parser_)
    this->position_min_parser_->_reset ();

  if (this->position_max_parser_)
    this->position_max_parser_->_reset ();

  if (this->speed_min_parser_)
    this->speed_min_parser_->_reset ();

  if (this->speed_max_parser_)
    this->speed_max_parser_->_reset ();

  if (this->run_cs_parser_)
    this->run_cs_parser_->_reset ();

  if (this->stop_cs_parser_)
    this->stop_cs_parser_->_reset ();

  if (this->stop_cs_delay_parser_)
    this->stop_cs_delay_parser_->_reset ();
}

::std::string rotationType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// reference_runType_pskel
//

void reference_runType_pskel::
ref_position (signed char x)
{
  if (this->reference_runType_impl_)
    this->reference_runType_impl_->ref_position (x);
}

void reference_runType_pskel::
max_distance (short x)
{
  if (this->reference_runType_impl_)
    this->reference_runType_impl_->max_distance (x);
}

void reference_runType_pskel::
timeout (int x)
{
  if (this->reference_runType_impl_)
    this->reference_runType_impl_->timeout (x);
}

void reference_runType_pskel::
reverse_distance (signed char x)
{
  if (this->reference_runType_impl_)
    this->reference_runType_impl_->reverse_distance (x);
}

void reference_runType_pskel::
slow_speed (signed char x)
{
  if (this->reference_runType_impl_)
    this->reference_runType_impl_->slow_speed (x);
}

void reference_runType_pskel::
high_speed (short x)
{
  if (this->reference_runType_impl_)
    this->reference_runType_impl_->high_speed (x);
}

void reference_runType_pskel::
refpos_offset (signed char x)
{
  if (this->reference_runType_impl_)
    this->reference_runType_impl_->refpos_offset (x);
}

void reference_runType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->ref_position_parser_)
    this->ref_position_parser_->_reset ();

  if (this->max_distance_parser_)
    this->max_distance_parser_->_reset ();

  if (this->timeout_parser_)
    this->timeout_parser_->_reset ();

  if (this->reverse_distance_parser_)
    this->reverse_distance_parser_->_reset ();

  if (this->slow_speed_parser_)
    this->slow_speed_parser_->_reset ();

  if (this->high_speed_parser_)
    this->high_speed_parser_->_reset ();

  if (this->refpos_offset_parser_)
    this->refpos_offset_parser_->_reset ();
}

::std::string reference_runType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// encoderType_pskel
//

void encoderType_pskel::
type (signed char x)
{
  if (this->encoderType_impl_)
    this->encoderType_impl_->type (x);
}

void encoderType_pskel::
resolution (short x)
{
  if (this->encoderType_impl_)
    this->encoderType_impl_->resolution (x);
}

void encoderType_pskel::
rotation (const ::std::string& x)
{
  if (this->encoderType_impl_)
    this->encoderType_impl_->rotation (x);
}

void encoderType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->type_parser_)
    this->type_parser_->_reset ();

  if (this->resolution_parser_)
    this->resolution_parser_->_reset ();

  if (this->rotation_parser_)
    this->rotation_parser_->_reset ();
}

::std::string encoderType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// configurationType_pskel
//

void configurationType_pskel::
polarity (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->polarity (x);
}

void configurationType_pskel::
sample_rate (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->sample_rate (x);
}

void configurationType_pskel::
debounce (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->debounce (x);
}

void configurationType_pskel::
temp_tolerance (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->temp_tolerance (x);
}

void configurationType_pskel::
sampling_period (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->sampling_period (x);
}

void configurationType_pskel::
fan_speed (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->fan_speed (x);
}

void configurationType_pskel::
fan_threshold (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->fan_threshold (x);
}

void configurationType_pskel::
current_gain (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->current_gain (x);
}

void configurationType_pskel::
heater_current (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->heater_current (x);
}

void configurationType_pskel::
heater_threshold (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->heater_threshold (x);
}

void configurationType_pskel::
current_deviation (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->current_deviation (x);
}

void configurationType_pskel::
current_min_230_serial (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->current_min_230_serial (x);
}

void configurationType_pskel::
current_max_230_serial (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->current_max_230_serial (x);
}

void configurationType_pskel::
current_min_100_serial (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->current_min_100_serial (x);
}

void configurationType_pskel::
current_max_100_serial (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->current_max_100_serial (x);
}

void configurationType_pskel::
current_min_100_parallel (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->current_min_100_parallel (x);
}

void configurationType_pskel::
current_max_100_parallel (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->current_max_100_parallel (x);
}

void configurationType_pskel::
pressure_tolerance (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->pressure_tolerance (x);
}

void configurationType_pskel::
fan_current_gain (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->fan_current_gain (x);
}

void configurationType_pskel::
fan_current (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->fan_current (x);
}

void configurationType_pskel::
pump_current (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->pump_current (x);
}

void configurationType_pskel::
pump_threshold (short x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->pump_threshold (x);
}

void configurationType_pskel::
enabled (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->enabled (x);
}

void configurationType_pskel::
inactiv_shutdown (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->inactiv_shutdown (x);
}

void configurationType_pskel::
inactiv_emcy (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->inactiv_emcy (x);
}

void configurationType_pskel::
outval_inactiv (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->outval_inactiv (x);
}

void configurationType_pskel::
livetime_limit (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->livetime_limit (x);
}

void configurationType_pskel::
timestamp (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->timestamp (x);
}

void configurationType_pskel::
threshold (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->threshold (x);
}

void configurationType_pskel::
interval (signed char x)
{
  if (this->configurationType_impl_)
    this->configurationType_impl_->interval (x);
}

void configurationType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->polarity_parser_)
    this->polarity_parser_->_reset ();

  if (this->sample_rate_parser_)
    this->sample_rate_parser_->_reset ();

  if (this->debounce_parser_)
    this->debounce_parser_->_reset ();

  if (this->temp_tolerance_parser_)
    this->temp_tolerance_parser_->_reset ();

  if (this->sampling_period_parser_)
    this->sampling_period_parser_->_reset ();

  if (this->fan_speed_parser_)
    this->fan_speed_parser_->_reset ();

  if (this->fan_threshold_parser_)
    this->fan_threshold_parser_->_reset ();

  if (this->current_gain_parser_)
    this->current_gain_parser_->_reset ();

  if (this->heater_current_parser_)
    this->heater_current_parser_->_reset ();

  if (this->heater_threshold_parser_)
    this->heater_threshold_parser_->_reset ();

  if (this->current_deviation_parser_)
    this->current_deviation_parser_->_reset ();

  if (this->current_min_230_serial_parser_)
    this->current_min_230_serial_parser_->_reset ();

  if (this->current_max_230_serial_parser_)
    this->current_max_230_serial_parser_->_reset ();

  if (this->current_min_100_serial_parser_)
    this->current_min_100_serial_parser_->_reset ();

  if (this->current_max_100_serial_parser_)
    this->current_max_100_serial_parser_->_reset ();

  if (this->current_min_100_parallel_parser_)
    this->current_min_100_parallel_parser_->_reset ();

  if (this->current_max_100_parallel_parser_)
    this->current_max_100_parallel_parser_->_reset ();

  if (this->pressure_tolerance_parser_)
    this->pressure_tolerance_parser_->_reset ();

  if (this->fan_current_gain_parser_)
    this->fan_current_gain_parser_->_reset ();

  if (this->fan_current_parser_)
    this->fan_current_parser_->_reset ();

  if (this->pump_current_parser_)
    this->pump_current_parser_->_reset ();

  if (this->pump_threshold_parser_)
    this->pump_threshold_parser_->_reset ();

  if (this->enabled_parser_)
    this->enabled_parser_->_reset ();

  if (this->inactiv_shutdown_parser_)
    this->inactiv_shutdown_parser_->_reset ();

  if (this->inactiv_emcy_parser_)
    this->inactiv_emcy_parser_->_reset ();

  if (this->outval_inactiv_parser_)
    this->outval_inactiv_parser_->_reset ();

  if (this->livetime_limit_parser_)
    this->livetime_limit_parser_->_reset ();

  if (this->timestamp_parser_)
    this->timestamp_parser_->_reset ();

  if (this->threshold_parser_)
    this->threshold_parser_->_reset ();

  if (this->interval_parser_)
    this->interval_parser_->_reset ();
}

::std::string configurationType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// limitswitchType_pskel
//

void limitswitchType_pskel::
index (signed char x)
{
  if (this->limitswitchType_impl_)
    this->limitswitchType_impl_->index (x);
}

void limitswitchType_pskel::
configuration (const ::configurationType& x)
{
  if (this->limitswitchType_impl_)
    this->limitswitchType_impl_->configuration (x);
}

void limitswitchType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->index_parser_)
    this->index_parser_->_reset ();

  this->resetting_ = true;

  if (this->configuration_parser_)
    this->configuration_parser_->_reset ();

  this->resetting_ = false;
}

// position_codeType_pskel
//

void position_codeType_pskel::
value (signed char x)
{
  if (this->position_codeType_impl_)
    this->position_codeType_impl_->value (x);
}

void position_codeType_pskel::
stop (signed char x)
{
  if (this->position_codeType_impl_)
    this->position_codeType_impl_->stop (x);
}

void position_codeType_pskel::
stop_dir (const ::std::string& x)
{
  if (this->position_codeType_impl_)
    this->position_codeType_impl_->stop_dir (x);
}

void position_codeType_pskel::
position (signed char x)
{
  if (this->position_codeType_impl_)
    this->position_codeType_impl_->position (x);
}

void position_codeType_pskel::
width (signed char x)
{
  if (this->position_codeType_impl_)
    this->position_codeType_impl_->width (x);
}

void position_codeType_pskel::
deviation (signed char x)
{
  if (this->position_codeType_impl_)
    this->position_codeType_impl_->deviation (x);
}

void position_codeType_pskel::
dir_check (signed char x)
{
  if (this->position_codeType_impl_)
    this->position_codeType_impl_->dir_check (x);
}

void position_codeType_pskel::
hit_skip (signed char x)
{
  if (this->position_codeType_impl_)
    this->position_codeType_impl_->hit_skip (x);
}

void position_codeType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->value_parser_)
    this->value_parser_->_reset ();

  if (this->stop_parser_)
    this->stop_parser_->_reset ();

  if (this->stop_dir_parser_)
    this->stop_dir_parser_->_reset ();

  if (this->position_parser_)
    this->position_parser_->_reset ();

  if (this->width_parser_)
    this->width_parser_->_reset ();

  if (this->deviation_parser_)
    this->deviation_parser_->_reset ();

  if (this->dir_check_parser_)
    this->dir_check_parser_->_reset ();

  if (this->hit_skip_parser_)
    this->hit_skip_parser_->_reset ();
}

::std::string position_codeType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// limitswitchesType_pskel
//

void limitswitchesType_pskel::
limitswitch (const ::limitswitchType& x)
{
  if (this->limitswitchesType_impl_)
    this->limitswitchesType_impl_->limitswitch (x);
}

void limitswitchesType_pskel::
position_code (const ::position_codeType& x)
{
  if (this->limitswitchesType_impl_)
    this->limitswitchesType_impl_->position_code (x);
}

void limitswitchesType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->limitswitch_parser_)
    this->limitswitch_parser_->_reset ();

  if (this->position_code_parser_)
    this->position_code_parser_->_reset ();

  this->resetting_ = false;
}

// position_coverageType_pskel
//

void position_coverageType_pskel::
encoder (const ::encoderType& x)
{
  if (this->position_coverageType_impl_)
    this->position_coverageType_impl_->encoder (x);
}

void position_coverageType_pskel::
limitswitches (::limitswitchesType* x)
{
  if (this->position_coverageType_impl_)
    this->position_coverageType_impl_->limitswitches (x);
}

void position_coverageType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->encoder_parser_)
    this->encoder_parser_->_reset ();

  if (this->limitswitches_parser_)
    this->limitswitches_parser_->_reset ();

  this->resetting_ = false;
}

// supervisionType_pskel
//

void supervisionType_pskel::
steploss_warn_limit (signed char x)
{
  if (this->supervisionType_impl_)
    this->supervisionType_impl_->steploss_warn_limit (x);
}

void supervisionType_pskel::
steploss_error_limit (signed char x)
{
  if (this->supervisionType_impl_)
    this->supervisionType_impl_->steploss_error_limit (x);
}

void supervisionType_pskel::
current_limit (short x)
{
  if (this->supervisionType_impl_)
    this->supervisionType_impl_->current_limit (x);
}

void supervisionType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->steploss_warn_limit_parser_)
    this->steploss_warn_limit_parser_->_reset ();

  if (this->steploss_error_limit_parser_)
    this->steploss_error_limit_parser_->_reset ();

  if (this->current_limit_parser_)
    this->current_limit_parser_->_reset ();
}

::std::string supervisionType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// driverType_pskel
//

void driverType_pskel::
type (const ::std::string& x)
{
  if (this->driverType_impl_)
    this->driverType_impl_->type (x);
}

void driverType_pskel::
reg_chopConf (const ::std::string& x)
{
  if (this->driverType_impl_)
    this->driverType_impl_->reg_chopConf (x);
}

void driverType_pskel::
reg_smartEn (const ::std::string& x)
{
  if (this->driverType_impl_)
    this->driverType_impl_->reg_smartEn (x);
}

void driverType_pskel::
reg_sgcsConf (const ::std::string& x)
{
  if (this->driverType_impl_)
    this->driverType_impl_->reg_sgcsConf (x);
}

void driverType_pskel::
reg_drvConf (const ::std::string& x)
{
  if (this->driverType_impl_)
    this->driverType_impl_->reg_drvConf (x);
}

void driverType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->type_parser_)
    this->type_parser_->_reset ();

  if (this->reg_chopConf_parser_)
    this->reg_chopConf_parser_->_reset ();

  if (this->reg_smartEn_parser_)
    this->reg_smartEn_parser_->_reset ();

  if (this->reg_sgcsConf_parser_)
    this->reg_sgcsConf_parser_->_reset ();

  if (this->reg_drvConf_parser_)
    this->reg_drvConf_parser_->_reset ();
}

::std::string driverType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// motion_profileType_pskel
//

void motion_profileType_pskel::
speed_min (signed char x)
{
  if (this->motion_profileType_impl_)
    this->motion_profileType_impl_->speed_min (x);
}

void motion_profileType_pskel::
speed_max (short x)
{
  if (this->motion_profileType_impl_)
    this->motion_profileType_impl_->speed_max (x);
}

void motion_profileType_pskel::
acc (short x)
{
  if (this->motion_profileType_impl_)
    this->motion_profileType_impl_->acc (x);
}

void motion_profileType_pskel::
dec (short x)
{
  if (this->motion_profileType_impl_)
    this->motion_profileType_impl_->dec (x);
}

void motion_profileType_pskel::
acc_time (signed char x)
{
  if (this->motion_profileType_impl_)
    this->motion_profileType_impl_->acc_time (x);
}

void motion_profileType_pskel::
dec_time (signed char x)
{
  if (this->motion_profileType_impl_)
    this->motion_profileType_impl_->dec_time (x);
}

void motion_profileType_pskel::
micro_steps (signed char x)
{
  if (this->motion_profileType_impl_)
    this->motion_profileType_impl_->micro_steps (x);
}

void motion_profileType_pskel::
ramp_type (signed char x)
{
  if (this->motion_profileType_impl_)
    this->motion_profileType_impl_->ramp_type (x);
}

void motion_profileType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->speed_min_parser_)
    this->speed_min_parser_->_reset ();

  if (this->speed_max_parser_)
    this->speed_max_parser_->_reset ();

  if (this->acc_parser_)
    this->acc_parser_->_reset ();

  if (this->dec_parser_)
    this->dec_parser_->_reset ();

  if (this->acc_time_parser_)
    this->acc_time_parser_->_reset ();

  if (this->dec_time_parser_)
    this->dec_time_parser_->_reset ();

  if (this->micro_steps_parser_)
    this->micro_steps_parser_->_reset ();

  if (this->ramp_type_parser_)
    this->ramp_type_parser_->_reset ();
}

::std::string motion_profileType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// motion_profilesType_pskel
//

void motion_profilesType_pskel::
motion_profile (const ::motion_profileType& x)
{
  if (this->motion_profilesType_impl_)
    this->motion_profilesType_impl_->motion_profile (x);
}

void motion_profilesType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->motion_profile_parser_)
    this->motion_profile_parser_->_reset ();

  this->resetting_ = false;
}

// pid_controllerType_pskel
//

void pid_controllerType_pskel::
max_temperature (short x)
{
  if (this->pid_controllerType_impl_)
    this->pid_controllerType_impl_->max_temperature (x);
}

void pid_controllerType_pskel::
controller_gain (short x)
{
  if (this->pid_controllerType_impl_)
    this->pid_controllerType_impl_->controller_gain (x);
}

void pid_controllerType_pskel::
reset_time (short x)
{
  if (this->pid_controllerType_impl_)
    this->pid_controllerType_impl_->reset_time (x);
}

void pid_controllerType_pskel::
derivative_time (signed char x)
{
  if (this->pid_controllerType_impl_)
    this->pid_controllerType_impl_->derivative_time (x);
}

void pid_controllerType_pskel::
max_pressure (signed char x)
{
  if (this->pid_controllerType_impl_)
    this->pid_controllerType_impl_->max_pressure (x);
}

void pid_controllerType_pskel::
min_pressure (signed char x)
{
  if (this->pid_controllerType_impl_)
    this->pid_controllerType_impl_->min_pressure (x);
}

void pid_controllerType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->max_temperature_parser_)
    this->max_temperature_parser_->_reset ();

  if (this->controller_gain_parser_)
    this->controller_gain_parser_->_reset ();

  if (this->reset_time_parser_)
    this->reset_time_parser_->_reset ();

  if (this->derivative_time_parser_)
    this->derivative_time_parser_->_reset ();

  if (this->max_pressure_parser_)
    this->max_pressure_parser_->_reset ();

  if (this->min_pressure_parser_)
    this->min_pressure_parser_->_reset ();
}

::std::string pid_controllerType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// pid_controllersType_pskel
//

void pid_controllersType_pskel::
pid_controller (const ::pid_controllerType& x)
{
  if (this->pid_controllersType_impl_)
    this->pid_controllersType_impl_->pid_controller (x);
}

void pid_controllersType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->pid_controller_parser_)
    this->pid_controller_parser_->_reset ();

  this->resetting_ = false;
}

// pwm_controllerType_pskel
//

void pwm_controllerType_pskel::
max_actuating_value (short x)
{
  if (this->pwm_controllerType_impl_)
    this->pwm_controllerType_impl_->max_actuating_value (x);
}

void pwm_controllerType_pskel::
min_actuating_value (short x)
{
  if (this->pwm_controllerType_impl_)
    this->pwm_controllerType_impl_->min_actuating_value (x);
}

void pwm_controllerType_pskel::
max_pwm_duty (signed char x)
{
  if (this->pwm_controllerType_impl_)
    this->pwm_controllerType_impl_->max_pwm_duty (x);
}

void pwm_controllerType_pskel::
min_pwm_duty (signed char x)
{
  if (this->pwm_controllerType_impl_)
    this->pwm_controllerType_impl_->min_pwm_duty (x);
}

void pwm_controllerType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  if (this->max_actuating_value_parser_)
    this->max_actuating_value_parser_->_reset ();

  if (this->min_actuating_value_parser_)
    this->min_actuating_value_parser_->_reset ();

  if (this->max_pwm_duty_parser_)
    this->max_pwm_duty_parser_->_reset ();

  if (this->min_pwm_duty_parser_)
    this->min_pwm_duty_parser_->_reset ();
}

::std::string pwm_controllerType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// functionmoduleType_pskel
//

void functionmoduleType_pskel::
type (const ::std::string& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->type (x);
}

void functionmoduleType_pskel::
key (const ::std::string& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->key (x);
}

void functionmoduleType_pskel::
name (const ::std::string& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->name (x);
}

void functionmoduleType_pskel::
interface (signed char x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->interface (x);
}

void functionmoduleType_pskel::
fct_instanceID (const ::std::string& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->fct_instanceID (x);
}

void functionmoduleType_pskel::
rotation (const ::rotationType& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->rotation (x);
}

void functionmoduleType_pskel::
reference_run (const ::reference_runType& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->reference_run (x);
}

void functionmoduleType_pskel::
position_coverage (::position_coverageType* x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->position_coverage (x);
}

void functionmoduleType_pskel::
supervision (const ::supervisionType& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->supervision (x);
}

void functionmoduleType_pskel::
driver (const ::driverType& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->driver (x);
}

void functionmoduleType_pskel::
motion_profiles (::motion_profilesType* x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->motion_profiles (x);
}

void functionmoduleType_pskel::
configuration (const ::configurationType& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->configuration (x);
}

void functionmoduleType_pskel::
pid_controllers (const ::pid_controllersType& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->pid_controllers (x);
}

void functionmoduleType_pskel::
pwm_controller (const ::pwm_controllerType& x)
{
  if (this->functionmoduleType_impl_)
    this->functionmoduleType_impl_->pwm_controller (x);
}

void functionmoduleType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->type_parser_)
    this->type_parser_->_reset ();

  if (this->key_parser_)
    this->key_parser_->_reset ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->interface_parser_)
    this->interface_parser_->_reset ();

  if (this->fct_instanceID_parser_)
    this->fct_instanceID_parser_->_reset ();

  this->resetting_ = true;

  if (this->rotation_parser_)
    this->rotation_parser_->_reset ();

  if (this->reference_run_parser_)
    this->reference_run_parser_->_reset ();

  if (this->position_coverage_parser_)
    this->position_coverage_parser_->_reset ();

  if (this->supervision_parser_)
    this->supervision_parser_->_reset ();

  if (this->driver_parser_)
    this->driver_parser_->_reset ();

  if (this->motion_profiles_parser_)
    this->motion_profiles_parser_->_reset ();

  if (this->configuration_parser_)
    this->configuration_parser_->_reset ();

  if (this->pid_controllers_parser_)
    this->pid_controllers_parser_->_reset ();

  if (this->pwm_controller_parser_)
    this->pwm_controller_parser_->_reset ();

  this->resetting_ = false;
}

// functionmodulesType_pskel
//

void functionmodulesType_pskel::
functionmodule (::functionmoduleType* x)
{
  if (this->functionmodulesType_impl_)
    this->functionmodulesType_impl_->functionmodule (x);
}

void functionmodulesType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->functionmodule_parser_)
    this->functionmodule_parser_->_reset ();

  this->resetting_ = false;
}

// slaveType_pskel
//

void slaveType_pskel::
type (const ::std::string& x)
{
  if (this->slaveType_impl_)
    this->slaveType_impl_->type (x);
}

void slaveType_pskel::
key (const ::std::string& x)
{
  if (this->slaveType_impl_)
    this->slaveType_impl_->key (x);
}

void slaveType_pskel::
name (const ::std::string& x)
{
  if (this->slaveType_impl_)
    this->slaveType_impl_->name (x);
}

void slaveType_pskel::
virtual_ (signed char x)
{
  if (this->slaveType_impl_)
    this->slaveType_impl_->virtual_ (x);
}

void slaveType_pskel::
nodetype (signed char x)
{
  if (this->slaveType_impl_)
    this->slaveType_impl_->nodetype (x);
}

void slaveType_pskel::
nodeindex (signed char x)
{
  if (this->slaveType_impl_)
    this->slaveType_impl_->nodeindex (x);
}

void slaveType_pskel::
functionmodules (::functionmodulesType* x)
{
  if (this->slaveType_impl_)
    this->slaveType_impl_->functionmodules (x);
}

void slaveType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->type_parser_)
    this->type_parser_->_reset ();

  if (this->key_parser_)
    this->key_parser_->_reset ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->virtual__parser_)
    this->virtual__parser_->_reset ();

  this->resetting_ = true;

  if (this->nodetype_parser_)
    this->nodetype_parser_->_reset ();

  if (this->nodeindex_parser_)
    this->nodeindex_parser_->_reset ();

  if (this->functionmodules_parser_)
    this->functionmodules_parser_->_reset ();

  this->resetting_ = false;
}

// parameter_slavesType_pskel
//

void parameter_slavesType_pskel::
slave (::slaveType* x)
{
  if (this->parameter_slavesType_impl_)
    this->parameter_slavesType_impl_->slave (x);
}

void parameter_slavesType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->slave_parser_)
    this->slave_parser_->_reset ();

  this->resetting_ = false;
}

// hwconfigType_pskel
//

void hwconfigType_pskel::
version (float x)
{
  if (this->hwconfigType_impl_)
    this->hwconfigType_impl_->version (x);
}

void hwconfigType_pskel::
parameter_master (::parameter_masterType* x)
{
  if (this->hwconfigType_impl_)
    this->hwconfigType_impl_->parameter_master (x);
}

void hwconfigType_pskel::
parameter_slaves (::parameter_slavesType* x)
{
  if (this->hwconfigType_impl_)
    this->hwconfigType_impl_->parameter_slaves (x);
}

void hwconfigType_pskel::
devices (::devicesType* x)
{
  if (this->hwconfigType_impl_)
    this->hwconfigType_impl_->devices (x);
}

void hwconfigType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  if (this->version_parser_)
    this->version_parser_->_reset ();

  this->resetting_ = true;

  if (this->parameter_master_parser_)
    this->parameter_master_parser_->_reset ();

  if (this->parameter_slaves_parser_)
    this->parameter_slaves_parser_->_reset ();

  if (this->devices_parser_)
    this->devices_parser_->_reset ();

  this->resetting_ = false;
}

#include <assert.h>

// Element validation and dispatch functions for deviceType_pskel.
//
bool deviceType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "functionmodules" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &deviceType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool deviceType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void deviceType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void deviceType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void deviceType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "functionmodules" && ns.empty ())
      {
        if (start)
        {
          if (this->functionmodules_parser_)
          {
            this->functionmodules_parser_->pre ();

            if (this->functionmodules_parser_->_error_type ())
              this->functionmodules_parser_->_copy_error (ctx);

            ctx.nested_parser (this->functionmodules_parser_);
          }
        }
        else
        {
          if (this->functionmodules_parser_ != 0)
          {
            ::functionmodulesType* tmp = this->functionmodules_parser_->post_functionmodulesType ();

            if (this->functionmodules_parser_->_error_type ())
              this->functionmodules_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->functionmodules (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for devicesType_pskel.
//
bool devicesType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "device" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &devicesType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool devicesType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void devicesType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void devicesType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void devicesType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "device" && ns.empty ())
      {
        if (start)
        {
          if (this->device_parser_)
          {
            this->device_parser_->pre ();

            if (this->device_parser_->_error_type ())
              this->device_parser_->_copy_error (ctx);

            ctx.nested_parser (this->device_parser_);
          }
        }
        else
        {
          if (this->device_parser_ != 0)
          {
            ::deviceType* tmp = this->device_parser_->post_deviceType ();

            if (this->device_parser_->_error_type ())
              this->device_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->device (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for retortType_pskel.
//
bool retortType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "devices" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &retortType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool retortType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void retortType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void retortType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void retortType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "devices" && ns.empty ())
      {
        if (start)
        {
          if (this->devices_parser_)
          {
            this->devices_parser_->pre ();

            if (this->devices_parser_->_error_type ())
              this->devices_parser_->_copy_error (ctx);

            ctx.nested_parser (this->devices_parser_);
          }
        }
        else
        {
          if (this->devices_parser_ != 0)
          {
            ::devicesType* tmp = this->devices_parser_->post_devicesType ();

            if (this->devices_parser_->_error_type ())
              this->devices_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->devices (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for retortsType_pskel.
//
bool retortsType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "retort" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &retortsType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool retortsType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void retortsType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void retortsType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void retortsType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "retort" && ns.empty ())
      {
        if (start)
        {
          if (this->retort_parser_)
          {
            this->retort_parser_->pre ();

            if (this->retort_parser_->_error_type ())
              this->retort_parser_->_copy_error (ctx);

            ctx.nested_parser (this->retort_parser_);
          }
        }
        else
        {
          if (this->retort_parser_ != 0)
          {
            ::retortType* tmp = this->retort_parser_->post_retortType ();

            if (this->retort_parser_->_error_type ())
              this->retort_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->retort (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for parameter_masterType_pskel.
//
bool parameter_masterType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "can_interface" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &parameter_masterType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool parameter_masterType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void parameter_masterType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void parameter_masterType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void parameter_masterType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "can_interface" && ns.empty ())
      {
        if (start)
        {
          if (this->can_interface_parser_)
          {
            this->can_interface_parser_->pre ();

            if (this->can_interface_parser_->_error_type ())
              this->can_interface_parser_->_copy_error (ctx);

            ctx.nested_parser (this->can_interface_parser_);
          }
        }
        else
        {
          if (this->can_interface_parser_ != 0)
          {
            const ::can_interfaceType& tmp = this->can_interface_parser_->post_can_interfaceType ();

            if (this->can_interface_parser_->_error_type ())
              this->can_interface_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->can_interface (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "tcp_interface" && ns.empty ())
      {
        if (start)
        {
          if (this->tcp_interface_parser_)
          {
            this->tcp_interface_parser_->pre ();

            if (this->tcp_interface_parser_->_error_type ())
              this->tcp_interface_parser_->_copy_error (ctx);

            ctx.nested_parser (this->tcp_interface_parser_);
          }
        }
        else
        {
          if (this->tcp_interface_parser_ != 0)
          {
            const ::tcp_interfaceType& tmp = this->tcp_interface_parser_->post_tcp_interfaceType ();

            if (this->tcp_interface_parser_->_error_type ())
              this->tcp_interface_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->tcp_interface (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "nodetype" && ns.empty ())
      {
        if (start)
        {
          if (this->nodetype_parser_)
          {
            this->nodetype_parser_->pre ();

            if (this->nodetype_parser_->_error_type ())
              this->nodetype_parser_->_copy_error (ctx);

            ctx.nested_parser (this->nodetype_parser_);
          }
        }
        else
        {
          if (this->nodetype_parser_ != 0)
          {
            signed char tmp = this->nodetype_parser_->post_byte ();

            if (this->nodetype_parser_->_error_type ())
              this->nodetype_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->nodetype (tmp);
          }

          count = 0;
          state = 3UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "nodeindex" && ns.empty ())
      {
        if (start)
        {
          if (this->nodeindex_parser_)
          {
            this->nodeindex_parser_->pre ();

            if (this->nodeindex_parser_->_error_type ())
              this->nodeindex_parser_->_copy_error (ctx);

            ctx.nested_parser (this->nodeindex_parser_);
          }
        }
        else
        {
          if (this->nodeindex_parser_ != 0)
          {
            signed char tmp = this->nodeindex_parser_->post_byte ();

            if (this->nodeindex_parser_->_error_type ())
              this->nodeindex_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->nodeindex (tmp);
          }

          count = 0;
          state = 4UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 4UL;
        // Fall through.
      }
    }
    case 4UL:
    {
      if (n == "serial_number" && ns.empty ())
      {
        if (start)
        {
          if (this->serial_number_parser_)
          {
            this->serial_number_parser_->pre ();

            if (this->serial_number_parser_->_error_type ())
              this->serial_number_parser_->_copy_error (ctx);

            ctx.nested_parser (this->serial_number_parser_);
          }
        }
        else
        {
          if (this->serial_number_parser_ != 0)
          {
            const ::serial_numberType& tmp = this->serial_number_parser_->post_serial_numberType ();

            if (this->serial_number_parser_->_error_type ())
              this->serial_number_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->serial_number (tmp);
          }

          count = 0;
          state = 5UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 5UL;
        // Fall through.
      }
    }
    case 5UL:
    {
      if (n == "retorts" && ns.empty ())
      {
        if (start)
        {
          if (this->retorts_parser_)
          {
            this->retorts_parser_->pre ();

            if (this->retorts_parser_->_error_type ())
              this->retorts_parser_->_copy_error (ctx);

            ctx.nested_parser (this->retorts_parser_);
          }
        }
        else
        {
          if (this->retorts_parser_ != 0)
          {
            ::retortsType* tmp = this->retorts_parser_->post_retortsType ();

            if (this->retorts_parser_->_error_type ())
              this->retorts_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->retorts (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for limitswitchType_pskel.
//
bool limitswitchType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "configuration" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &limitswitchType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool limitswitchType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void limitswitchType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void limitswitchType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void limitswitchType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "configuration" && ns.empty ())
      {
        if (start)
        {
          if (this->configuration_parser_)
          {
            this->configuration_parser_->pre ();

            if (this->configuration_parser_->_error_type ())
              this->configuration_parser_->_copy_error (ctx);

            ctx.nested_parser (this->configuration_parser_);
          }
        }
        else
        {
          if (this->configuration_parser_ != 0)
          {
            const ::configurationType& tmp = this->configuration_parser_->post_configurationType ();

            if (this->configuration_parser_->_error_type ())
              this->configuration_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->configuration (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for limitswitchesType_pskel.
//
bool limitswitchesType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "limitswitch" && ns.empty ())
        s = 0UL;
      else if (n == "position_code" && ns.empty ())
        s = 1UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &limitswitchesType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool limitswitchesType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void limitswitchesType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void limitswitchesType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void limitswitchesType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "limitswitch" && ns.empty ())
      {
        if (start)
        {
          if (this->limitswitch_parser_)
          {
            this->limitswitch_parser_->pre ();

            if (this->limitswitch_parser_->_error_type ())
              this->limitswitch_parser_->_copy_error (ctx);

            ctx.nested_parser (this->limitswitch_parser_);
          }
        }
        else
        {
          if (this->limitswitch_parser_ != 0)
          {
            const ::limitswitchType& tmp = this->limitswitch_parser_->post_limitswitchType ();

            if (this->limitswitch_parser_->_error_type ())
              this->limitswitch_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->limitswitch (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "position_code" && ns.empty ())
      {
        if (start)
        {
          if (this->position_code_parser_)
          {
            this->position_code_parser_->pre ();

            if (this->position_code_parser_->_error_type ())
              this->position_code_parser_->_copy_error (ctx);

            ctx.nested_parser (this->position_code_parser_);
          }
        }
        else
        {
          if (this->position_code_parser_ != 0)
          {
            const ::position_codeType& tmp = this->position_code_parser_->post_position_codeType ();

            if (this->position_code_parser_->_error_type ())
              this->position_code_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->position_code (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for position_coverageType_pskel.
//
bool position_coverageType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "encoder" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &position_coverageType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool position_coverageType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void position_coverageType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void position_coverageType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void position_coverageType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "encoder" && ns.empty ())
      {
        if (start)
        {
          if (this->encoder_parser_)
          {
            this->encoder_parser_->pre ();

            if (this->encoder_parser_->_error_type ())
              this->encoder_parser_->_copy_error (ctx);

            ctx.nested_parser (this->encoder_parser_);
          }
        }
        else
        {
          if (this->encoder_parser_ != 0)
          {
            const ::encoderType& tmp = this->encoder_parser_->post_encoderType ();

            if (this->encoder_parser_->_error_type ())
              this->encoder_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->encoder (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "limitswitches" && ns.empty ())
      {
        if (start)
        {
          if (this->limitswitches_parser_)
          {
            this->limitswitches_parser_->pre ();

            if (this->limitswitches_parser_->_error_type ())
              this->limitswitches_parser_->_copy_error (ctx);

            ctx.nested_parser (this->limitswitches_parser_);
          }
        }
        else
        {
          if (this->limitswitches_parser_ != 0)
          {
            ::limitswitchesType* tmp = this->limitswitches_parser_->post_limitswitchesType ();

            if (this->limitswitches_parser_->_error_type ())
              this->limitswitches_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->limitswitches (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for motion_profilesType_pskel.
//
bool motion_profilesType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "motion_profile" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &motion_profilesType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool motion_profilesType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void motion_profilesType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void motion_profilesType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void motion_profilesType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "motion_profile" && ns.empty ())
      {
        if (start)
        {
          if (this->motion_profile_parser_)
          {
            this->motion_profile_parser_->pre ();

            if (this->motion_profile_parser_->_error_type ())
              this->motion_profile_parser_->_copy_error (ctx);

            ctx.nested_parser (this->motion_profile_parser_);
          }
        }
        else
        {
          if (this->motion_profile_parser_ != 0)
          {
            const ::motion_profileType& tmp = this->motion_profile_parser_->post_motion_profileType ();

            if (this->motion_profile_parser_->_error_type ())
              this->motion_profile_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->motion_profile (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for pid_controllersType_pskel.
//
bool pid_controllersType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "pid_controller" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &pid_controllersType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool pid_controllersType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void pid_controllersType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void pid_controllersType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void pid_controllersType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "pid_controller" && ns.empty ())
      {
        if (start)
        {
          if (this->pid_controller_parser_)
          {
            this->pid_controller_parser_->pre ();

            if (this->pid_controller_parser_->_error_type ())
              this->pid_controller_parser_->_copy_error (ctx);

            ctx.nested_parser (this->pid_controller_parser_);
          }
        }
        else
        {
          if (this->pid_controller_parser_ != 0)
          {
            const ::pid_controllerType& tmp = this->pid_controller_parser_->post_pid_controllerType ();

            if (this->pid_controller_parser_->_error_type ())
              this->pid_controller_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->pid_controller (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for functionmoduleType_pskel.
//
bool functionmoduleType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "rotation" && ns.empty ())
        s = 0UL;
      else if (n == "reference_run" && ns.empty ())
        s = 1UL;
      else if (n == "position_coverage" && ns.empty ())
        s = 2UL;
      else if (n == "supervision" && ns.empty ())
        s = 3UL;
      else if (n == "driver" && ns.empty ())
        s = 4UL;
      else if (n == "motion_profiles" && ns.empty ())
        s = 5UL;
      else if (n == "configuration" && ns.empty ())
        s = 6UL;
      else if (n == "pid_controllers" && ns.empty ())
        s = 7UL;
      else if (n == "pwm_controller" && ns.empty ())
        s = 8UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &functionmoduleType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool functionmoduleType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void functionmoduleType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void functionmoduleType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void functionmoduleType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "rotation" && ns.empty ())
      {
        if (start)
        {
          if (this->rotation_parser_)
          {
            this->rotation_parser_->pre ();

            if (this->rotation_parser_->_error_type ())
              this->rotation_parser_->_copy_error (ctx);

            ctx.nested_parser (this->rotation_parser_);
          }
        }
        else
        {
          if (this->rotation_parser_ != 0)
          {
            const ::rotationType& tmp = this->rotation_parser_->post_rotationType ();

            if (this->rotation_parser_->_error_type ())
              this->rotation_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->rotation (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "reference_run" && ns.empty ())
      {
        if (start)
        {
          if (this->reference_run_parser_)
          {
            this->reference_run_parser_->pre ();

            if (this->reference_run_parser_->_error_type ())
              this->reference_run_parser_->_copy_error (ctx);

            ctx.nested_parser (this->reference_run_parser_);
          }
        }
        else
        {
          if (this->reference_run_parser_ != 0)
          {
            const ::reference_runType& tmp = this->reference_run_parser_->post_reference_runType ();

            if (this->reference_run_parser_->_error_type ())
              this->reference_run_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->reference_run (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "position_coverage" && ns.empty ())
      {
        if (start)
        {
          if (this->position_coverage_parser_)
          {
            this->position_coverage_parser_->pre ();

            if (this->position_coverage_parser_->_error_type ())
              this->position_coverage_parser_->_copy_error (ctx);

            ctx.nested_parser (this->position_coverage_parser_);
          }
        }
        else
        {
          if (this->position_coverage_parser_ != 0)
          {
            ::position_coverageType* tmp = this->position_coverage_parser_->post_position_coverageType ();

            if (this->position_coverage_parser_->_error_type ())
              this->position_coverage_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->position_coverage (tmp);
          }

          count = 0;
          state = 3UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "supervision" && ns.empty ())
      {
        if (start)
        {
          if (this->supervision_parser_)
          {
            this->supervision_parser_->pre ();

            if (this->supervision_parser_->_error_type ())
              this->supervision_parser_->_copy_error (ctx);

            ctx.nested_parser (this->supervision_parser_);
          }
        }
        else
        {
          if (this->supervision_parser_ != 0)
          {
            const ::supervisionType& tmp = this->supervision_parser_->post_supervisionType ();

            if (this->supervision_parser_->_error_type ())
              this->supervision_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->supervision (tmp);
          }

          count = 0;
          state = 4UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 4UL;
        // Fall through.
      }
    }
    case 4UL:
    {
      if (n == "driver" && ns.empty ())
      {
        if (start)
        {
          if (this->driver_parser_)
          {
            this->driver_parser_->pre ();

            if (this->driver_parser_->_error_type ())
              this->driver_parser_->_copy_error (ctx);

            ctx.nested_parser (this->driver_parser_);
          }
        }
        else
        {
          if (this->driver_parser_ != 0)
          {
            const ::driverType& tmp = this->driver_parser_->post_driverType ();

            if (this->driver_parser_->_error_type ())
              this->driver_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->driver (tmp);
          }

          count = 0;
          state = 5UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 5UL;
        // Fall through.
      }
    }
    case 5UL:
    {
      if (n == "motion_profiles" && ns.empty ())
      {
        if (start)
        {
          if (this->motion_profiles_parser_)
          {
            this->motion_profiles_parser_->pre ();

            if (this->motion_profiles_parser_->_error_type ())
              this->motion_profiles_parser_->_copy_error (ctx);

            ctx.nested_parser (this->motion_profiles_parser_);
          }
        }
        else
        {
          if (this->motion_profiles_parser_ != 0)
          {
            ::motion_profilesType* tmp = this->motion_profiles_parser_->post_motion_profilesType ();

            if (this->motion_profiles_parser_->_error_type ())
              this->motion_profiles_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->motion_profiles (tmp);
          }

          count = 0;
          state = 6UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 6UL;
        // Fall through.
      }
    }
    case 6UL:
    {
      if (n == "configuration" && ns.empty ())
      {
        if (start)
        {
          if (this->configuration_parser_)
          {
            this->configuration_parser_->pre ();

            if (this->configuration_parser_->_error_type ())
              this->configuration_parser_->_copy_error (ctx);

            ctx.nested_parser (this->configuration_parser_);
          }
        }
        else
        {
          if (this->configuration_parser_ != 0)
          {
            const ::configurationType& tmp = this->configuration_parser_->post_configurationType ();

            if (this->configuration_parser_->_error_type ())
              this->configuration_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->configuration (tmp);
          }

          count = 0;
          state = 7UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 7UL;
        // Fall through.
      }
    }
    case 7UL:
    {
      if (n == "pid_controllers" && ns.empty ())
      {
        if (start)
        {
          if (this->pid_controllers_parser_)
          {
            this->pid_controllers_parser_->pre ();

            if (this->pid_controllers_parser_->_error_type ())
              this->pid_controllers_parser_->_copy_error (ctx);

            ctx.nested_parser (this->pid_controllers_parser_);
          }
        }
        else
        {
          if (this->pid_controllers_parser_ != 0)
          {
            const ::pid_controllersType& tmp = this->pid_controllers_parser_->post_pid_controllersType ();

            if (this->pid_controllers_parser_->_error_type ())
              this->pid_controllers_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->pid_controllers (tmp);
          }

          count = 0;
          state = 8UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 8UL;
        // Fall through.
      }
    }
    case 8UL:
    {
      if (n == "pwm_controller" && ns.empty ())
      {
        if (start)
        {
          if (this->pwm_controller_parser_)
          {
            this->pwm_controller_parser_->pre ();

            if (this->pwm_controller_parser_->_error_type ())
              this->pwm_controller_parser_->_copy_error (ctx);

            ctx.nested_parser (this->pwm_controller_parser_);
          }
        }
        else
        {
          if (this->pwm_controller_parser_ != 0)
          {
            const ::pwm_controllerType& tmp = this->pwm_controller_parser_->post_pwm_controllerType ();

            if (this->pwm_controller_parser_->_error_type ())
              this->pwm_controller_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->pwm_controller (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for functionmodulesType_pskel.
//
bool functionmodulesType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "functionmodule" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &functionmodulesType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool functionmodulesType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void functionmodulesType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void functionmodulesType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void functionmodulesType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "functionmodule" && ns.empty ())
      {
        if (start)
        {
          if (this->functionmodule_parser_)
          {
            this->functionmodule_parser_->pre ();

            if (this->functionmodule_parser_->_error_type ())
              this->functionmodule_parser_->_copy_error (ctx);

            ctx.nested_parser (this->functionmodule_parser_);
          }
        }
        else
        {
          if (this->functionmodule_parser_ != 0)
          {
            ::functionmoduleType* tmp = this->functionmodule_parser_->post_functionmoduleType ();

            if (this->functionmodule_parser_->_error_type ())
              this->functionmodule_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->functionmodule (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for slaveType_pskel.
//
bool slaveType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "nodetype" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &slaveType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool slaveType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void slaveType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void slaveType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void slaveType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "nodetype" && ns.empty ())
      {
        if (start)
        {
          if (this->nodetype_parser_)
          {
            this->nodetype_parser_->pre ();

            if (this->nodetype_parser_->_error_type ())
              this->nodetype_parser_->_copy_error (ctx);

            ctx.nested_parser (this->nodetype_parser_);
          }
        }
        else
        {
          if (this->nodetype_parser_ != 0)
          {
            signed char tmp = this->nodetype_parser_->post_byte ();

            if (this->nodetype_parser_->_error_type ())
              this->nodetype_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->nodetype (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "nodeindex" && ns.empty ())
      {
        if (start)
        {
          if (this->nodeindex_parser_)
          {
            this->nodeindex_parser_->pre ();

            if (this->nodeindex_parser_->_error_type ())
              this->nodeindex_parser_->_copy_error (ctx);

            ctx.nested_parser (this->nodeindex_parser_);
          }
        }
        else
        {
          if (this->nodeindex_parser_ != 0)
          {
            signed char tmp = this->nodeindex_parser_->post_byte ();

            if (this->nodeindex_parser_->_error_type ())
              this->nodeindex_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->nodeindex (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "functionmodules" && ns.empty ())
      {
        if (start)
        {
          if (this->functionmodules_parser_)
          {
            this->functionmodules_parser_->pre ();

            if (this->functionmodules_parser_->_error_type ())
              this->functionmodules_parser_->_copy_error (ctx);

            ctx.nested_parser (this->functionmodules_parser_);
          }
        }
        else
        {
          if (this->functionmodules_parser_ != 0)
          {
            ::functionmodulesType* tmp = this->functionmodules_parser_->post_functionmodulesType ();

            if (this->functionmodules_parser_->_error_type ())
              this->functionmodules_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->functionmodules (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for parameter_slavesType_pskel.
//
bool parameter_slavesType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "slave" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &parameter_slavesType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool parameter_slavesType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void parameter_slavesType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void parameter_slavesType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void parameter_slavesType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "slave" && ns.empty ())
      {
        if (start)
        {
          if (this->slave_parser_)
          {
            this->slave_parser_->pre ();

            if (this->slave_parser_->_error_type ())
              this->slave_parser_->_copy_error (ctx);

            ctx.nested_parser (this->slave_parser_);
          }
        }
        else
        {
          if (this->slave_parser_ != 0)
          {
            ::slaveType* tmp = this->slave_parser_->post_slaveType ();

            if (this->slave_parser_->_error_type ())
              this->slave_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->slave (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for hwconfigType_pskel.
//
bool hwconfigType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "parameter_master" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &hwconfigType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool hwconfigType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void hwconfigType_pskel::
_pre_e_validate ()
{
  if (this->v_state_stack_.push ())
  {
    this->_sys_error (::xsde::cxx::sys_error::no_memory);
    return;
  }

  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void hwconfigType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void hwconfigType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "parameter_master" && ns.empty ())
      {
        if (start)
        {
          if (this->parameter_master_parser_)
          {
            this->parameter_master_parser_->pre ();

            if (this->parameter_master_parser_->_error_type ())
              this->parameter_master_parser_->_copy_error (ctx);

            ctx.nested_parser (this->parameter_master_parser_);
          }
        }
        else
        {
          if (this->parameter_master_parser_ != 0)
          {
            ::parameter_masterType* tmp = this->parameter_master_parser_->post_parameter_masterType ();

            if (this->parameter_master_parser_->_error_type ())
              this->parameter_master_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->parameter_master (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "parameter_slaves" && ns.empty ())
      {
        if (start)
        {
          if (this->parameter_slaves_parser_)
          {
            this->parameter_slaves_parser_->pre ();

            if (this->parameter_slaves_parser_->_error_type ())
              this->parameter_slaves_parser_->_copy_error (ctx);

            ctx.nested_parser (this->parameter_slaves_parser_);
          }
        }
        else
        {
          if (this->parameter_slaves_parser_ != 0)
          {
            ::parameter_slavesType* tmp = this->parameter_slaves_parser_->post_parameter_slavesType ();

            if (this->parameter_slaves_parser_->_error_type ())
              this->parameter_slaves_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->parameter_slaves (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "devices" && ns.empty ())
      {
        if (start)
        {
          if (this->devices_parser_)
          {
            this->devices_parser_->pre ();

            if (this->devices_parser_->_error_type ())
              this->devices_parser_->_copy_error (ctx);

            ctx.nested_parser (this->devices_parser_);
          }
        }
        else
        {
          if (this->devices_parser_ != 0)
          {
            ::devicesType* tmp = this->devices_parser_->post_devicesType ();

            if (this->devices_parser_->_error_type ())
              this->devices_parser_->_copy_error (ctx);

            if (!ctx.error_type ())
              this->devices (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Attribute validation and dispatch functions for can_interfaceType_pskel.
//
bool can_interfaceType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "interface" && ns.empty ())
  {
    if (this->interface_parser_)
    {
      this->interface_parser_->pre ();

      if (this->interface_parser_->_error_type ())
        this->interface_parser_->_copy_error (ctx);
      else
        this->interface_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->interface_parser_->_characters (s);

      if (!ctx.error_type ())
        this->interface_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->interface_parser_->post_string ();

        if (this->interface_parser_->_error_type ())
          this->interface_parser_->_copy_error (ctx);
        else
          this->interface (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for tcp_interfaceType_pskel.
//
bool tcp_interfaceType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "usage" && ns.empty ())
  {
    if (this->usage_parser_)
    {
      this->usage_parser_->pre ();

      if (this->usage_parser_->_error_type ())
        this->usage_parser_->_copy_error (ctx);
      else
        this->usage_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->usage_parser_->_characters (s);

      if (!ctx.error_type ())
        this->usage_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->usage_parser_->post_byte ();

        if (this->usage_parser_->_error_type ())
          this->usage_parser_->_copy_error (ctx);
        else
          this->usage (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for serial_numberType_pskel.
//
bool serial_numberType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "serialno" && ns.empty ())
  {
    if (this->serialno_parser_)
    {
      this->serialno_parser_->pre ();

      if (this->serialno_parser_->_error_type ())
        this->serialno_parser_->_copy_error (ctx);
      else
        this->serialno_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->serialno_parser_->_characters (s);

      if (!ctx.error_type ())
        this->serialno_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->serialno_parser_->post_string ();

        if (this->serialno_parser_->_error_type ())
          this->serialno_parser_->_copy_error (ctx);
        else
          this->serialno (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for deviceType_pskel.
//
bool deviceType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      if (this->name_parser_->_error_type ())
        this->name_parser_->_copy_error (ctx);
      else
        this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_string ();

        if (this->name_parser_->_error_type ())
          this->name_parser_->_copy_error (ctx);
        else
          this->name (tmp);
      }
    }

    return true;
  }

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      if (this->id_parser_->_error_type ())
        this->id_parser_->_copy_error (ctx);
      else
        this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->id_parser_->post_string ();

        if (this->id_parser_->_error_type ())
          this->id_parser_->_copy_error (ctx);
        else
          this->id (tmp);
      }
    }

    return true;
  }

  if (n == "type" && ns.empty ())
  {
    if (this->type_parser_)
    {
      this->type_parser_->pre ();

      if (this->type_parser_->_error_type ())
        this->type_parser_->_copy_error (ctx);
      else
        this->type_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->type_parser_->_characters (s);

      if (!ctx.error_type ())
        this->type_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->type_parser_->post_string ();

        if (this->type_parser_->_error_type ())
          this->type_parser_->_copy_error (ctx);
        else
          this->type (tmp);
      }
    }

    return true;
  }

  if (n == "dev_instanceID" && ns.empty ())
  {
    if (this->dev_instanceID_parser_)
    {
      this->dev_instanceID_parser_->pre ();

      if (this->dev_instanceID_parser_->_error_type ())
        this->dev_instanceID_parser_->_copy_error (ctx);
      else
        this->dev_instanceID_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->dev_instanceID_parser_->_characters (s);

      if (!ctx.error_type ())
        this->dev_instanceID_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->dev_instanceID_parser_->post_string ();

        if (this->dev_instanceID_parser_->_error_type ())
          this->dev_instanceID_parser_->_copy_error (ctx);
        else
          this->dev_instanceID (tmp);
      }
    }

    return true;
  }

  if (n == "optional" && ns.empty ())
  {
    if (this->optional_parser_)
    {
      this->optional_parser_->pre ();

      if (this->optional_parser_->_error_type ())
        this->optional_parser_->_copy_error (ctx);
      else
        this->optional_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->optional_parser_->_characters (s);

      if (!ctx.error_type ())
        this->optional_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->optional_parser_->post_byte ();

        if (this->optional_parser_->_error_type ())
          this->optional_parser_->_copy_error (ctx);
        else
          this->optional (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for retortType_pskel.
//
bool retortType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      if (this->name_parser_->_error_type ())
        this->name_parser_->_copy_error (ctx);
      else
        this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_string ();

        if (this->name_parser_->_error_type ())
          this->name_parser_->_copy_error (ctx);
        else
          this->name (tmp);
      }
    }

    return true;
  }

  if (n == "index" && ns.empty ())
  {
    if (this->index_parser_)
    {
      this->index_parser_->pre ();

      if (this->index_parser_->_error_type ())
        this->index_parser_->_copy_error (ctx);
      else
        this->index_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->index_parser_->_characters (s);

      if (!ctx.error_type ())
        this->index_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->index_parser_->post_byte ();

        if (this->index_parser_->_error_type ())
          this->index_parser_->_copy_error (ctx);
        else
          this->index (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for parameter_masterType_pskel.
//
bool parameter_masterType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "folded" && ns.empty ())
  {
    if (this->folded_parser_)
    {
      this->folded_parser_->pre ();

      if (this->folded_parser_->_error_type ())
        this->folded_parser_->_copy_error (ctx);
      else
        this->folded_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->folded_parser_->_characters (s);

      if (!ctx.error_type ())
        this->folded_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->folded_parser_->post_string ();

        if (this->folded_parser_->_error_type ())
          this->folded_parser_->_copy_error (ctx);
        else
          this->folded (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for rotationType_pskel.
//
bool rotationType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "type" && ns.empty ())
  {
    if (this->type_parser_)
    {
      this->type_parser_->pre ();

      if (this->type_parser_->_error_type ())
        this->type_parser_->_copy_error (ctx);
      else
        this->type_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->type_parser_->_characters (s);

      if (!ctx.error_type ())
        this->type_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->type_parser_->post_string ();

        if (this->type_parser_->_error_type ())
          this->type_parser_->_copy_error (ctx);
        else
          this->type (tmp);
      }
    }

    return true;
  }

  if (n == "direction" && ns.empty ())
  {
    if (this->direction_parser_)
    {
      this->direction_parser_->pre ();

      if (this->direction_parser_->_error_type ())
        this->direction_parser_->_copy_error (ctx);
      else
        this->direction_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->direction_parser_->_characters (s);

      if (!ctx.error_type ())
        this->direction_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->direction_parser_->post_string ();

        if (this->direction_parser_->_error_type ())
          this->direction_parser_->_copy_error (ctx);
        else
          this->direction (tmp);
      }
    }

    return true;
  }

  if (n == "steps_revolution" && ns.empty ())
  {
    if (this->steps_revolution_parser_)
    {
      this->steps_revolution_parser_->pre ();

      if (this->steps_revolution_parser_->_error_type ())
        this->steps_revolution_parser_->_copy_error (ctx);
      else
        this->steps_revolution_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->steps_revolution_parser_->_characters (s);

      if (!ctx.error_type ())
        this->steps_revolution_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->steps_revolution_parser_->post_short ();

        if (this->steps_revolution_parser_->_error_type ())
          this->steps_revolution_parser_->_copy_error (ctx);
        else
          this->steps_revolution (tmp);
      }
    }

    return true;
  }

  if (n == "position_min" && ns.empty ())
  {
    if (this->position_min_parser_)
    {
      this->position_min_parser_->pre ();

      if (this->position_min_parser_->_error_type ())
        this->position_min_parser_->_copy_error (ctx);
      else
        this->position_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->position_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->position_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->position_min_parser_->post_short ();

        if (this->position_min_parser_->_error_type ())
          this->position_min_parser_->_copy_error (ctx);
        else
          this->position_min (tmp);
      }
    }

    return true;
  }

  if (n == "position_max" && ns.empty ())
  {
    if (this->position_max_parser_)
    {
      this->position_max_parser_->pre ();

      if (this->position_max_parser_->_error_type ())
        this->position_max_parser_->_copy_error (ctx);
      else
        this->position_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->position_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->position_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->position_max_parser_->post_short ();

        if (this->position_max_parser_->_error_type ())
          this->position_max_parser_->_copy_error (ctx);
        else
          this->position_max (tmp);
      }
    }

    return true;
  }

  if (n == "speed_min" && ns.empty ())
  {
    if (this->speed_min_parser_)
    {
      this->speed_min_parser_->pre ();

      if (this->speed_min_parser_->_error_type ())
        this->speed_min_parser_->_copy_error (ctx);
      else
        this->speed_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->speed_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->speed_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->speed_min_parser_->post_byte ();

        if (this->speed_min_parser_->_error_type ())
          this->speed_min_parser_->_copy_error (ctx);
        else
          this->speed_min (tmp);
      }
    }

    return true;
  }

  if (n == "speed_max" && ns.empty ())
  {
    if (this->speed_max_parser_)
    {
      this->speed_max_parser_->pre ();

      if (this->speed_max_parser_->_error_type ())
        this->speed_max_parser_->_copy_error (ctx);
      else
        this->speed_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->speed_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->speed_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->speed_max_parser_->post_short ();

        if (this->speed_max_parser_->_error_type ())
          this->speed_max_parser_->_copy_error (ctx);
        else
          this->speed_max (tmp);
      }
    }

    return true;
  }

  if (n == "run_cs" && ns.empty ())
  {
    if (this->run_cs_parser_)
    {
      this->run_cs_parser_->pre ();

      if (this->run_cs_parser_->_error_type ())
        this->run_cs_parser_->_copy_error (ctx);
      else
        this->run_cs_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->run_cs_parser_->_characters (s);

      if (!ctx.error_type ())
        this->run_cs_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->run_cs_parser_->post_byte ();

        if (this->run_cs_parser_->_error_type ())
          this->run_cs_parser_->_copy_error (ctx);
        else
          this->run_cs (tmp);
      }
    }

    return true;
  }

  if (n == "stop_cs" && ns.empty ())
  {
    if (this->stop_cs_parser_)
    {
      this->stop_cs_parser_->pre ();

      if (this->stop_cs_parser_->_error_type ())
        this->stop_cs_parser_->_copy_error (ctx);
      else
        this->stop_cs_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->stop_cs_parser_->_characters (s);

      if (!ctx.error_type ())
        this->stop_cs_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->stop_cs_parser_->post_byte ();

        if (this->stop_cs_parser_->_error_type ())
          this->stop_cs_parser_->_copy_error (ctx);
        else
          this->stop_cs (tmp);
      }
    }

    return true;
  }

  if (n == "stop_cs_delay" && ns.empty ())
  {
    if (this->stop_cs_delay_parser_)
    {
      this->stop_cs_delay_parser_->pre ();

      if (this->stop_cs_delay_parser_->_error_type ())
        this->stop_cs_delay_parser_->_copy_error (ctx);
      else
        this->stop_cs_delay_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->stop_cs_delay_parser_->_characters (s);

      if (!ctx.error_type ())
        this->stop_cs_delay_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->stop_cs_delay_parser_->post_short ();

        if (this->stop_cs_delay_parser_->_error_type ())
          this->stop_cs_delay_parser_->_copy_error (ctx);
        else
          this->stop_cs_delay (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for reference_runType_pskel.
//
bool reference_runType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "ref_position" && ns.empty ())
  {
    if (this->ref_position_parser_)
    {
      this->ref_position_parser_->pre ();

      if (this->ref_position_parser_->_error_type ())
        this->ref_position_parser_->_copy_error (ctx);
      else
        this->ref_position_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->ref_position_parser_->_characters (s);

      if (!ctx.error_type ())
        this->ref_position_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->ref_position_parser_->post_byte ();

        if (this->ref_position_parser_->_error_type ())
          this->ref_position_parser_->_copy_error (ctx);
        else
          this->ref_position (tmp);
      }
    }

    return true;
  }

  if (n == "max_distance" && ns.empty ())
  {
    if (this->max_distance_parser_)
    {
      this->max_distance_parser_->pre ();

      if (this->max_distance_parser_->_error_type ())
        this->max_distance_parser_->_copy_error (ctx);
      else
        this->max_distance_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->max_distance_parser_->_characters (s);

      if (!ctx.error_type ())
        this->max_distance_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->max_distance_parser_->post_short ();

        if (this->max_distance_parser_->_error_type ())
          this->max_distance_parser_->_copy_error (ctx);
        else
          this->max_distance (tmp);
      }
    }

    return true;
  }

  if (n == "timeout" && ns.empty ())
  {
    if (this->timeout_parser_)
    {
      this->timeout_parser_->pre ();

      if (this->timeout_parser_->_error_type ())
        this->timeout_parser_->_copy_error (ctx);
      else
        this->timeout_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->timeout_parser_->_characters (s);

      if (!ctx.error_type ())
        this->timeout_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        int tmp = this->timeout_parser_->post_int ();

        if (this->timeout_parser_->_error_type ())
          this->timeout_parser_->_copy_error (ctx);
        else
          this->timeout (tmp);
      }
    }

    return true;
  }

  if (n == "reverse_distance" && ns.empty ())
  {
    if (this->reverse_distance_parser_)
    {
      this->reverse_distance_parser_->pre ();

      if (this->reverse_distance_parser_->_error_type ())
        this->reverse_distance_parser_->_copy_error (ctx);
      else
        this->reverse_distance_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->reverse_distance_parser_->_characters (s);

      if (!ctx.error_type ())
        this->reverse_distance_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->reverse_distance_parser_->post_byte ();

        if (this->reverse_distance_parser_->_error_type ())
          this->reverse_distance_parser_->_copy_error (ctx);
        else
          this->reverse_distance (tmp);
      }
    }

    return true;
  }

  if (n == "slow_speed" && ns.empty ())
  {
    if (this->slow_speed_parser_)
    {
      this->slow_speed_parser_->pre ();

      if (this->slow_speed_parser_->_error_type ())
        this->slow_speed_parser_->_copy_error (ctx);
      else
        this->slow_speed_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->slow_speed_parser_->_characters (s);

      if (!ctx.error_type ())
        this->slow_speed_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->slow_speed_parser_->post_byte ();

        if (this->slow_speed_parser_->_error_type ())
          this->slow_speed_parser_->_copy_error (ctx);
        else
          this->slow_speed (tmp);
      }
    }

    return true;
  }

  if (n == "high_speed" && ns.empty ())
  {
    if (this->high_speed_parser_)
    {
      this->high_speed_parser_->pre ();

      if (this->high_speed_parser_->_error_type ())
        this->high_speed_parser_->_copy_error (ctx);
      else
        this->high_speed_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->high_speed_parser_->_characters (s);

      if (!ctx.error_type ())
        this->high_speed_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->high_speed_parser_->post_short ();

        if (this->high_speed_parser_->_error_type ())
          this->high_speed_parser_->_copy_error (ctx);
        else
          this->high_speed (tmp);
      }
    }

    return true;
  }

  if (n == "refpos_offset" && ns.empty ())
  {
    if (this->refpos_offset_parser_)
    {
      this->refpos_offset_parser_->pre ();

      if (this->refpos_offset_parser_->_error_type ())
        this->refpos_offset_parser_->_copy_error (ctx);
      else
        this->refpos_offset_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->refpos_offset_parser_->_characters (s);

      if (!ctx.error_type ())
        this->refpos_offset_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->refpos_offset_parser_->post_byte ();

        if (this->refpos_offset_parser_->_error_type ())
          this->refpos_offset_parser_->_copy_error (ctx);
        else
          this->refpos_offset (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for encoderType_pskel.
//
bool encoderType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "type" && ns.empty ())
  {
    if (this->type_parser_)
    {
      this->type_parser_->pre ();

      if (this->type_parser_->_error_type ())
        this->type_parser_->_copy_error (ctx);
      else
        this->type_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->type_parser_->_characters (s);

      if (!ctx.error_type ())
        this->type_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->type_parser_->post_byte ();

        if (this->type_parser_->_error_type ())
          this->type_parser_->_copy_error (ctx);
        else
          this->type (tmp);
      }
    }

    return true;
  }

  if (n == "resolution" && ns.empty ())
  {
    if (this->resolution_parser_)
    {
      this->resolution_parser_->pre ();

      if (this->resolution_parser_->_error_type ())
        this->resolution_parser_->_copy_error (ctx);
      else
        this->resolution_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->resolution_parser_->_characters (s);

      if (!ctx.error_type ())
        this->resolution_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->resolution_parser_->post_short ();

        if (this->resolution_parser_->_error_type ())
          this->resolution_parser_->_copy_error (ctx);
        else
          this->resolution (tmp);
      }
    }

    return true;
  }

  if (n == "rotation" && ns.empty ())
  {
    if (this->rotation_parser_)
    {
      this->rotation_parser_->pre ();

      if (this->rotation_parser_->_error_type ())
        this->rotation_parser_->_copy_error (ctx);
      else
        this->rotation_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->rotation_parser_->_characters (s);

      if (!ctx.error_type ())
        this->rotation_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->rotation_parser_->post_string ();

        if (this->rotation_parser_->_error_type ())
          this->rotation_parser_->_copy_error (ctx);
        else
          this->rotation (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for configurationType_pskel.
//
bool configurationType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "polarity" && ns.empty ())
  {
    if (this->polarity_parser_)
    {
      this->polarity_parser_->pre ();

      if (this->polarity_parser_->_error_type ())
        this->polarity_parser_->_copy_error (ctx);
      else
        this->polarity_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->polarity_parser_->_characters (s);

      if (!ctx.error_type ())
        this->polarity_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->polarity_parser_->post_byte ();

        if (this->polarity_parser_->_error_type ())
          this->polarity_parser_->_copy_error (ctx);
        else
          this->polarity (tmp);
      }
    }

    return true;
  }

  if (n == "sample_rate" && ns.empty ())
  {
    if (this->sample_rate_parser_)
    {
      this->sample_rate_parser_->pre ();

      if (this->sample_rate_parser_->_error_type ())
        this->sample_rate_parser_->_copy_error (ctx);
      else
        this->sample_rate_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->sample_rate_parser_->_characters (s);

      if (!ctx.error_type ())
        this->sample_rate_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->sample_rate_parser_->post_byte ();

        if (this->sample_rate_parser_->_error_type ())
          this->sample_rate_parser_->_copy_error (ctx);
        else
          this->sample_rate (tmp);
      }
    }

    return true;
  }

  if (n == "debounce" && ns.empty ())
  {
    if (this->debounce_parser_)
    {
      this->debounce_parser_->pre ();

      if (this->debounce_parser_->_error_type ())
        this->debounce_parser_->_copy_error (ctx);
      else
        this->debounce_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->debounce_parser_->_characters (s);

      if (!ctx.error_type ())
        this->debounce_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->debounce_parser_->post_byte ();

        if (this->debounce_parser_->_error_type ())
          this->debounce_parser_->_copy_error (ctx);
        else
          this->debounce (tmp);
      }
    }

    return true;
  }

  if (n == "temp_tolerance" && ns.empty ())
  {
    if (this->temp_tolerance_parser_)
    {
      this->temp_tolerance_parser_->pre ();

      if (this->temp_tolerance_parser_->_error_type ())
        this->temp_tolerance_parser_->_copy_error (ctx);
      else
        this->temp_tolerance_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->temp_tolerance_parser_->_characters (s);

      if (!ctx.error_type ())
        this->temp_tolerance_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->temp_tolerance_parser_->post_byte ();

        if (this->temp_tolerance_parser_->_error_type ())
          this->temp_tolerance_parser_->_copy_error (ctx);
        else
          this->temp_tolerance (tmp);
      }
    }

    return true;
  }

  if (n == "sampling_period" && ns.empty ())
  {
    if (this->sampling_period_parser_)
    {
      this->sampling_period_parser_->pre ();

      if (this->sampling_period_parser_->_error_type ())
        this->sampling_period_parser_->_copy_error (ctx);
      else
        this->sampling_period_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->sampling_period_parser_->_characters (s);

      if (!ctx.error_type ())
        this->sampling_period_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->sampling_period_parser_->post_short ();

        if (this->sampling_period_parser_->_error_type ())
          this->sampling_period_parser_->_copy_error (ctx);
        else
          this->sampling_period (tmp);
      }
    }

    return true;
  }

  if (n == "fan_speed" && ns.empty ())
  {
    if (this->fan_speed_parser_)
    {
      this->fan_speed_parser_->pre ();

      if (this->fan_speed_parser_->_error_type ())
        this->fan_speed_parser_->_copy_error (ctx);
      else
        this->fan_speed_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->fan_speed_parser_->_characters (s);

      if (!ctx.error_type ())
        this->fan_speed_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->fan_speed_parser_->post_short ();

        if (this->fan_speed_parser_->_error_type ())
          this->fan_speed_parser_->_copy_error (ctx);
        else
          this->fan_speed (tmp);
      }
    }

    return true;
  }

  if (n == "fan_threshold" && ns.empty ())
  {
    if (this->fan_threshold_parser_)
    {
      this->fan_threshold_parser_->pre ();

      if (this->fan_threshold_parser_->_error_type ())
        this->fan_threshold_parser_->_copy_error (ctx);
      else
        this->fan_threshold_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->fan_threshold_parser_->_characters (s);

      if (!ctx.error_type ())
        this->fan_threshold_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->fan_threshold_parser_->post_short ();

        if (this->fan_threshold_parser_->_error_type ())
          this->fan_threshold_parser_->_copy_error (ctx);
        else
          this->fan_threshold (tmp);
      }
    }

    return true;
  }

  if (n == "current_gain" && ns.empty ())
  {
    if (this->current_gain_parser_)
    {
      this->current_gain_parser_->pre ();

      if (this->current_gain_parser_->_error_type ())
        this->current_gain_parser_->_copy_error (ctx);
      else
        this->current_gain_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->current_gain_parser_->_characters (s);

      if (!ctx.error_type ())
        this->current_gain_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->current_gain_parser_->post_short ();

        if (this->current_gain_parser_->_error_type ())
          this->current_gain_parser_->_copy_error (ctx);
        else
          this->current_gain (tmp);
      }
    }

    return true;
  }

  if (n == "heater_current" && ns.empty ())
  {
    if (this->heater_current_parser_)
    {
      this->heater_current_parser_->pre ();

      if (this->heater_current_parser_->_error_type ())
        this->heater_current_parser_->_copy_error (ctx);
      else
        this->heater_current_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->heater_current_parser_->_characters (s);

      if (!ctx.error_type ())
        this->heater_current_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->heater_current_parser_->post_short ();

        if (this->heater_current_parser_->_error_type ())
          this->heater_current_parser_->_copy_error (ctx);
        else
          this->heater_current (tmp);
      }
    }

    return true;
  }

  if (n == "heater_threshold" && ns.empty ())
  {
    if (this->heater_threshold_parser_)
    {
      this->heater_threshold_parser_->pre ();

      if (this->heater_threshold_parser_->_error_type ())
        this->heater_threshold_parser_->_copy_error (ctx);
      else
        this->heater_threshold_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->heater_threshold_parser_->_characters (s);

      if (!ctx.error_type ())
        this->heater_threshold_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->heater_threshold_parser_->post_short ();

        if (this->heater_threshold_parser_->_error_type ())
          this->heater_threshold_parser_->_copy_error (ctx);
        else
          this->heater_threshold (tmp);
      }
    }

    return true;
  }

  if (n == "current_deviation" && ns.empty ())
  {
    if (this->current_deviation_parser_)
    {
      this->current_deviation_parser_->pre ();

      if (this->current_deviation_parser_->_error_type ())
        this->current_deviation_parser_->_copy_error (ctx);
      else
        this->current_deviation_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->current_deviation_parser_->_characters (s);

      if (!ctx.error_type ())
        this->current_deviation_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->current_deviation_parser_->post_short ();

        if (this->current_deviation_parser_->_error_type ())
          this->current_deviation_parser_->_copy_error (ctx);
        else
          this->current_deviation (tmp);
      }
    }

    return true;
  }

  if (n == "current_min_230_serial" && ns.empty ())
  {
    if (this->current_min_230_serial_parser_)
    {
      this->current_min_230_serial_parser_->pre ();

      if (this->current_min_230_serial_parser_->_error_type ())
        this->current_min_230_serial_parser_->_copy_error (ctx);
      else
        this->current_min_230_serial_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->current_min_230_serial_parser_->_characters (s);

      if (!ctx.error_type ())
        this->current_min_230_serial_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->current_min_230_serial_parser_->post_short ();

        if (this->current_min_230_serial_parser_->_error_type ())
          this->current_min_230_serial_parser_->_copy_error (ctx);
        else
          this->current_min_230_serial (tmp);
      }
    }

    return true;
  }

  if (n == "current_max_230_serial" && ns.empty ())
  {
    if (this->current_max_230_serial_parser_)
    {
      this->current_max_230_serial_parser_->pre ();

      if (this->current_max_230_serial_parser_->_error_type ())
        this->current_max_230_serial_parser_->_copy_error (ctx);
      else
        this->current_max_230_serial_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->current_max_230_serial_parser_->_characters (s);

      if (!ctx.error_type ())
        this->current_max_230_serial_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->current_max_230_serial_parser_->post_short ();

        if (this->current_max_230_serial_parser_->_error_type ())
          this->current_max_230_serial_parser_->_copy_error (ctx);
        else
          this->current_max_230_serial (tmp);
      }
    }

    return true;
  }

  if (n == "current_min_100_serial" && ns.empty ())
  {
    if (this->current_min_100_serial_parser_)
    {
      this->current_min_100_serial_parser_->pre ();

      if (this->current_min_100_serial_parser_->_error_type ())
        this->current_min_100_serial_parser_->_copy_error (ctx);
      else
        this->current_min_100_serial_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->current_min_100_serial_parser_->_characters (s);

      if (!ctx.error_type ())
        this->current_min_100_serial_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->current_min_100_serial_parser_->post_short ();

        if (this->current_min_100_serial_parser_->_error_type ())
          this->current_min_100_serial_parser_->_copy_error (ctx);
        else
          this->current_min_100_serial (tmp);
      }
    }

    return true;
  }

  if (n == "current_max_100_serial" && ns.empty ())
  {
    if (this->current_max_100_serial_parser_)
    {
      this->current_max_100_serial_parser_->pre ();

      if (this->current_max_100_serial_parser_->_error_type ())
        this->current_max_100_serial_parser_->_copy_error (ctx);
      else
        this->current_max_100_serial_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->current_max_100_serial_parser_->_characters (s);

      if (!ctx.error_type ())
        this->current_max_100_serial_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->current_max_100_serial_parser_->post_short ();

        if (this->current_max_100_serial_parser_->_error_type ())
          this->current_max_100_serial_parser_->_copy_error (ctx);
        else
          this->current_max_100_serial (tmp);
      }
    }

    return true;
  }

  if (n == "current_min_100_parallel" && ns.empty ())
  {
    if (this->current_min_100_parallel_parser_)
    {
      this->current_min_100_parallel_parser_->pre ();

      if (this->current_min_100_parallel_parser_->_error_type ())
        this->current_min_100_parallel_parser_->_copy_error (ctx);
      else
        this->current_min_100_parallel_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->current_min_100_parallel_parser_->_characters (s);

      if (!ctx.error_type ())
        this->current_min_100_parallel_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->current_min_100_parallel_parser_->post_short ();

        if (this->current_min_100_parallel_parser_->_error_type ())
          this->current_min_100_parallel_parser_->_copy_error (ctx);
        else
          this->current_min_100_parallel (tmp);
      }
    }

    return true;
  }

  if (n == "current_max_100_parallel" && ns.empty ())
  {
    if (this->current_max_100_parallel_parser_)
    {
      this->current_max_100_parallel_parser_->pre ();

      if (this->current_max_100_parallel_parser_->_error_type ())
        this->current_max_100_parallel_parser_->_copy_error (ctx);
      else
        this->current_max_100_parallel_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->current_max_100_parallel_parser_->_characters (s);

      if (!ctx.error_type ())
        this->current_max_100_parallel_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->current_max_100_parallel_parser_->post_short ();

        if (this->current_max_100_parallel_parser_->_error_type ())
          this->current_max_100_parallel_parser_->_copy_error (ctx);
        else
          this->current_max_100_parallel (tmp);
      }
    }

    return true;
  }

  if (n == "pressure_tolerance" && ns.empty ())
  {
    if (this->pressure_tolerance_parser_)
    {
      this->pressure_tolerance_parser_->pre ();

      if (this->pressure_tolerance_parser_->_error_type ())
        this->pressure_tolerance_parser_->_copy_error (ctx);
      else
        this->pressure_tolerance_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->pressure_tolerance_parser_->_characters (s);

      if (!ctx.error_type ())
        this->pressure_tolerance_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->pressure_tolerance_parser_->post_byte ();

        if (this->pressure_tolerance_parser_->_error_type ())
          this->pressure_tolerance_parser_->_copy_error (ctx);
        else
          this->pressure_tolerance (tmp);
      }
    }

    return true;
  }

  if (n == "fan_current_gain" && ns.empty ())
  {
    if (this->fan_current_gain_parser_)
    {
      this->fan_current_gain_parser_->pre ();

      if (this->fan_current_gain_parser_->_error_type ())
        this->fan_current_gain_parser_->_copy_error (ctx);
      else
        this->fan_current_gain_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->fan_current_gain_parser_->_characters (s);

      if (!ctx.error_type ())
        this->fan_current_gain_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->fan_current_gain_parser_->post_byte ();

        if (this->fan_current_gain_parser_->_error_type ())
          this->fan_current_gain_parser_->_copy_error (ctx);
        else
          this->fan_current_gain (tmp);
      }
    }

    return true;
  }

  if (n == "fan_current" && ns.empty ())
  {
    if (this->fan_current_parser_)
    {
      this->fan_current_parser_->pre ();

      if (this->fan_current_parser_->_error_type ())
        this->fan_current_parser_->_copy_error (ctx);
      else
        this->fan_current_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->fan_current_parser_->_characters (s);

      if (!ctx.error_type ())
        this->fan_current_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->fan_current_parser_->post_short ();

        if (this->fan_current_parser_->_error_type ())
          this->fan_current_parser_->_copy_error (ctx);
        else
          this->fan_current (tmp);
      }
    }

    return true;
  }

  if (n == "pump_current" && ns.empty ())
  {
    if (this->pump_current_parser_)
    {
      this->pump_current_parser_->pre ();

      if (this->pump_current_parser_->_error_type ())
        this->pump_current_parser_->_copy_error (ctx);
      else
        this->pump_current_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->pump_current_parser_->_characters (s);

      if (!ctx.error_type ())
        this->pump_current_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->pump_current_parser_->post_short ();

        if (this->pump_current_parser_->_error_type ())
          this->pump_current_parser_->_copy_error (ctx);
        else
          this->pump_current (tmp);
      }
    }

    return true;
  }

  if (n == "pump_threshold" && ns.empty ())
  {
    if (this->pump_threshold_parser_)
    {
      this->pump_threshold_parser_->pre ();

      if (this->pump_threshold_parser_->_error_type ())
        this->pump_threshold_parser_->_copy_error (ctx);
      else
        this->pump_threshold_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->pump_threshold_parser_->_characters (s);

      if (!ctx.error_type ())
        this->pump_threshold_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->pump_threshold_parser_->post_short ();

        if (this->pump_threshold_parser_->_error_type ())
          this->pump_threshold_parser_->_copy_error (ctx);
        else
          this->pump_threshold (tmp);
      }
    }

    return true;
  }

  if (n == "enabled" && ns.empty ())
  {
    if (this->enabled_parser_)
    {
      this->enabled_parser_->pre ();

      if (this->enabled_parser_->_error_type ())
        this->enabled_parser_->_copy_error (ctx);
      else
        this->enabled_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->enabled_parser_->_characters (s);

      if (!ctx.error_type ())
        this->enabled_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->enabled_parser_->post_byte ();

        if (this->enabled_parser_->_error_type ())
          this->enabled_parser_->_copy_error (ctx);
        else
          this->enabled (tmp);
      }
    }

    return true;
  }

  if (n == "inactiv_shutdown" && ns.empty ())
  {
    if (this->inactiv_shutdown_parser_)
    {
      this->inactiv_shutdown_parser_->pre ();

      if (this->inactiv_shutdown_parser_->_error_type ())
        this->inactiv_shutdown_parser_->_copy_error (ctx);
      else
        this->inactiv_shutdown_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->inactiv_shutdown_parser_->_characters (s);

      if (!ctx.error_type ())
        this->inactiv_shutdown_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->inactiv_shutdown_parser_->post_byte ();

        if (this->inactiv_shutdown_parser_->_error_type ())
          this->inactiv_shutdown_parser_->_copy_error (ctx);
        else
          this->inactiv_shutdown (tmp);
      }
    }

    return true;
  }

  if (n == "inactiv_emcy" && ns.empty ())
  {
    if (this->inactiv_emcy_parser_)
    {
      this->inactiv_emcy_parser_->pre ();

      if (this->inactiv_emcy_parser_->_error_type ())
        this->inactiv_emcy_parser_->_copy_error (ctx);
      else
        this->inactiv_emcy_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->inactiv_emcy_parser_->_characters (s);

      if (!ctx.error_type ())
        this->inactiv_emcy_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->inactiv_emcy_parser_->post_byte ();

        if (this->inactiv_emcy_parser_->_error_type ())
          this->inactiv_emcy_parser_->_copy_error (ctx);
        else
          this->inactiv_emcy (tmp);
      }
    }

    return true;
  }

  if (n == "outval_inactiv" && ns.empty ())
  {
    if (this->outval_inactiv_parser_)
    {
      this->outval_inactiv_parser_->pre ();

      if (this->outval_inactiv_parser_->_error_type ())
        this->outval_inactiv_parser_->_copy_error (ctx);
      else
        this->outval_inactiv_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->outval_inactiv_parser_->_characters (s);

      if (!ctx.error_type ())
        this->outval_inactiv_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->outval_inactiv_parser_->post_byte ();

        if (this->outval_inactiv_parser_->_error_type ())
          this->outval_inactiv_parser_->_copy_error (ctx);
        else
          this->outval_inactiv (tmp);
      }
    }

    return true;
  }

  if (n == "livetime_limit" && ns.empty ())
  {
    if (this->livetime_limit_parser_)
    {
      this->livetime_limit_parser_->pre ();

      if (this->livetime_limit_parser_->_error_type ())
        this->livetime_limit_parser_->_copy_error (ctx);
      else
        this->livetime_limit_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->livetime_limit_parser_->_characters (s);

      if (!ctx.error_type ())
        this->livetime_limit_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->livetime_limit_parser_->post_byte ();

        if (this->livetime_limit_parser_->_error_type ())
          this->livetime_limit_parser_->_copy_error (ctx);
        else
          this->livetime_limit (tmp);
      }
    }

    return true;
  }

  if (n == "timestamp" && ns.empty ())
  {
    if (this->timestamp_parser_)
    {
      this->timestamp_parser_->pre ();

      if (this->timestamp_parser_->_error_type ())
        this->timestamp_parser_->_copy_error (ctx);
      else
        this->timestamp_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->timestamp_parser_->_characters (s);

      if (!ctx.error_type ())
        this->timestamp_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->timestamp_parser_->post_byte ();

        if (this->timestamp_parser_->_error_type ())
          this->timestamp_parser_->_copy_error (ctx);
        else
          this->timestamp (tmp);
      }
    }

    return true;
  }

  if (n == "threshold" && ns.empty ())
  {
    if (this->threshold_parser_)
    {
      this->threshold_parser_->pre ();

      if (this->threshold_parser_->_error_type ())
        this->threshold_parser_->_copy_error (ctx);
      else
        this->threshold_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->threshold_parser_->_characters (s);

      if (!ctx.error_type ())
        this->threshold_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->threshold_parser_->post_byte ();

        if (this->threshold_parser_->_error_type ())
          this->threshold_parser_->_copy_error (ctx);
        else
          this->threshold (tmp);
      }
    }

    return true;
  }

  if (n == "interval" && ns.empty ())
  {
    if (this->interval_parser_)
    {
      this->interval_parser_->pre ();

      if (this->interval_parser_->_error_type ())
        this->interval_parser_->_copy_error (ctx);
      else
        this->interval_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->interval_parser_->_characters (s);

      if (!ctx.error_type ())
        this->interval_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->interval_parser_->post_byte ();

        if (this->interval_parser_->_error_type ())
          this->interval_parser_->_copy_error (ctx);
        else
          this->interval (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for limitswitchType_pskel.
//
bool limitswitchType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "index" && ns.empty ())
  {
    if (this->index_parser_)
    {
      this->index_parser_->pre ();

      if (this->index_parser_->_error_type ())
        this->index_parser_->_copy_error (ctx);
      else
        this->index_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->index_parser_->_characters (s);

      if (!ctx.error_type ())
        this->index_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->index_parser_->post_byte ();

        if (this->index_parser_->_error_type ())
          this->index_parser_->_copy_error (ctx);
        else
          this->index (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for position_codeType_pskel.
//
bool position_codeType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "value" && ns.empty ())
  {
    if (this->value_parser_)
    {
      this->value_parser_->pre ();

      if (this->value_parser_->_error_type ())
        this->value_parser_->_copy_error (ctx);
      else
        this->value_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->value_parser_->_characters (s);

      if (!ctx.error_type ())
        this->value_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->value_parser_->post_byte ();

        if (this->value_parser_->_error_type ())
          this->value_parser_->_copy_error (ctx);
        else
          this->value (tmp);
      }
    }

    return true;
  }

  if (n == "stop" && ns.empty ())
  {
    if (this->stop_parser_)
    {
      this->stop_parser_->pre ();

      if (this->stop_parser_->_error_type ())
        this->stop_parser_->_copy_error (ctx);
      else
        this->stop_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->stop_parser_->_characters (s);

      if (!ctx.error_type ())
        this->stop_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->stop_parser_->post_byte ();

        if (this->stop_parser_->_error_type ())
          this->stop_parser_->_copy_error (ctx);
        else
          this->stop (tmp);
      }
    }

    return true;
  }

  if (n == "stop_dir" && ns.empty ())
  {
    if (this->stop_dir_parser_)
    {
      this->stop_dir_parser_->pre ();

      if (this->stop_dir_parser_->_error_type ())
        this->stop_dir_parser_->_copy_error (ctx);
      else
        this->stop_dir_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->stop_dir_parser_->_characters (s);

      if (!ctx.error_type ())
        this->stop_dir_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->stop_dir_parser_->post_string ();

        if (this->stop_dir_parser_->_error_type ())
          this->stop_dir_parser_->_copy_error (ctx);
        else
          this->stop_dir (tmp);
      }
    }

    return true;
  }

  if (n == "position" && ns.empty ())
  {
    if (this->position_parser_)
    {
      this->position_parser_->pre ();

      if (this->position_parser_->_error_type ())
        this->position_parser_->_copy_error (ctx);
      else
        this->position_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->position_parser_->_characters (s);

      if (!ctx.error_type ())
        this->position_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->position_parser_->post_byte ();

        if (this->position_parser_->_error_type ())
          this->position_parser_->_copy_error (ctx);
        else
          this->position (tmp);
      }
    }

    return true;
  }

  if (n == "width" && ns.empty ())
  {
    if (this->width_parser_)
    {
      this->width_parser_->pre ();

      if (this->width_parser_->_error_type ())
        this->width_parser_->_copy_error (ctx);
      else
        this->width_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->width_parser_->_characters (s);

      if (!ctx.error_type ())
        this->width_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->width_parser_->post_byte ();

        if (this->width_parser_->_error_type ())
          this->width_parser_->_copy_error (ctx);
        else
          this->width (tmp);
      }
    }

    return true;
  }

  if (n == "deviation" && ns.empty ())
  {
    if (this->deviation_parser_)
    {
      this->deviation_parser_->pre ();

      if (this->deviation_parser_->_error_type ())
        this->deviation_parser_->_copy_error (ctx);
      else
        this->deviation_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->deviation_parser_->_characters (s);

      if (!ctx.error_type ())
        this->deviation_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->deviation_parser_->post_byte ();

        if (this->deviation_parser_->_error_type ())
          this->deviation_parser_->_copy_error (ctx);
        else
          this->deviation (tmp);
      }
    }

    return true;
  }

  if (n == "dir_check" && ns.empty ())
  {
    if (this->dir_check_parser_)
    {
      this->dir_check_parser_->pre ();

      if (this->dir_check_parser_->_error_type ())
        this->dir_check_parser_->_copy_error (ctx);
      else
        this->dir_check_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->dir_check_parser_->_characters (s);

      if (!ctx.error_type ())
        this->dir_check_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->dir_check_parser_->post_byte ();

        if (this->dir_check_parser_->_error_type ())
          this->dir_check_parser_->_copy_error (ctx);
        else
          this->dir_check (tmp);
      }
    }

    return true;
  }

  if (n == "hit_skip" && ns.empty ())
  {
    if (this->hit_skip_parser_)
    {
      this->hit_skip_parser_->pre ();

      if (this->hit_skip_parser_->_error_type ())
        this->hit_skip_parser_->_copy_error (ctx);
      else
        this->hit_skip_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->hit_skip_parser_->_characters (s);

      if (!ctx.error_type ())
        this->hit_skip_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->hit_skip_parser_->post_byte ();

        if (this->hit_skip_parser_->_error_type ())
          this->hit_skip_parser_->_copy_error (ctx);
        else
          this->hit_skip (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for supervisionType_pskel.
//
bool supervisionType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "steploss_warn_limit" && ns.empty ())
  {
    if (this->steploss_warn_limit_parser_)
    {
      this->steploss_warn_limit_parser_->pre ();

      if (this->steploss_warn_limit_parser_->_error_type ())
        this->steploss_warn_limit_parser_->_copy_error (ctx);
      else
        this->steploss_warn_limit_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->steploss_warn_limit_parser_->_characters (s);

      if (!ctx.error_type ())
        this->steploss_warn_limit_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->steploss_warn_limit_parser_->post_byte ();

        if (this->steploss_warn_limit_parser_->_error_type ())
          this->steploss_warn_limit_parser_->_copy_error (ctx);
        else
          this->steploss_warn_limit (tmp);
      }
    }

    return true;
  }

  if (n == "steploss_error_limit" && ns.empty ())
  {
    if (this->steploss_error_limit_parser_)
    {
      this->steploss_error_limit_parser_->pre ();

      if (this->steploss_error_limit_parser_->_error_type ())
        this->steploss_error_limit_parser_->_copy_error (ctx);
      else
        this->steploss_error_limit_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->steploss_error_limit_parser_->_characters (s);

      if (!ctx.error_type ())
        this->steploss_error_limit_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->steploss_error_limit_parser_->post_byte ();

        if (this->steploss_error_limit_parser_->_error_type ())
          this->steploss_error_limit_parser_->_copy_error (ctx);
        else
          this->steploss_error_limit (tmp);
      }
    }

    return true;
  }

  if (n == "current_limit" && ns.empty ())
  {
    if (this->current_limit_parser_)
    {
      this->current_limit_parser_->pre ();

      if (this->current_limit_parser_->_error_type ())
        this->current_limit_parser_->_copy_error (ctx);
      else
        this->current_limit_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->current_limit_parser_->_characters (s);

      if (!ctx.error_type ())
        this->current_limit_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->current_limit_parser_->post_short ();

        if (this->current_limit_parser_->_error_type ())
          this->current_limit_parser_->_copy_error (ctx);
        else
          this->current_limit (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for driverType_pskel.
//
bool driverType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "type" && ns.empty ())
  {
    if (this->type_parser_)
    {
      this->type_parser_->pre ();

      if (this->type_parser_->_error_type ())
        this->type_parser_->_copy_error (ctx);
      else
        this->type_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->type_parser_->_characters (s);

      if (!ctx.error_type ())
        this->type_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->type_parser_->post_string ();

        if (this->type_parser_->_error_type ())
          this->type_parser_->_copy_error (ctx);
        else
          this->type (tmp);
      }
    }

    return true;
  }

  if (n == "reg_chopConf" && ns.empty ())
  {
    if (this->reg_chopConf_parser_)
    {
      this->reg_chopConf_parser_->pre ();

      if (this->reg_chopConf_parser_->_error_type ())
        this->reg_chopConf_parser_->_copy_error (ctx);
      else
        this->reg_chopConf_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->reg_chopConf_parser_->_characters (s);

      if (!ctx.error_type ())
        this->reg_chopConf_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->reg_chopConf_parser_->post_string ();

        if (this->reg_chopConf_parser_->_error_type ())
          this->reg_chopConf_parser_->_copy_error (ctx);
        else
          this->reg_chopConf (tmp);
      }
    }

    return true;
  }

  if (n == "reg_smartEn" && ns.empty ())
  {
    if (this->reg_smartEn_parser_)
    {
      this->reg_smartEn_parser_->pre ();

      if (this->reg_smartEn_parser_->_error_type ())
        this->reg_smartEn_parser_->_copy_error (ctx);
      else
        this->reg_smartEn_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->reg_smartEn_parser_->_characters (s);

      if (!ctx.error_type ())
        this->reg_smartEn_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->reg_smartEn_parser_->post_string ();

        if (this->reg_smartEn_parser_->_error_type ())
          this->reg_smartEn_parser_->_copy_error (ctx);
        else
          this->reg_smartEn (tmp);
      }
    }

    return true;
  }

  if (n == "reg_sgcsConf" && ns.empty ())
  {
    if (this->reg_sgcsConf_parser_)
    {
      this->reg_sgcsConf_parser_->pre ();

      if (this->reg_sgcsConf_parser_->_error_type ())
        this->reg_sgcsConf_parser_->_copy_error (ctx);
      else
        this->reg_sgcsConf_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->reg_sgcsConf_parser_->_characters (s);

      if (!ctx.error_type ())
        this->reg_sgcsConf_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->reg_sgcsConf_parser_->post_string ();

        if (this->reg_sgcsConf_parser_->_error_type ())
          this->reg_sgcsConf_parser_->_copy_error (ctx);
        else
          this->reg_sgcsConf (tmp);
      }
    }

    return true;
  }

  if (n == "reg_drvConf" && ns.empty ())
  {
    if (this->reg_drvConf_parser_)
    {
      this->reg_drvConf_parser_->pre ();

      if (this->reg_drvConf_parser_->_error_type ())
        this->reg_drvConf_parser_->_copy_error (ctx);
      else
        this->reg_drvConf_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->reg_drvConf_parser_->_characters (s);

      if (!ctx.error_type ())
        this->reg_drvConf_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->reg_drvConf_parser_->post_string ();

        if (this->reg_drvConf_parser_->_error_type ())
          this->reg_drvConf_parser_->_copy_error (ctx);
        else
          this->reg_drvConf (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for motion_profileType_pskel.
//
bool motion_profileType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "speed_min" && ns.empty ())
  {
    if (this->speed_min_parser_)
    {
      this->speed_min_parser_->pre ();

      if (this->speed_min_parser_->_error_type ())
        this->speed_min_parser_->_copy_error (ctx);
      else
        this->speed_min_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->speed_min_parser_->_characters (s);

      if (!ctx.error_type ())
        this->speed_min_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->speed_min_parser_->post_byte ();

        if (this->speed_min_parser_->_error_type ())
          this->speed_min_parser_->_copy_error (ctx);
        else
          this->speed_min (tmp);
      }
    }

    return true;
  }

  if (n == "speed_max" && ns.empty ())
  {
    if (this->speed_max_parser_)
    {
      this->speed_max_parser_->pre ();

      if (this->speed_max_parser_->_error_type ())
        this->speed_max_parser_->_copy_error (ctx);
      else
        this->speed_max_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->speed_max_parser_->_characters (s);

      if (!ctx.error_type ())
        this->speed_max_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->speed_max_parser_->post_short ();

        if (this->speed_max_parser_->_error_type ())
          this->speed_max_parser_->_copy_error (ctx);
        else
          this->speed_max (tmp);
      }
    }

    return true;
  }

  if (n == "acc" && ns.empty ())
  {
    if (this->acc_parser_)
    {
      this->acc_parser_->pre ();

      if (this->acc_parser_->_error_type ())
        this->acc_parser_->_copy_error (ctx);
      else
        this->acc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->acc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->acc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->acc_parser_->post_short ();

        if (this->acc_parser_->_error_type ())
          this->acc_parser_->_copy_error (ctx);
        else
          this->acc (tmp);
      }
    }

    return true;
  }

  if (n == "dec" && ns.empty ())
  {
    if (this->dec_parser_)
    {
      this->dec_parser_->pre ();

      if (this->dec_parser_->_error_type ())
        this->dec_parser_->_copy_error (ctx);
      else
        this->dec_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->dec_parser_->_characters (s);

      if (!ctx.error_type ())
        this->dec_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->dec_parser_->post_short ();

        if (this->dec_parser_->_error_type ())
          this->dec_parser_->_copy_error (ctx);
        else
          this->dec (tmp);
      }
    }

    return true;
  }

  if (n == "acc_time" && ns.empty ())
  {
    if (this->acc_time_parser_)
    {
      this->acc_time_parser_->pre ();

      if (this->acc_time_parser_->_error_type ())
        this->acc_time_parser_->_copy_error (ctx);
      else
        this->acc_time_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->acc_time_parser_->_characters (s);

      if (!ctx.error_type ())
        this->acc_time_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->acc_time_parser_->post_byte ();

        if (this->acc_time_parser_->_error_type ())
          this->acc_time_parser_->_copy_error (ctx);
        else
          this->acc_time (tmp);
      }
    }

    return true;
  }

  if (n == "dec_time" && ns.empty ())
  {
    if (this->dec_time_parser_)
    {
      this->dec_time_parser_->pre ();

      if (this->dec_time_parser_->_error_type ())
        this->dec_time_parser_->_copy_error (ctx);
      else
        this->dec_time_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->dec_time_parser_->_characters (s);

      if (!ctx.error_type ())
        this->dec_time_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->dec_time_parser_->post_byte ();

        if (this->dec_time_parser_->_error_type ())
          this->dec_time_parser_->_copy_error (ctx);
        else
          this->dec_time (tmp);
      }
    }

    return true;
  }

  if (n == "micro_steps" && ns.empty ())
  {
    if (this->micro_steps_parser_)
    {
      this->micro_steps_parser_->pre ();

      if (this->micro_steps_parser_->_error_type ())
        this->micro_steps_parser_->_copy_error (ctx);
      else
        this->micro_steps_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->micro_steps_parser_->_characters (s);

      if (!ctx.error_type ())
        this->micro_steps_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->micro_steps_parser_->post_byte ();

        if (this->micro_steps_parser_->_error_type ())
          this->micro_steps_parser_->_copy_error (ctx);
        else
          this->micro_steps (tmp);
      }
    }

    return true;
  }

  if (n == "ramp_type" && ns.empty ())
  {
    if (this->ramp_type_parser_)
    {
      this->ramp_type_parser_->pre ();

      if (this->ramp_type_parser_->_error_type ())
        this->ramp_type_parser_->_copy_error (ctx);
      else
        this->ramp_type_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->ramp_type_parser_->_characters (s);

      if (!ctx.error_type ())
        this->ramp_type_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->ramp_type_parser_->post_byte ();

        if (this->ramp_type_parser_->_error_type ())
          this->ramp_type_parser_->_copy_error (ctx);
        else
          this->ramp_type (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for pid_controllerType_pskel.
//
bool pid_controllerType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "max_temperature" && ns.empty ())
  {
    if (this->max_temperature_parser_)
    {
      this->max_temperature_parser_->pre ();

      if (this->max_temperature_parser_->_error_type ())
        this->max_temperature_parser_->_copy_error (ctx);
      else
        this->max_temperature_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->max_temperature_parser_->_characters (s);

      if (!ctx.error_type ())
        this->max_temperature_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->max_temperature_parser_->post_short ();

        if (this->max_temperature_parser_->_error_type ())
          this->max_temperature_parser_->_copy_error (ctx);
        else
          this->max_temperature (tmp);
      }
    }

    return true;
  }

  if (n == "controller_gain" && ns.empty ())
  {
    if (this->controller_gain_parser_)
    {
      this->controller_gain_parser_->pre ();

      if (this->controller_gain_parser_->_error_type ())
        this->controller_gain_parser_->_copy_error (ctx);
      else
        this->controller_gain_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->controller_gain_parser_->_characters (s);

      if (!ctx.error_type ())
        this->controller_gain_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->controller_gain_parser_->post_short ();

        if (this->controller_gain_parser_->_error_type ())
          this->controller_gain_parser_->_copy_error (ctx);
        else
          this->controller_gain (tmp);
      }
    }

    return true;
  }

  if (n == "reset_time" && ns.empty ())
  {
    if (this->reset_time_parser_)
    {
      this->reset_time_parser_->pre ();

      if (this->reset_time_parser_->_error_type ())
        this->reset_time_parser_->_copy_error (ctx);
      else
        this->reset_time_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->reset_time_parser_->_characters (s);

      if (!ctx.error_type ())
        this->reset_time_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->reset_time_parser_->post_short ();

        if (this->reset_time_parser_->_error_type ())
          this->reset_time_parser_->_copy_error (ctx);
        else
          this->reset_time (tmp);
      }
    }

    return true;
  }

  if (n == "derivative_time" && ns.empty ())
  {
    if (this->derivative_time_parser_)
    {
      this->derivative_time_parser_->pre ();

      if (this->derivative_time_parser_->_error_type ())
        this->derivative_time_parser_->_copy_error (ctx);
      else
        this->derivative_time_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->derivative_time_parser_->_characters (s);

      if (!ctx.error_type ())
        this->derivative_time_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->derivative_time_parser_->post_byte ();

        if (this->derivative_time_parser_->_error_type ())
          this->derivative_time_parser_->_copy_error (ctx);
        else
          this->derivative_time (tmp);
      }
    }

    return true;
  }

  if (n == "max_pressure" && ns.empty ())
  {
    if (this->max_pressure_parser_)
    {
      this->max_pressure_parser_->pre ();

      if (this->max_pressure_parser_->_error_type ())
        this->max_pressure_parser_->_copy_error (ctx);
      else
        this->max_pressure_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->max_pressure_parser_->_characters (s);

      if (!ctx.error_type ())
        this->max_pressure_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->max_pressure_parser_->post_byte ();

        if (this->max_pressure_parser_->_error_type ())
          this->max_pressure_parser_->_copy_error (ctx);
        else
          this->max_pressure (tmp);
      }
    }

    return true;
  }

  if (n == "min_pressure" && ns.empty ())
  {
    if (this->min_pressure_parser_)
    {
      this->min_pressure_parser_->pre ();

      if (this->min_pressure_parser_->_error_type ())
        this->min_pressure_parser_->_copy_error (ctx);
      else
        this->min_pressure_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->min_pressure_parser_->_characters (s);

      if (!ctx.error_type ())
        this->min_pressure_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->min_pressure_parser_->post_byte ();

        if (this->min_pressure_parser_->_error_type ())
          this->min_pressure_parser_->_copy_error (ctx);
        else
          this->min_pressure (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for pwm_controllerType_pskel.
//
bool pwm_controllerType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "max_actuating_value" && ns.empty ())
  {
    if (this->max_actuating_value_parser_)
    {
      this->max_actuating_value_parser_->pre ();

      if (this->max_actuating_value_parser_->_error_type ())
        this->max_actuating_value_parser_->_copy_error (ctx);
      else
        this->max_actuating_value_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->max_actuating_value_parser_->_characters (s);

      if (!ctx.error_type ())
        this->max_actuating_value_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->max_actuating_value_parser_->post_short ();

        if (this->max_actuating_value_parser_->_error_type ())
          this->max_actuating_value_parser_->_copy_error (ctx);
        else
          this->max_actuating_value (tmp);
      }
    }

    return true;
  }

  if (n == "min_actuating_value" && ns.empty ())
  {
    if (this->min_actuating_value_parser_)
    {
      this->min_actuating_value_parser_->pre ();

      if (this->min_actuating_value_parser_->_error_type ())
        this->min_actuating_value_parser_->_copy_error (ctx);
      else
        this->min_actuating_value_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->min_actuating_value_parser_->_characters (s);

      if (!ctx.error_type ())
        this->min_actuating_value_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        short tmp = this->min_actuating_value_parser_->post_short ();

        if (this->min_actuating_value_parser_->_error_type ())
          this->min_actuating_value_parser_->_copy_error (ctx);
        else
          this->min_actuating_value (tmp);
      }
    }

    return true;
  }

  if (n == "max_pwm_duty" && ns.empty ())
  {
    if (this->max_pwm_duty_parser_)
    {
      this->max_pwm_duty_parser_->pre ();

      if (this->max_pwm_duty_parser_->_error_type ())
        this->max_pwm_duty_parser_->_copy_error (ctx);
      else
        this->max_pwm_duty_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->max_pwm_duty_parser_->_characters (s);

      if (!ctx.error_type ())
        this->max_pwm_duty_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->max_pwm_duty_parser_->post_byte ();

        if (this->max_pwm_duty_parser_->_error_type ())
          this->max_pwm_duty_parser_->_copy_error (ctx);
        else
          this->max_pwm_duty (tmp);
      }
    }

    return true;
  }

  if (n == "min_pwm_duty" && ns.empty ())
  {
    if (this->min_pwm_duty_parser_)
    {
      this->min_pwm_duty_parser_->pre ();

      if (this->min_pwm_duty_parser_->_error_type ())
        this->min_pwm_duty_parser_->_copy_error (ctx);
      else
        this->min_pwm_duty_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->min_pwm_duty_parser_->_characters (s);

      if (!ctx.error_type ())
        this->min_pwm_duty_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->min_pwm_duty_parser_->post_byte ();

        if (this->min_pwm_duty_parser_->_error_type ())
          this->min_pwm_duty_parser_->_copy_error (ctx);
        else
          this->min_pwm_duty (tmp);
      }
    }

    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

// Attribute validation and dispatch functions for functionmoduleType_pskel.
//
bool functionmoduleType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "type" && ns.empty ())
  {
    if (this->type_parser_)
    {
      this->type_parser_->pre ();

      if (this->type_parser_->_error_type ())
        this->type_parser_->_copy_error (ctx);
      else
        this->type_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->type_parser_->_characters (s);

      if (!ctx.error_type ())
        this->type_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->type_parser_->post_string ();

        if (this->type_parser_->_error_type ())
          this->type_parser_->_copy_error (ctx);
        else
          this->type (tmp);
      }
    }

    return true;
  }

  if (n == "key" && ns.empty ())
  {
    if (this->key_parser_)
    {
      this->key_parser_->pre ();

      if (this->key_parser_->_error_type ())
        this->key_parser_->_copy_error (ctx);
      else
        this->key_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->key_parser_->_characters (s);

      if (!ctx.error_type ())
        this->key_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->key_parser_->post_string ();

        if (this->key_parser_->_error_type ())
          this->key_parser_->_copy_error (ctx);
        else
          this->key (tmp);
      }
    }

    return true;
  }

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      if (this->name_parser_->_error_type ())
        this->name_parser_->_copy_error (ctx);
      else
        this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_string ();

        if (this->name_parser_->_error_type ())
          this->name_parser_->_copy_error (ctx);
        else
          this->name (tmp);
      }
    }

    return true;
  }

  if (n == "interface" && ns.empty ())
  {
    if (this->interface_parser_)
    {
      this->interface_parser_->pre ();

      if (this->interface_parser_->_error_type ())
        this->interface_parser_->_copy_error (ctx);
      else
        this->interface_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->interface_parser_->_characters (s);

      if (!ctx.error_type ())
        this->interface_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->interface_parser_->post_byte ();

        if (this->interface_parser_->_error_type ())
          this->interface_parser_->_copy_error (ctx);
        else
          this->interface (tmp);
      }
    }

    return true;
  }

  if (n == "fct_instanceID" && ns.empty ())
  {
    if (this->fct_instanceID_parser_)
    {
      this->fct_instanceID_parser_->pre ();

      if (this->fct_instanceID_parser_->_error_type ())
        this->fct_instanceID_parser_->_copy_error (ctx);
      else
        this->fct_instanceID_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->fct_instanceID_parser_->_characters (s);

      if (!ctx.error_type ())
        this->fct_instanceID_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->fct_instanceID_parser_->post_string ();

        if (this->fct_instanceID_parser_->_error_type ())
          this->fct_instanceID_parser_->_copy_error (ctx);
        else
          this->fct_instanceID (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for slaveType_pskel.
//
bool slaveType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "type" && ns.empty ())
  {
    if (this->type_parser_)
    {
      this->type_parser_->pre ();

      if (this->type_parser_->_error_type ())
        this->type_parser_->_copy_error (ctx);
      else
        this->type_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->type_parser_->_characters (s);

      if (!ctx.error_type ())
        this->type_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->type_parser_->post_string ();

        if (this->type_parser_->_error_type ())
          this->type_parser_->_copy_error (ctx);
        else
          this->type (tmp);
      }
    }

    return true;
  }

  if (n == "key" && ns.empty ())
  {
    if (this->key_parser_)
    {
      this->key_parser_->pre ();

      if (this->key_parser_->_error_type ())
        this->key_parser_->_copy_error (ctx);
      else
        this->key_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->key_parser_->_characters (s);

      if (!ctx.error_type ())
        this->key_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->key_parser_->post_string ();

        if (this->key_parser_->_error_type ())
          this->key_parser_->_copy_error (ctx);
        else
          this->key (tmp);
      }
    }

    return true;
  }

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      if (this->name_parser_->_error_type ())
        this->name_parser_->_copy_error (ctx);
      else
        this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_string ();

        if (this->name_parser_->_error_type ())
          this->name_parser_->_copy_error (ctx);
        else
          this->name (tmp);
      }
    }

    return true;
  }

  if (n == "virtual" && ns.empty ())
  {
    if (this->virtual__parser_)
    {
      this->virtual__parser_->pre ();

      if (this->virtual__parser_->_error_type ())
        this->virtual__parser_->_copy_error (ctx);
      else
        this->virtual__parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->virtual__parser_->_characters (s);

      if (!ctx.error_type ())
        this->virtual__parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        signed char tmp = this->virtual__parser_->post_byte ();

        if (this->virtual__parser_->_error_type ())
          this->virtual__parser_->_copy_error (ctx);
        else
          this->virtual_ (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for hwconfigType_pskel.
//
bool hwconfigType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "version" && ns.empty ())
  {
    if (this->version_parser_)
    {
      this->version_parser_->pre ();

      if (this->version_parser_->_error_type ())
        this->version_parser_->_copy_error (ctx);
      else
        this->version_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->version_parser_->_characters (s);

      if (!ctx.error_type ())
        this->version_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        float tmp = this->version_parser_->post_float ();

        if (this->version_parser_->_error_type ())
          this->version_parser_->_copy_error (ctx);
        else
          this->version (tmp);
      }
    }

    return true;
  }

  return false;
}

// Character validation functions for deviceType_pskel.
//
bool deviceType_pskel::
_characters_impl (const ::xsde::cxx::ro_string& s)
{
  this->_any_characters (s);
  return true;
}

// Character validation functions for functionmoduleType_pskel.
//
bool functionmoduleType_pskel::
_characters_impl (const ::xsde::cxx::ro_string& s)
{
  this->_any_characters (s);
  return true;
}

// Begin epilogue.
//
//
// End epilogue.

