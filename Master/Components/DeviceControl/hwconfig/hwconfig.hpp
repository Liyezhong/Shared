// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef HWCONFIG_HPP
#define HWCONFIG_HPP

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifdef XSDE_EXCEPTIONS
#error the XSD/e runtime uses exceptions while the generated code does not (reconfigure the runtime or remove --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include <string>
#include <xsde/cxx/hybrid/xml-schema.hxx>
#include <xsde/cxx/hybrid/sequence.hxx>

namespace xml_schema
{
  using ::xsde::cxx::hybrid::any_type;
  typedef ::std::string any_simple_type;

  typedef signed char byte;
  using ::xsde::cxx::hybrid::byte_base;

  typedef unsigned char unsigned_byte;
  using ::xsde::cxx::hybrid::unsigned_byte_base;

  typedef short short_;
  using ::xsde::cxx::hybrid::short_base;

  typedef unsigned short unsigned_short;
  using ::xsde::cxx::hybrid::unsigned_short_base;

  typedef int int_;
  using ::xsde::cxx::hybrid::int_base;

  typedef unsigned int unsigned_int;
  using ::xsde::cxx::hybrid::unsigned_int_base;

  typedef long long long_;
  using ::xsde::cxx::hybrid::long_base;

  typedef unsigned long long unsigned_long;
  using ::xsde::cxx::hybrid::unsigned_long_base;

  typedef long integer;
  using ::xsde::cxx::hybrid::integer_base;

  typedef long non_positive_integer;
  using ::xsde::cxx::hybrid::non_positive_integer_base;

  typedef unsigned long non_negative_integer;
  using ::xsde::cxx::hybrid::non_negative_integer_base;

  typedef unsigned long positive_integer;
  using ::xsde::cxx::hybrid::positive_integer_base;

  typedef long negative_integer;
  using ::xsde::cxx::hybrid::negative_integer_base;

  typedef bool boolean;
  using ::xsde::cxx::hybrid::boolean_base;

  typedef float float_;
  using ::xsde::cxx::hybrid::float_base;

  typedef double double_;
  using ::xsde::cxx::hybrid::double_base;

  typedef double decimal;
  using ::xsde::cxx::hybrid::decimal_base;

  typedef ::std::string string;

  typedef ::std::string normalized_string;

  typedef ::std::string token;

  typedef ::std::string name;

  typedef ::std::string nmtoken;

  typedef ::xsde::cxx::string_sequence nmtokens;

  typedef ::std::string ncname;

  typedef ::std::string language;

  typedef ::std::string id;

  typedef ::std::string idref;

  typedef ::xsde::cxx::string_sequence idrefs;

  typedef ::std::string uri;

  using ::xsde::cxx::qname;

  using ::xsde::cxx::buffer;
  typedef ::xsde::cxx::buffer base64_binary;
  typedef ::xsde::cxx::buffer hex_binary;

  using ::xsde::cxx::time_zone;
  using ::xsde::cxx::date;
  using ::xsde::cxx::date_time;
  using ::xsde::cxx::duration;
  using ::xsde::cxx::gday;
  using ::xsde::cxx::gmonth;
  using ::xsde::cxx::gmonth_day;
  using ::xsde::cxx::gyear;
  using ::xsde::cxx::gyear_month;
  using ::xsde::cxx::time;

  using ::xsde::cxx::hybrid::pod_sequence;
  using ::xsde::cxx::hybrid::fix_sequence;
  using ::xsde::cxx::hybrid::var_sequence;
  using ::xsde::cxx::string_sequence;
  using ::xsde::cxx::hybrid::data_sequence;
}

class can_interfaceType;
class tcp_interfaceType;
class serial_numberType;
class deviceType;
class devicesType;
class retortType;
class retortsType;
class parameter_masterType;
class rotationType;
class reference_runType;
class encoderType;
class configurationType;
class limitswitchType;
class position_codeType;
class limitswitchesType;
class position_coverageType;
class supervisionType;
class driverType;
class motion_profileType;
class motion_profilesType;
class pid_controllerType;
class pid_controllersType;
class pwm_controllerType;
class functionmoduleType;
class functionmodulesType;
class slaveType;
class parameter_slavesType;
class hwconfigType;

// can_interfaceType (fixed-length)
//
class can_interfaceType: public ::std::string
{
  public:
  can_interfaceType ();

  can_interfaceType (const can_interfaceType&);
  can_interfaceType& operator= (const can_interfaceType&);

  ~can_interfaceType ();

  // interface
  //
  bool
  interface_present () const;

  void
  interface_present (bool);

  const ::std::string&
  interface () const;

  ::std::string&
  interface ();

  void
  interface (const ::std::string&);

  private:
  ::std::string interface_;
  unsigned char interface_present_;
};

// tcp_interfaceType (fixed-length)
//
class tcp_interfaceType: public ::std::string
{
  public:
  tcp_interfaceType ();

  tcp_interfaceType (const tcp_interfaceType&);
  tcp_interfaceType& operator= (const tcp_interfaceType&);

  ~tcp_interfaceType ();

  // usage
  //
  bool
  usage_present () const;

  void
  usage_present (bool);

  signed char
  usage () const;

  signed char&
  usage ();

  void
  usage (signed char);

  private:
  signed char usage_;
  unsigned char usage_present_;
};

// serial_numberType (fixed-length)
//
class serial_numberType: public ::std::string
{
  public:
  serial_numberType ();

  serial_numberType (const serial_numberType&);
  serial_numberType& operator= (const serial_numberType&);

  ~serial_numberType ();

  // serialno
  //
  bool
  serialno_present () const;

  void
  serialno_present (bool);

  const ::std::string&
  serialno () const;

  ::std::string&
  serialno ();

  void
  serialno (const ::std::string&);

  private:
  ::std::string serialno_;
  unsigned char serialno_present_;
};

// deviceType (variable-length)
//
class deviceType
{
  private:
  deviceType (const deviceType&);
  deviceType& operator= (const deviceType&);

  public:
  deviceType ();

  ~deviceType ();

  // name
  //
  bool
  name_present () const;

  void
  name_present (bool);

  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // id
  //
  bool
  id_present () const;

  void
  id_present (bool);

  const ::std::string&
  id () const;

  ::std::string&
  id ();

  void
  id (const ::std::string&);

  // type
  //
  bool
  type_present () const;

  void
  type_present (bool);

  const ::std::string&
  type () const;

  ::std::string&
  type ();

  void
  type (const ::std::string&);

  // dev_instanceID
  //
  bool
  dev_instanceID_present () const;

  void
  dev_instanceID_present (bool);

  const ::std::string&
  dev_instanceID () const;

  ::std::string&
  dev_instanceID ();

  void
  dev_instanceID (const ::std::string&);

  // optional
  //
  bool
  optional_present () const;

  void
  optional_present (bool);

  signed char
  optional () const;

  signed char&
  optional ();

  void
  optional (signed char);

  // functionmodules
  //
  bool
  functionmodules_present () const;

  const ::functionmodulesType&
  functionmodules () const;

  ::functionmodulesType&
  functionmodules ();

  void
  functionmodules (::functionmodulesType*);

  private:
  ::std::string name_;
  unsigned char name_present_;
  ::std::string id_;
  unsigned char id_present_;
  ::std::string type_;
  unsigned char type_present_;
  ::std::string dev_instanceID_;
  unsigned char dev_instanceID_present_;
  signed char optional_;
  unsigned char optional_present_;
  ::functionmodulesType* functionmodules_;
};

// devicesType (variable-length)
//
class devicesType
{
  private:
  devicesType (const devicesType&);
  devicesType& operator= (const devicesType&);

  public:
  devicesType ();

  ~devicesType ();

  // device
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::deviceType > device_sequence;
  typedef device_sequence::iterator device_iterator;
  typedef device_sequence::const_iterator device_const_iterator;

  const device_sequence&
  device () const;

  device_sequence&
  device ();

  private:
  device_sequence device_;
};

// retortType (variable-length)
//
class retortType
{
  private:
  retortType (const retortType&);
  retortType& operator= (const retortType&);

  public:
  retortType ();

  ~retortType ();

  // name
  //
  bool
  name_present () const;

  void
  name_present (bool);

  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // index
  //
  bool
  index_present () const;

  void
  index_present (bool);

  signed char
  index () const;

  signed char&
  index ();

  void
  index (signed char);

  // devices
  //
  const ::devicesType&
  devices () const;

  ::devicesType&
  devices ();

  void
  devices (::devicesType*);

  private:
  ::std::string name_;
  unsigned char name_present_;
  signed char index_;
  unsigned char index_present_;
  ::devicesType* devices_;
};

// retortsType (variable-length)
//
class retortsType
{
  private:
  retortsType (const retortsType&);
  retortsType& operator= (const retortsType&);

  public:
  retortsType ();

  ~retortsType ();

  // retort
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::retortType > retort_sequence;
  typedef retort_sequence::iterator retort_iterator;
  typedef retort_sequence::const_iterator retort_const_iterator;

  const retort_sequence&
  retort () const;

  retort_sequence&
  retort ();

  private:
  retort_sequence retort_;
};

// parameter_masterType (variable-length)
//
class parameter_masterType
{
  private:
  parameter_masterType (const parameter_masterType&);
  parameter_masterType& operator= (const parameter_masterType&);

  public:
  parameter_masterType ();

  ~parameter_masterType ();

  // folded
  //
  bool
  folded_present () const;

  void
  folded_present (bool);

  const ::std::string&
  folded () const;

  ::std::string&
  folded ();

  void
  folded (const ::std::string&);

  // can_interface
  //
  const ::can_interfaceType&
  can_interface () const;

  ::can_interfaceType&
  can_interface ();

  void
  can_interface (const ::can_interfaceType&);

  // tcp_interface
  //
  const ::tcp_interfaceType&
  tcp_interface () const;

  ::tcp_interfaceType&
  tcp_interface ();

  void
  tcp_interface (const ::tcp_interfaceType&);

  // nodetype
  //
  signed char
  nodetype () const;

  signed char&
  nodetype ();

  void
  nodetype (signed char);

  // nodeindex
  //
  signed char
  nodeindex () const;

  signed char&
  nodeindex ();

  void
  nodeindex (signed char);

  // serial_number
  //
  const ::serial_numberType&
  serial_number () const;

  ::serial_numberType&
  serial_number ();

  void
  serial_number (const ::serial_numberType&);

  // retorts
  //
  const ::retortsType&
  retorts () const;

  ::retortsType&
  retorts ();

  void
  retorts (::retortsType*);

  private:
  ::std::string folded_;
  unsigned char folded_present_;
  ::can_interfaceType can_interface_;
  ::tcp_interfaceType tcp_interface_;
  signed char nodetype_;
  signed char nodeindex_;
  ::serial_numberType serial_number_;
  ::retortsType* retorts_;
};

// rotationType (fixed-length)
//
class rotationType: public ::std::string
{
  public:
  rotationType ();

  rotationType (const rotationType&);
  rotationType& operator= (const rotationType&);

  ~rotationType ();

  // type
  //
  bool
  type_present () const;

  void
  type_present (bool);

  const ::std::string&
  type () const;

  ::std::string&
  type ();

  void
  type (const ::std::string&);

  // direction
  //
  bool
  direction_present () const;

  void
  direction_present (bool);

  const ::std::string&
  direction () const;

  ::std::string&
  direction ();

  void
  direction (const ::std::string&);

  // steps_revolution
  //
  bool
  steps_revolution_present () const;

  void
  steps_revolution_present (bool);

  short
  steps_revolution () const;

  short&
  steps_revolution ();

  void
  steps_revolution (short);

  // position_min
  //
  bool
  position_min_present () const;

  void
  position_min_present (bool);

  short
  position_min () const;

  short&
  position_min ();

  void
  position_min (short);

  // position_max
  //
  bool
  position_max_present () const;

  void
  position_max_present (bool);

  short
  position_max () const;

  short&
  position_max ();

  void
  position_max (short);

  // speed_min
  //
  bool
  speed_min_present () const;

  void
  speed_min_present (bool);

  signed char
  speed_min () const;

  signed char&
  speed_min ();

  void
  speed_min (signed char);

  // speed_max
  //
  bool
  speed_max_present () const;

  void
  speed_max_present (bool);

  short
  speed_max () const;

  short&
  speed_max ();

  void
  speed_max (short);

  // run_cs
  //
  bool
  run_cs_present () const;

  void
  run_cs_present (bool);

  signed char
  run_cs () const;

  signed char&
  run_cs ();

  void
  run_cs (signed char);

  // stop_cs
  //
  bool
  stop_cs_present () const;

  void
  stop_cs_present (bool);

  signed char
  stop_cs () const;

  signed char&
  stop_cs ();

  void
  stop_cs (signed char);

  // stop_cs_delay
  //
  bool
  stop_cs_delay_present () const;

  void
  stop_cs_delay_present (bool);

  short
  stop_cs_delay () const;

  short&
  stop_cs_delay ();

  void
  stop_cs_delay (short);

  private:
  ::std::string type_;
  unsigned char type_present_;
  ::std::string direction_;
  unsigned char direction_present_;
  short steps_revolution_;
  unsigned char steps_revolution_present_;
  short position_min_;
  unsigned char position_min_present_;
  short position_max_;
  unsigned char position_max_present_;
  signed char speed_min_;
  unsigned char speed_min_present_;
  short speed_max_;
  unsigned char speed_max_present_;
  signed char run_cs_;
  unsigned char run_cs_present_;
  signed char stop_cs_;
  unsigned char stop_cs_present_;
  short stop_cs_delay_;
  unsigned char stop_cs_delay_present_;
};

// reference_runType (fixed-length)
//
class reference_runType: public ::std::string
{
  public:
  reference_runType ();

  reference_runType (const reference_runType&);
  reference_runType& operator= (const reference_runType&);

  ~reference_runType ();

  // ref_position
  //
  bool
  ref_position_present () const;

  void
  ref_position_present (bool);

  signed char
  ref_position () const;

  signed char&
  ref_position ();

  void
  ref_position (signed char);

  // max_distance
  //
  bool
  max_distance_present () const;

  void
  max_distance_present (bool);

  short
  max_distance () const;

  short&
  max_distance ();

  void
  max_distance (short);

  // timeout
  //
  bool
  timeout_present () const;

  void
  timeout_present (bool);

  int
  timeout () const;

  int&
  timeout ();

  void
  timeout (int);

  // reverse_distance
  //
  bool
  reverse_distance_present () const;

  void
  reverse_distance_present (bool);

  signed char
  reverse_distance () const;

  signed char&
  reverse_distance ();

  void
  reverse_distance (signed char);

  // slow_speed
  //
  bool
  slow_speed_present () const;

  void
  slow_speed_present (bool);

  signed char
  slow_speed () const;

  signed char&
  slow_speed ();

  void
  slow_speed (signed char);

  // high_speed
  //
  bool
  high_speed_present () const;

  void
  high_speed_present (bool);

  short
  high_speed () const;

  short&
  high_speed ();

  void
  high_speed (short);

  // refpos_offset
  //
  bool
  refpos_offset_present () const;

  void
  refpos_offset_present (bool);

  signed char
  refpos_offset () const;

  signed char&
  refpos_offset ();

  void
  refpos_offset (signed char);

  private:
  signed char ref_position_;
  unsigned char ref_position_present_;
  short max_distance_;
  unsigned char max_distance_present_;
  int timeout_;
  unsigned char timeout_present_;
  signed char reverse_distance_;
  unsigned char reverse_distance_present_;
  signed char slow_speed_;
  unsigned char slow_speed_present_;
  short high_speed_;
  unsigned char high_speed_present_;
  signed char refpos_offset_;
  unsigned char refpos_offset_present_;
};

// encoderType (fixed-length)
//
class encoderType: public ::std::string
{
  public:
  encoderType ();

  encoderType (const encoderType&);
  encoderType& operator= (const encoderType&);

  ~encoderType ();

  // type
  //
  bool
  type_present () const;

  void
  type_present (bool);

  signed char
  type () const;

  signed char&
  type ();

  void
  type (signed char);

  // resolution
  //
  bool
  resolution_present () const;

  void
  resolution_present (bool);

  short
  resolution () const;

  short&
  resolution ();

  void
  resolution (short);

  // rotation
  //
  bool
  rotation_present () const;

  void
  rotation_present (bool);

  const ::std::string&
  rotation () const;

  ::std::string&
  rotation ();

  void
  rotation (const ::std::string&);

  private:
  signed char type_;
  unsigned char type_present_;
  short resolution_;
  unsigned char resolution_present_;
  ::std::string rotation_;
  unsigned char rotation_present_;
};

// configurationType (fixed-length)
//
class configurationType: public ::std::string
{
  public:
  configurationType ();

  configurationType (const configurationType&);
  configurationType& operator= (const configurationType&);

  ~configurationType ();

  // polarity
  //
  bool
  polarity_present () const;

  void
  polarity_present (bool);

  signed char
  polarity () const;

  signed char&
  polarity ();

  void
  polarity (signed char);

  // sample_rate
  //
  bool
  sample_rate_present () const;

  void
  sample_rate_present (bool);

  signed char
  sample_rate () const;

  signed char&
  sample_rate ();

  void
  sample_rate (signed char);

  // debounce
  //
  bool
  debounce_present () const;

  void
  debounce_present (bool);

  signed char
  debounce () const;

  signed char&
  debounce ();

  void
  debounce (signed char);

  // temp_tolerance
  //
  bool
  temp_tolerance_present () const;

  void
  temp_tolerance_present (bool);

  signed char
  temp_tolerance () const;

  signed char&
  temp_tolerance ();

  void
  temp_tolerance (signed char);

  // sampling_period
  //
  bool
  sampling_period_present () const;

  void
  sampling_period_present (bool);

  short
  sampling_period () const;

  short&
  sampling_period ();

  void
  sampling_period (short);

  // fan_speed
  //
  bool
  fan_speed_present () const;

  void
  fan_speed_present (bool);

  short
  fan_speed () const;

  short&
  fan_speed ();

  void
  fan_speed (short);

  // fan_threshold
  //
  bool
  fan_threshold_present () const;

  void
  fan_threshold_present (bool);

  short
  fan_threshold () const;

  short&
  fan_threshold ();

  void
  fan_threshold (short);

  // current_gain
  //
  bool
  current_gain_present () const;

  void
  current_gain_present (bool);

  short
  current_gain () const;

  short&
  current_gain ();

  void
  current_gain (short);

  // heater_current
  //
  bool
  heater_current_present () const;

  void
  heater_current_present (bool);

  short
  heater_current () const;

  short&
  heater_current ();

  void
  heater_current (short);

  // heater_threshold
  //
  bool
  heater_threshold_present () const;

  void
  heater_threshold_present (bool);

  short
  heater_threshold () const;

  short&
  heater_threshold ();

  void
  heater_threshold (short);

  // current_deviation
  //
  bool
  current_deviation_present () const;

  void
  current_deviation_present (bool);

  short
  current_deviation () const;

  short&
  current_deviation ();

  void
  current_deviation (short);

  // current_min_230_serial
  //
  bool
  current_min_230_serial_present () const;

  void
  current_min_230_serial_present (bool);

  short
  current_min_230_serial () const;

  short&
  current_min_230_serial ();

  void
  current_min_230_serial (short);

  // current_max_230_serial
  //
  bool
  current_max_230_serial_present () const;

  void
  current_max_230_serial_present (bool);

  short
  current_max_230_serial () const;

  short&
  current_max_230_serial ();

  void
  current_max_230_serial (short);

  // current_min_100_serial
  //
  bool
  current_min_100_serial_present () const;

  void
  current_min_100_serial_present (bool);

  short
  current_min_100_serial () const;

  short&
  current_min_100_serial ();

  void
  current_min_100_serial (short);

  // current_max_100_serial
  //
  bool
  current_max_100_serial_present () const;

  void
  current_max_100_serial_present (bool);

  short
  current_max_100_serial () const;

  short&
  current_max_100_serial ();

  void
  current_max_100_serial (short);

  // current_min_100_parallel
  //
  bool
  current_min_100_parallel_present () const;

  void
  current_min_100_parallel_present (bool);

  short
  current_min_100_parallel () const;

  short&
  current_min_100_parallel ();

  void
  current_min_100_parallel (short);

  // current_max_100_parallel
  //
  bool
  current_max_100_parallel_present () const;

  void
  current_max_100_parallel_present (bool);

  short
  current_max_100_parallel () const;

  short&
  current_max_100_parallel ();

  void
  current_max_100_parallel (short);

  // pressure_tolerance
  //
  bool
  pressure_tolerance_present () const;

  void
  pressure_tolerance_present (bool);

  signed char
  pressure_tolerance () const;

  signed char&
  pressure_tolerance ();

  void
  pressure_tolerance (signed char);

  // fan_current_gain
  //
  bool
  fan_current_gain_present () const;

  void
  fan_current_gain_present (bool);

  signed char
  fan_current_gain () const;

  signed char&
  fan_current_gain ();

  void
  fan_current_gain (signed char);

  // fan_current
  //
  bool
  fan_current_present () const;

  void
  fan_current_present (bool);

  short
  fan_current () const;

  short&
  fan_current ();

  void
  fan_current (short);

  // pump_current
  //
  bool
  pump_current_present () const;

  void
  pump_current_present (bool);

  short
  pump_current () const;

  short&
  pump_current ();

  void
  pump_current (short);

  // pump_threshold
  //
  bool
  pump_threshold_present () const;

  void
  pump_threshold_present (bool);

  short
  pump_threshold () const;

  short&
  pump_threshold ();

  void
  pump_threshold (short);

  // enabled
  //
  bool
  enabled_present () const;

  void
  enabled_present (bool);

  signed char
  enabled () const;

  signed char&
  enabled ();

  void
  enabled (signed char);

  // inactiv_shutdown
  //
  bool
  inactiv_shutdown_present () const;

  void
  inactiv_shutdown_present (bool);

  signed char
  inactiv_shutdown () const;

  signed char&
  inactiv_shutdown ();

  void
  inactiv_shutdown (signed char);

  // inactiv_emcy
  //
  bool
  inactiv_emcy_present () const;

  void
  inactiv_emcy_present (bool);

  signed char
  inactiv_emcy () const;

  signed char&
  inactiv_emcy ();

  void
  inactiv_emcy (signed char);

  // outval_inactiv
  //
  bool
  outval_inactiv_present () const;

  void
  outval_inactiv_present (bool);

  signed char
  outval_inactiv () const;

  signed char&
  outval_inactiv ();

  void
  outval_inactiv (signed char);

  // livetime_limit
  //
  bool
  livetime_limit_present () const;

  void
  livetime_limit_present (bool);

  signed char
  livetime_limit () const;

  signed char&
  livetime_limit ();

  void
  livetime_limit (signed char);

  // timestamp
  //
  bool
  timestamp_present () const;

  void
  timestamp_present (bool);

  signed char
  timestamp () const;

  signed char&
  timestamp ();

  void
  timestamp (signed char);

  // threshold
  //
  bool
  threshold_present () const;

  void
  threshold_present (bool);

  signed char
  threshold () const;

  signed char&
  threshold ();

  void
  threshold (signed char);

  // interval
  //
  bool
  interval_present () const;

  void
  interval_present (bool);

  signed char
  interval () const;

  signed char&
  interval ();

  void
  interval (signed char);

  private:
  signed char polarity_;
  unsigned char polarity_present_;
  signed char sample_rate_;
  unsigned char sample_rate_present_;
  signed char debounce_;
  unsigned char debounce_present_;
  signed char temp_tolerance_;
  unsigned char temp_tolerance_present_;
  short sampling_period_;
  unsigned char sampling_period_present_;
  short fan_speed_;
  unsigned char fan_speed_present_;
  short fan_threshold_;
  unsigned char fan_threshold_present_;
  short current_gain_;
  unsigned char current_gain_present_;
  short heater_current_;
  unsigned char heater_current_present_;
  short heater_threshold_;
  unsigned char heater_threshold_present_;
  short current_deviation_;
  unsigned char current_deviation_present_;
  short current_min_230_serial_;
  unsigned char current_min_230_serial_present_;
  short current_max_230_serial_;
  unsigned char current_max_230_serial_present_;
  short current_min_100_serial_;
  unsigned char current_min_100_serial_present_;
  short current_max_100_serial_;
  unsigned char current_max_100_serial_present_;
  short current_min_100_parallel_;
  unsigned char current_min_100_parallel_present_;
  short current_max_100_parallel_;
  unsigned char current_max_100_parallel_present_;
  signed char pressure_tolerance_;
  unsigned char pressure_tolerance_present_;
  signed char fan_current_gain_;
  unsigned char fan_current_gain_present_;
  short fan_current_;
  unsigned char fan_current_present_;
  short pump_current_;
  unsigned char pump_current_present_;
  short pump_threshold_;
  unsigned char pump_threshold_present_;
  signed char enabled_;
  unsigned char enabled_present_;
  signed char inactiv_shutdown_;
  unsigned char inactiv_shutdown_present_;
  signed char inactiv_emcy_;
  unsigned char inactiv_emcy_present_;
  signed char outval_inactiv_;
  unsigned char outval_inactiv_present_;
  signed char livetime_limit_;
  unsigned char livetime_limit_present_;
  signed char timestamp_;
  unsigned char timestamp_present_;
  signed char threshold_;
  unsigned char threshold_present_;
  signed char interval_;
  unsigned char interval_present_;
};

// limitswitchType (fixed-length)
//
class limitswitchType
{
  public:
  limitswitchType ();

  limitswitchType (const limitswitchType&);
  limitswitchType& operator= (const limitswitchType&);

  ~limitswitchType ();

  // index
  //
  bool
  index_present () const;

  void
  index_present (bool);

  signed char
  index () const;

  signed char&
  index ();

  void
  index (signed char);

  // configuration
  //
  const ::configurationType&
  configuration () const;

  ::configurationType&
  configuration ();

  void
  configuration (const ::configurationType&);

  private:
  signed char index_;
  unsigned char index_present_;
  ::configurationType configuration_;
};

// position_codeType (fixed-length)
//
class position_codeType: public ::std::string
{
  public:
  position_codeType ();

  position_codeType (const position_codeType&);
  position_codeType& operator= (const position_codeType&);

  ~position_codeType ();

  // value
  //
  bool
  value_present () const;

  void
  value_present (bool);

  signed char
  value () const;

  signed char&
  value ();

  void
  value (signed char);

  // stop
  //
  bool
  stop_present () const;

  void
  stop_present (bool);

  signed char
  stop () const;

  signed char&
  stop ();

  void
  stop (signed char);

  // stop_dir
  //
  bool
  stop_dir_present () const;

  void
  stop_dir_present (bool);

  const ::std::string&
  stop_dir () const;

  ::std::string&
  stop_dir ();

  void
  stop_dir (const ::std::string&);

  // position
  //
  bool
  position_present () const;

  void
  position_present (bool);

  signed char
  position () const;

  signed char&
  position ();

  void
  position (signed char);

  // width
  //
  bool
  width_present () const;

  void
  width_present (bool);

  signed char
  width () const;

  signed char&
  width ();

  void
  width (signed char);

  // deviation
  //
  bool
  deviation_present () const;

  void
  deviation_present (bool);

  signed char
  deviation () const;

  signed char&
  deviation ();

  void
  deviation (signed char);

  // dir_check
  //
  bool
  dir_check_present () const;

  void
  dir_check_present (bool);

  signed char
  dir_check () const;

  signed char&
  dir_check ();

  void
  dir_check (signed char);

  // hit_skip
  //
  bool
  hit_skip_present () const;

  void
  hit_skip_present (bool);

  signed char
  hit_skip () const;

  signed char&
  hit_skip ();

  void
  hit_skip (signed char);

  private:
  signed char value_;
  unsigned char value_present_;
  signed char stop_;
  unsigned char stop_present_;
  ::std::string stop_dir_;
  unsigned char stop_dir_present_;
  signed char position_;
  unsigned char position_present_;
  signed char width_;
  unsigned char width_present_;
  signed char deviation_;
  unsigned char deviation_present_;
  signed char dir_check_;
  unsigned char dir_check_present_;
  signed char hit_skip_;
  unsigned char hit_skip_present_;
};

// limitswitchesType (variable-length)
//
class limitswitchesType
{
  private:
  limitswitchesType (const limitswitchesType&);
  limitswitchesType& operator= (const limitswitchesType&);

  public:
  limitswitchesType ();

  ~limitswitchesType ();

  // limitswitch
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::limitswitchType > limitswitch_sequence;
  typedef limitswitch_sequence::iterator limitswitch_iterator;
  typedef limitswitch_sequence::const_iterator limitswitch_const_iterator;

  const limitswitch_sequence&
  limitswitch () const;

  limitswitch_sequence&
  limitswitch ();

  // position_code
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::position_codeType > position_code_sequence;
  typedef position_code_sequence::iterator position_code_iterator;
  typedef position_code_sequence::const_iterator position_code_const_iterator;

  const position_code_sequence&
  position_code () const;

  position_code_sequence&
  position_code ();

  private:
  limitswitch_sequence limitswitch_;
  position_code_sequence position_code_;
};

// position_coverageType (variable-length)
//
class position_coverageType
{
  private:
  position_coverageType (const position_coverageType&);
  position_coverageType& operator= (const position_coverageType&);

  public:
  position_coverageType ();

  ~position_coverageType ();

  // encoder
  //
  const ::encoderType&
  encoder () const;

  ::encoderType&
  encoder ();

  void
  encoder (const ::encoderType&);

  // limitswitches
  //
  const ::limitswitchesType&
  limitswitches () const;

  ::limitswitchesType&
  limitswitches ();

  void
  limitswitches (::limitswitchesType*);

  private:
  ::encoderType encoder_;
  ::limitswitchesType* limitswitches_;
};

// supervisionType (fixed-length)
//
class supervisionType: public ::std::string
{
  public:
  supervisionType ();

  supervisionType (const supervisionType&);
  supervisionType& operator= (const supervisionType&);

  ~supervisionType ();

  // steploss_warn_limit
  //
  bool
  steploss_warn_limit_present () const;

  void
  steploss_warn_limit_present (bool);

  signed char
  steploss_warn_limit () const;

  signed char&
  steploss_warn_limit ();

  void
  steploss_warn_limit (signed char);

  // steploss_error_limit
  //
  bool
  steploss_error_limit_present () const;

  void
  steploss_error_limit_present (bool);

  signed char
  steploss_error_limit () const;

  signed char&
  steploss_error_limit ();

  void
  steploss_error_limit (signed char);

  // current_limit
  //
  bool
  current_limit_present () const;

  void
  current_limit_present (bool);

  short
  current_limit () const;

  short&
  current_limit ();

  void
  current_limit (short);

  private:
  signed char steploss_warn_limit_;
  unsigned char steploss_warn_limit_present_;
  signed char steploss_error_limit_;
  unsigned char steploss_error_limit_present_;
  short current_limit_;
  unsigned char current_limit_present_;
};

// driverType (fixed-length)
//
class driverType: public ::std::string
{
  public:
  driverType ();

  driverType (const driverType&);
  driverType& operator= (const driverType&);

  ~driverType ();

  // type
  //
  bool
  type_present () const;

  void
  type_present (bool);

  const ::std::string&
  type () const;

  ::std::string&
  type ();

  void
  type (const ::std::string&);

  // reg_chopConf
  //
  bool
  reg_chopConf_present () const;

  void
  reg_chopConf_present (bool);

  const ::std::string&
  reg_chopConf () const;

  ::std::string&
  reg_chopConf ();

  void
  reg_chopConf (const ::std::string&);

  // reg_smartEn
  //
  bool
  reg_smartEn_present () const;

  void
  reg_smartEn_present (bool);

  const ::std::string&
  reg_smartEn () const;

  ::std::string&
  reg_smartEn ();

  void
  reg_smartEn (const ::std::string&);

  // reg_sgcsConf
  //
  bool
  reg_sgcsConf_present () const;

  void
  reg_sgcsConf_present (bool);

  const ::std::string&
  reg_sgcsConf () const;

  ::std::string&
  reg_sgcsConf ();

  void
  reg_sgcsConf (const ::std::string&);

  // reg_drvConf
  //
  bool
  reg_drvConf_present () const;

  void
  reg_drvConf_present (bool);

  const ::std::string&
  reg_drvConf () const;

  ::std::string&
  reg_drvConf ();

  void
  reg_drvConf (const ::std::string&);

  private:
  ::std::string type_;
  unsigned char type_present_;
  ::std::string reg_chopConf_;
  unsigned char reg_chopConf_present_;
  ::std::string reg_smartEn_;
  unsigned char reg_smartEn_present_;
  ::std::string reg_sgcsConf_;
  unsigned char reg_sgcsConf_present_;
  ::std::string reg_drvConf_;
  unsigned char reg_drvConf_present_;
};

// motion_profileType (fixed-length)
//
class motion_profileType: public ::std::string
{
  public:
  motion_profileType ();

  motion_profileType (const motion_profileType&);
  motion_profileType& operator= (const motion_profileType&);

  ~motion_profileType ();

  // speed_min
  //
  bool
  speed_min_present () const;

  void
  speed_min_present (bool);

  signed char
  speed_min () const;

  signed char&
  speed_min ();

  void
  speed_min (signed char);

  // speed_max
  //
  bool
  speed_max_present () const;

  void
  speed_max_present (bool);

  short
  speed_max () const;

  short&
  speed_max ();

  void
  speed_max (short);

  // acc
  //
  bool
  acc_present () const;

  void
  acc_present (bool);

  short
  acc () const;

  short&
  acc ();

  void
  acc (short);

  // dec
  //
  bool
  dec_present () const;

  void
  dec_present (bool);

  short
  dec () const;

  short&
  dec ();

  void
  dec (short);

  // acc_time
  //
  bool
  acc_time_present () const;

  void
  acc_time_present (bool);

  signed char
  acc_time () const;

  signed char&
  acc_time ();

  void
  acc_time (signed char);

  // dec_time
  //
  bool
  dec_time_present () const;

  void
  dec_time_present (bool);

  signed char
  dec_time () const;

  signed char&
  dec_time ();

  void
  dec_time (signed char);

  // micro_steps
  //
  bool
  micro_steps_present () const;

  void
  micro_steps_present (bool);

  signed char
  micro_steps () const;

  signed char&
  micro_steps ();

  void
  micro_steps (signed char);

  // ramp_type
  //
  bool
  ramp_type_present () const;

  void
  ramp_type_present (bool);

  signed char
  ramp_type () const;

  signed char&
  ramp_type ();

  void
  ramp_type (signed char);

  private:
  signed char speed_min_;
  unsigned char speed_min_present_;
  short speed_max_;
  unsigned char speed_max_present_;
  short acc_;
  unsigned char acc_present_;
  short dec_;
  unsigned char dec_present_;
  signed char acc_time_;
  unsigned char acc_time_present_;
  signed char dec_time_;
  unsigned char dec_time_present_;
  signed char micro_steps_;
  unsigned char micro_steps_present_;
  signed char ramp_type_;
  unsigned char ramp_type_present_;
};

// motion_profilesType (variable-length)
//
class motion_profilesType
{
  private:
  motion_profilesType (const motion_profilesType&);
  motion_profilesType& operator= (const motion_profilesType&);

  public:
  motion_profilesType ();

  ~motion_profilesType ();

  // motion_profile
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::motion_profileType > motion_profile_sequence;
  typedef motion_profile_sequence::iterator motion_profile_iterator;
  typedef motion_profile_sequence::const_iterator motion_profile_const_iterator;

  const motion_profile_sequence&
  motion_profile () const;

  motion_profile_sequence&
  motion_profile ();

  private:
  motion_profile_sequence motion_profile_;
};

// pid_controllerType (fixed-length)
//
class pid_controllerType: public ::std::string
{
  public:
  pid_controllerType ();

  pid_controllerType (const pid_controllerType&);
  pid_controllerType& operator= (const pid_controllerType&);

  ~pid_controllerType ();

  // max_temperature
  //
  bool
  max_temperature_present () const;

  void
  max_temperature_present (bool);

  short
  max_temperature () const;

  short&
  max_temperature ();

  void
  max_temperature (short);

  // controller_gain
  //
  bool
  controller_gain_present () const;

  void
  controller_gain_present (bool);

  short
  controller_gain () const;

  short&
  controller_gain ();

  void
  controller_gain (short);

  // reset_time
  //
  bool
  reset_time_present () const;

  void
  reset_time_present (bool);

  short
  reset_time () const;

  short&
  reset_time ();

  void
  reset_time (short);

  // derivative_time
  //
  bool
  derivative_time_present () const;

  void
  derivative_time_present (bool);

  signed char
  derivative_time () const;

  signed char&
  derivative_time ();

  void
  derivative_time (signed char);

  // max_pressure
  //
  bool
  max_pressure_present () const;

  void
  max_pressure_present (bool);

  signed char
  max_pressure () const;

  signed char&
  max_pressure ();

  void
  max_pressure (signed char);

  // min_pressure
  //
  bool
  min_pressure_present () const;

  void
  min_pressure_present (bool);

  signed char
  min_pressure () const;

  signed char&
  min_pressure ();

  void
  min_pressure (signed char);

  private:
  short max_temperature_;
  unsigned char max_temperature_present_;
  short controller_gain_;
  unsigned char controller_gain_present_;
  short reset_time_;
  unsigned char reset_time_present_;
  signed char derivative_time_;
  unsigned char derivative_time_present_;
  signed char max_pressure_;
  unsigned char max_pressure_present_;
  signed char min_pressure_;
  unsigned char min_pressure_present_;
};

// pid_controllersType (fixed-length)
//
class pid_controllersType
{
  public:
  pid_controllersType ();

  pid_controllersType (const pid_controllersType&);
  pid_controllersType& operator= (const pid_controllersType&);

  ~pid_controllersType ();

  // pid_controller
  //
  const ::pid_controllerType&
  pid_controller () const;

  ::pid_controllerType&
  pid_controller ();

  void
  pid_controller (const ::pid_controllerType&);

  private:
  ::pid_controllerType pid_controller_;
};

// pwm_controllerType (fixed-length)
//
class pwm_controllerType: public ::std::string
{
  public:
  pwm_controllerType ();

  pwm_controllerType (const pwm_controllerType&);
  pwm_controllerType& operator= (const pwm_controllerType&);

  ~pwm_controllerType ();

  // max_actuating_value
  //
  bool
  max_actuating_value_present () const;

  void
  max_actuating_value_present (bool);

  short
  max_actuating_value () const;

  short&
  max_actuating_value ();

  void
  max_actuating_value (short);

  // min_actuating_value
  //
  bool
  min_actuating_value_present () const;

  void
  min_actuating_value_present (bool);

  short
  min_actuating_value () const;

  short&
  min_actuating_value ();

  void
  min_actuating_value (short);

  // max_pwm_duty
  //
  bool
  max_pwm_duty_present () const;

  void
  max_pwm_duty_present (bool);

  signed char
  max_pwm_duty () const;

  signed char&
  max_pwm_duty ();

  void
  max_pwm_duty (signed char);

  // min_pwm_duty
  //
  bool
  min_pwm_duty_present () const;

  void
  min_pwm_duty_present (bool);

  signed char
  min_pwm_duty () const;

  signed char&
  min_pwm_duty ();

  void
  min_pwm_duty (signed char);

  private:
  short max_actuating_value_;
  unsigned char max_actuating_value_present_;
  short min_actuating_value_;
  unsigned char min_actuating_value_present_;
  signed char max_pwm_duty_;
  unsigned char max_pwm_duty_present_;
  signed char min_pwm_duty_;
  unsigned char min_pwm_duty_present_;
};

// functionmoduleType (variable-length)
//
class functionmoduleType
{
  private:
  functionmoduleType (const functionmoduleType&);
  functionmoduleType& operator= (const functionmoduleType&);

  public:
  functionmoduleType ();

  ~functionmoduleType ();

  // type
  //
  bool
  type_present () const;

  void
  type_present (bool);

  const ::std::string&
  type () const;

  ::std::string&
  type ();

  void
  type (const ::std::string&);

  // key
  //
  bool
  key_present () const;

  void
  key_present (bool);

  const ::std::string&
  key () const;

  ::std::string&
  key ();

  void
  key (const ::std::string&);

  // name
  //
  bool
  name_present () const;

  void
  name_present (bool);

  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // interface
  //
  bool
  interface_present () const;

  void
  interface_present (bool);

  signed char
  interface () const;

  signed char&
  interface ();

  void
  interface (signed char);

  // fct_instanceID
  //
  bool
  fct_instanceID_present () const;

  void
  fct_instanceID_present (bool);

  const ::std::string&
  fct_instanceID () const;

  ::std::string&
  fct_instanceID ();

  void
  fct_instanceID (const ::std::string&);

  // rotation
  //
  bool
  rotation_present () const;

  void
  rotation_present (bool);

  const ::rotationType&
  rotation () const;

  ::rotationType&
  rotation ();

  void
  rotation (const ::rotationType&);

  // reference_run
  //
  bool
  reference_run_present () const;

  void
  reference_run_present (bool);

  const ::reference_runType&
  reference_run () const;

  ::reference_runType&
  reference_run ();

  void
  reference_run (const ::reference_runType&);

  // position_coverage
  //
  bool
  position_coverage_present () const;

  const ::position_coverageType&
  position_coverage () const;

  ::position_coverageType&
  position_coverage ();

  void
  position_coverage (::position_coverageType*);

  // supervision
  //
  bool
  supervision_present () const;

  void
  supervision_present (bool);

  const ::supervisionType&
  supervision () const;

  ::supervisionType&
  supervision ();

  void
  supervision (const ::supervisionType&);

  // driver
  //
  bool
  driver_present () const;

  void
  driver_present (bool);

  const ::driverType&
  driver () const;

  ::driverType&
  driver ();

  void
  driver (const ::driverType&);

  // motion_profiles
  //
  bool
  motion_profiles_present () const;

  const ::motion_profilesType&
  motion_profiles () const;

  ::motion_profilesType&
  motion_profiles ();

  void
  motion_profiles (::motion_profilesType*);

  // configuration
  //
  bool
  configuration_present () const;

  void
  configuration_present (bool);

  const ::configurationType&
  configuration () const;

  ::configurationType&
  configuration ();

  void
  configuration (const ::configurationType&);

  // pid_controllers
  //
  bool
  pid_controllers_present () const;

  void
  pid_controllers_present (bool);

  const ::pid_controllersType&
  pid_controllers () const;

  ::pid_controllersType&
  pid_controllers ();

  void
  pid_controllers (const ::pid_controllersType&);

  // pwm_controller
  //
  bool
  pwm_controller_present () const;

  void
  pwm_controller_present (bool);

  const ::pwm_controllerType&
  pwm_controller () const;

  ::pwm_controllerType&
  pwm_controller ();

  void
  pwm_controller (const ::pwm_controllerType&);

  private:
  ::std::string type_;
  unsigned char type_present_;
  ::std::string key_;
  unsigned char key_present_;
  ::std::string name_;
  unsigned char name_present_;
  signed char interface_;
  unsigned char interface_present_;
  ::std::string fct_instanceID_;
  unsigned char fct_instanceID_present_;
  ::rotationType rotation_;
  unsigned char rotation_present_;
  ::reference_runType reference_run_;
  unsigned char reference_run_present_;
  ::position_coverageType* position_coverage_;
  ::supervisionType supervision_;
  unsigned char supervision_present_;
  ::driverType driver_;
  unsigned char driver_present_;
  ::motion_profilesType* motion_profiles_;
  ::configurationType configuration_;
  unsigned char configuration_present_;
  ::pid_controllersType pid_controllers_;
  unsigned char pid_controllers_present_;
  ::pwm_controllerType pwm_controller_;
  unsigned char pwm_controller_present_;
};

// functionmodulesType (variable-length)
//
class functionmodulesType
{
  private:
  functionmodulesType (const functionmodulesType&);
  functionmodulesType& operator= (const functionmodulesType&);

  public:
  functionmodulesType ();

  ~functionmodulesType ();

  // functionmodule
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::functionmoduleType > functionmodule_sequence;
  typedef functionmodule_sequence::iterator functionmodule_iterator;
  typedef functionmodule_sequence::const_iterator functionmodule_const_iterator;

  const functionmodule_sequence&
  functionmodule () const;

  functionmodule_sequence&
  functionmodule ();

  private:
  functionmodule_sequence functionmodule_;
};

// slaveType (variable-length)
//
class slaveType
{
  private:
  slaveType (const slaveType&);
  slaveType& operator= (const slaveType&);

  public:
  slaveType ();

  ~slaveType ();

  // type
  //
  bool
  type_present () const;

  void
  type_present (bool);

  const ::std::string&
  type () const;

  ::std::string&
  type ();

  void
  type (const ::std::string&);

  // key
  //
  bool
  key_present () const;

  void
  key_present (bool);

  const ::std::string&
  key () const;

  ::std::string&
  key ();

  void
  key (const ::std::string&);

  // name
  //
  bool
  name_present () const;

  void
  name_present (bool);

  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // virtual
  //
  bool
  virtual__present () const;

  void
  virtual__present (bool);

  signed char
  virtual_ () const;

  signed char&
  virtual_ ();

  void
  virtual_ (signed char);

  // nodetype
  //
  signed char
  nodetype () const;

  signed char&
  nodetype ();

  void
  nodetype (signed char);

  // nodeindex
  //
  signed char
  nodeindex () const;

  signed char&
  nodeindex ();

  void
  nodeindex (signed char);

  // functionmodules
  //
  const ::functionmodulesType&
  functionmodules () const;

  ::functionmodulesType&
  functionmodules ();

  void
  functionmodules (::functionmodulesType*);

  private:
  ::std::string type_;
  unsigned char type_present_;
  ::std::string key_;
  unsigned char key_present_;
  ::std::string name_;
  unsigned char name_present_;
  signed char virtual__;
  unsigned char virtual__present_;
  signed char nodetype_;
  signed char nodeindex_;
  ::functionmodulesType* functionmodules_;
};

// parameter_slavesType (variable-length)
//
class parameter_slavesType
{
  private:
  parameter_slavesType (const parameter_slavesType&);
  parameter_slavesType& operator= (const parameter_slavesType&);

  public:
  parameter_slavesType ();

  ~parameter_slavesType ();

  // slave
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::slaveType > slave_sequence;
  typedef slave_sequence::iterator slave_iterator;
  typedef slave_sequence::const_iterator slave_const_iterator;

  const slave_sequence&
  slave () const;

  slave_sequence&
  slave ();

  private:
  slave_sequence slave_;
};

// hwconfigType (variable-length)
//
class hwconfigType
{
  private:
  hwconfigType (const hwconfigType&);
  hwconfigType& operator= (const hwconfigType&);

  public:
  hwconfigType ();

  ~hwconfigType ();

  // version
  //
  bool
  version_present () const;

  void
  version_present (bool);

  float
  version () const;

  float&
  version ();

  void
  version (float);

  // parameter_master
  //
  const ::parameter_masterType&
  parameter_master () const;

  ::parameter_masterType&
  parameter_master ();

  void
  parameter_master (::parameter_masterType*);

  // parameter_slaves
  //
  const ::parameter_slavesType&
  parameter_slaves () const;

  ::parameter_slavesType&
  parameter_slaves ();

  void
  parameter_slaves (::parameter_slavesType*);

  // devices
  //
  const ::devicesType&
  devices () const;

  ::devicesType&
  devices ();

  void
  devices (::devicesType*);

  private:
  float version_;
  unsigned char version_present_;
  ::parameter_masterType* parameter_master_;
  ::parameter_slavesType* parameter_slaves_;
  ::devicesType* devices_;
};

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // HWCONFIG_HPP
